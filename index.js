var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
define("Constants", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.APP_NAME = void 0;
    exports.APP_NAME = "deepsight.gg / Destiny 2 Item Manager";
});
define("utility/Arrays", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Arrays;
    (function (Arrays) {
        Arrays.EMPTY = [];
        function resolve(or) {
            return Array.isArray(or) ? or : or === undefined ? [] : [or];
        }
        Arrays.resolve = resolve;
        function includes(array, value) {
            return Array.isArray(array) ? array.includes(value) : array === value;
        }
        Arrays.includes = includes;
        function slice(or) {
            return Array.isArray(or) ? or.slice() : or === undefined ? [] : [or];
        }
        Arrays.slice = slice;
        /**
         * Removes one instance of the given value from the given array.
         * @returns `true` if removed, `false` otherwise
         */
        function remove(array, ...values) {
            if (!array)
                return false;
            let removed = false;
            for (const value of values) {
                const index = array.indexOf(value);
                if (index === -1)
                    continue;
                array.splice(index, 1);
                removed = true;
            }
            return removed;
        }
        Arrays.remove = remove;
        /**
         * Removes one instance of the given value from the given array.
         * @returns `true` if removed, `false` otherwise
         */
        function removeSwap(array, ...values) {
            if (!array)
                return false;
            let removed = false;
            for (const value of values) {
                const index = array.indexOf(value);
                if (index === -1)
                    continue;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const swap = array.pop();
                if (!array.length)
                    break;
                if (index !== array.length)
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    array[index] = swap;
                removed = true;
            }
            return removed;
        }
        Arrays.removeSwap = removeSwap;
        /**
         * Adds the given value to the given array if not present.
         * @returns `true` if added, `false` otherwise
         */
        function add(array, value) {
            if (!array)
                return false;
            const index = array.indexOf(value);
            if (index !== -1)
                return false;
            array.push(value);
            return true;
        }
        Arrays.add = add;
        function tuple(...values) {
            return values;
        }
        Arrays.tuple = tuple;
        function range(start, end, step) {
            if (step === 0)
                throw new Error("Invalid step for range");
            const result = [];
            if (end === undefined)
                end = start, start = 0;
            step = end < start ? -1 : 1;
            for (let i = start; step > 0 ? i < end : i > end; i += step)
                result.push(i);
            return result;
        }
        Arrays.range = range;
        function filterNullish(value) {
            return value !== null && value !== undefined;
        }
        Arrays.filterNullish = filterNullish;
        function filterFalsy(value) {
            return !!value;
        }
        Arrays.filterFalsy = filterFalsy;
        function mergeSorted(...arrays) {
            return arrays.reduce((prev, curr) => mergeSorted2(prev, curr), []);
        }
        Arrays.mergeSorted = mergeSorted;
        function mergeSorted2(array1, array2) {
            const merged = [];
            let index1 = 0;
            let index2 = 0;
            while (index1 < array1.length || index2 < array2.length) {
                const v1 = index1 < array1.length ? array1[index1] : undefined;
                const v2 = index2 < array2.length ? array2[index2] : undefined;
                if (v1 === v2) {
                    merged.push(v1);
                    index1++;
                    index2++;
                    continue;
                }
                if (v1 === undefined && v2 !== undefined) {
                    merged.push(v2);
                    index2++;
                    continue;
                }
                if (v2 === undefined && v1 !== undefined) {
                    merged.push(v1);
                    index1++;
                    continue;
                }
                const indexOfPerson1InList2 = array2.indexOf(v1, index2);
                if (indexOfPerson1InList2 === -1) {
                    merged.push(v1);
                    index1++;
                }
                else {
                    merged.push(v2);
                    index2++;
                }
            }
            return merged;
        }
    })(Arrays || (Arrays = {}));
    exports.default = Arrays;
});
define("utility/EventManager", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventManager = void 0;
    class EventManager {
        static make() {
            return new EventManager({});
        }
        static emit(target, event, init) {
            if (init instanceof Event)
                event = init;
            if (typeof event === "string")
                event = new Event(event, { cancelable: true });
            if (typeof init === "function")
                init?.(event);
            else if (init && event !== init)
                Object.assign(event, init);
            target?.dispatchEvent(event);
            return event;
        }
        get target() {
            return this._target instanceof WeakRef ? this._target.deref() : this._target;
        }
        constructor(host, target = new EventTarget()) {
            this.subscriptions = {};
            this.pipeTargets = new Map();
            this.pipes = new Map();
            this.host = new WeakRef(host);
            this._target = target;
        }
        subscribe(type, listener, capture = true) {
            if (!Array.isArray(type))
                type = [type];
            for (const t of type)
                this.target?.addEventListener(t, listener, capture);
            return this.host.deref();
        }
        subscribeOnce(types, listener, capture = true) {
            if (!Array.isArray(types))
                types = [types];
            if (this.target) {
                const target = this.target;
                const subscriptions = this.subscriptions;
                function realListener(event) {
                    listener.call(this, event);
                    for (const type of types) {
                        subscriptions[type]?.delete(listener);
                        target?.removeEventListener(type, realListener, capture);
                    }
                }
                for (const type of types) {
                    subscriptions[type] ??= new WeakMap();
                    subscriptions[type].set(listener, realListener);
                    this.target?.addEventListener(type, realListener, capture);
                }
            }
            return this.host.deref();
        }
        unsubscribe(types, listener, capture = true) {
            if (!Array.isArray(types))
                types = [types];
            for (const type of types) {
                this.target?.removeEventListener(type, listener, capture);
                const realListener = this.subscriptions[type]?.get(listener);
                if (realListener) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    this.target?.removeEventListener(type, realListener, capture);
                    this.subscriptions[type].delete(listener);
                }
            }
            return this.host.deref();
        }
        async waitFor(types) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return new Promise(resolve => this.subscribeOnce(types, resolve));
        }
        until(promise, initialiser) {
            if (typeof promise !== "object")
                promise = this.waitFor(promise);
            const manager = {
                subscribe: (type, listener) => {
                    this.subscribe(type, listener);
                    void promise.then(() => this.unsubscribe(type, listener));
                    return manager;
                },
                subscribeOnce: (type, listener) => {
                    this.subscribeOnce(type, listener);
                    void promise.then(() => this.unsubscribe(type, listener));
                    return manager;
                },
            };
            initialiser?.(manager);
            return this.host.deref();
        }
        emit(event, init) {
            event = EventManager.emit(this.target, event, init);
            const pipeTargets = this.pipeTargets.get(event.type);
            if (pipeTargets) {
                for (let i = 0; i < pipeTargets.length; i++) {
                    const pipeTarget = pipeTargets[i].deref();
                    if (pipeTarget)
                        pipeTarget.dispatchEvent(event);
                    else
                        pipeTargets.splice(i--, 1);
                }
                if (!pipeTargets.length)
                    this.pipeTargets.delete(event.type);
            }
            return this.host.deref();
        }
        pipe(type, on) {
            const typeName = type;
            on.insertPipe(typeName, this._target instanceof WeakRef ? this._target : new WeakRef(this._target));
            let pipes = this.pipes.get(typeName);
            if (!pipes) {
                pipes = [];
                this.pipes.set(typeName, pipes);
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            pipes.push(new WeakRef(on));
            return this;
        }
        insertPipe(type, target) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            let pipeTargets = this.pipeTargets.get(type);
            if (!pipeTargets) {
                pipeTargets = [];
                this.pipeTargets.set(type, pipeTargets);
            }
            pipeTargets.push(target);
            const pipes = this.pipes.get(type);
            if (pipes) {
                for (let i = 0; i < pipes.length; i++) {
                    const pipe = pipes[i].deref();
                    if (pipe)
                        pipe.insertPipe(type, target);
                    else
                        pipes.splice(i--, 1);
                }
                if (!pipes.length)
                    this.pipes.delete(type);
            }
        }
    }
    exports.EventManager = EventManager;
    EventManager.global = EventManager.make();
});
define("utility/Type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("utility/Objects", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Objects;
    (function (Objects) {
        Objects.EMPTY = {};
        function inherit(obj, inherits) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
            Object.setPrototypeOf(obj, inherits.prototype);
            return obj;
        }
        Objects.inherit = inherit;
        function map(object, mapper) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unnecessary-type-assertion
            return Object.fromEntries(Object.entries(object).map(mapper));
        }
        Objects.map = map;
        async function mapAsync(object, mapper) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return Object.fromEntries(await Promise.all(Object.entries(object).map(mapper)));
        }
        Objects.mapAsync = mapAsync;
        function followPath(obj, keys) {
            for (const key of keys)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
                obj = obj?.[key];
            return obj;
        }
        Objects.followPath = followPath;
        function applyJIT(obj, key, compute) {
            const get = (() => {
                const promise = compute();
                delete obj[key];
                obj[key] = promise;
                if (promise instanceof Promise)
                    void promise.then(value => obj[key] = value);
                return promise;
            });
            get.compute = compute;
            Object.defineProperty(obj, key, {
                configurable: true,
                get,
            });
        }
        Objects.applyJIT = applyJIT;
        function copyJIT(target, from, key) {
            const descriptor = Object.getOwnPropertyDescriptor(from, key);
            if (!descriptor)
                return;
            if ("value" in descriptor) {
                target[key] = from[key];
                return;
            }
            const compute = descriptor.get?.compute;
            if (!compute)
                return;
            applyJIT(target, key, compute);
        }
        Objects.copyJIT = copyJIT;
    })(Objects || (Objects = {}));
    exports.default = Objects;
});
define("utility/BungieID", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BungieID;
    (function (BungieID) {
        function stringify(id) {
            return !id ? undefined : `${id.name}#${`${id.code}`.padStart(4, "0")}`;
        }
        BungieID.stringify = stringify;
        function parse(string, encoded = false) {
            let name = string.slice(0, -5);
            if (encoded)
                name = decodeURIComponent(name);
            const code = string.slice(-4);
            if (isNaN(parseInt(code)))
                return undefined;
            return { name, code: +code };
        }
        BungieID.parse = parse;
    })(BungieID || (BungieID = {}));
    exports.default = BungieID;
});
define("utility/Store", ["require", "exports", "utility/EventManager"], function (require, exports, EventManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let storage;
    class Store {
        static subscribeBackgroundChange(handler) {
            Store.event.subscribe("setSettingsBackground", handler);
            Store.event.subscribe("deleteSettingsBackground", handler);
            Store.event.subscribe("setSettingsBackgroundNoUseDefault", handler);
            Store.event.subscribe("deleteSettingsBackgroundNoUseDefault", handler);
        }
        static get items() {
            return storage ??= new Proxy({}, {
                has(_, key) {
                    return Store.has(key);
                },
                get(_, key) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return Store.get(key);
                },
                set(_, key, value) {
                    return Store.set(key, value);
                },
                deleteProperty(_, key) {
                    return Store.delete(key);
                },
            });
        }
        static has(key) {
            return localStorage.getItem(key) !== null;
        }
        static get(key) {
            const value = localStorage.getItem(key);
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return value === null ? null : JSON.parse(value);
            }
            catch {
                localStorage.removeItem(key);
                return null;
            }
        }
        static set(key, value) {
            const oldValue = Store.get(key);
            if (oldValue === (value ?? null))
                return true;
            if (value === undefined)
                localStorage.removeItem(key);
            else
                localStorage.setItem(key, JSON.stringify(value));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            Store.event.emit(`set${key[0].toUpperCase()}${key.slice(1)}`, { value, oldValue });
            return true;
        }
        static delete(key) {
            const oldValue = Store.get(key);
            if (oldValue === null)
                return true;
            localStorage.removeItem(key);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            Store.event.emit(`delete${key[0].toUpperCase()}${key.slice(1)}`, { oldValue });
            return true;
        }
    }
    Store.event = EventManager_1.EventManager.make();
    exports.default = Store;
    Object.assign(window, { Store });
});
define("utility/Database", ["require", "exports", "utility/Arrays", "utility/EventManager", "utility/Objects", "utility/Store"], function (require, exports, Arrays_1, EventManager_2, Objects_1, Store_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Version;
    (function (Version) {
        function encode(...[major, minor]) {
            return (Math.min(major, 2 ** 16) << 16) | Math.min(minor, 2 ** 16);
        }
        Version.encode = encode;
        function decode(encoded) {
            return [encoded >> 16, encoded & 0b1111_1111_1111_1111];
        }
        Version.decode = decode;
    })(Version || (Version = {}));
    class Database {
        async getDatabase() {
            if (this.database)
                return this.database;
            return this.open();
        }
        constructor(schema) {
            this.schema = schema;
            this.event = new EventManager_2.EventManager(this);
        }
        async get(store, key, index) {
            return this.transaction([store], "readonly", transaction => transaction.get(store, key, index));
        }
        async all(store, rangeOrKey, index) {
            return this.transaction([store], "readonly", transaction => transaction.all(store, rangeOrKey, index));
        }
        async set(store, key, value) {
            return this.transaction([store], transaction => transaction.set(store, key, value));
        }
        async delete(store, key) {
            return this.transaction([store], transaction => transaction.delete(store, key));
        }
        async keys(store) {
            return this.transaction([store], "readonly", transaction => transaction.keys(store));
        }
        async count(store) {
            return this.transaction([store], "readonly", transaction => transaction.count(store));
        }
        async clear(store) {
            return this.transaction([store], transaction => transaction.clear(store));
        }
        async transaction(over, modeOrTransaction, transaction) {
            if (typeof modeOrTransaction !== "string") {
                transaction = modeOrTransaction;
                modeOrTransaction = "readwrite";
            }
            const database = await this.getDatabase();
            const instance = new Database.Transaction(database.transaction(over, modeOrTransaction));
            const result = await transaction(instance);
            await instance.commit();
            return result;
        }
        stagedTransaction(over, mode = "readwrite") {
            return new Database.StagedTransaction(this, over, mode);
        }
        async upgrade(upgrade) {
            await this.close();
            const [, databaseVersionMinor] = (await this.getVersion()) ?? [];
            await this.open((databaseVersionMinor ?? 0) + 1, upgrade);
        }
        async stores() {
            const database = await this.getDatabase();
            return database.objectStoreNames;
        }
        async hasStore(...stores) {
            const database = await this.getDatabase();
            return stores.every(store => database.objectStoreNames.contains(store));
        }
        async createStore(store, options, init) {
            if (await this.hasStore(store))
                return;
            await this.upgrade(async (upgrade) => {
                await init?.(upgrade.createObjectStore(store, options));
            });
        }
        async dispose() {
            await this.close();
            return new Promise((resolve, reject) => {
                const request = indexedDB.deleteDatabase(this.schema.id);
                request.addEventListener("success", () => resolve());
                request.addEventListener("blocked", () => reject(new Error(`Cannot delete database '${this.schema.id}', blocked`)));
                request.addEventListener("error", () => reject(new Error(`Cannot delete database '${this.schema.id}', error: ${request.error?.message ?? "Unknown error"}`)));
            });
        }
        getVersion() {
            // const databaseInfo = (await indexedDB.databases()).find(({ name }) => name === this.schema.id);
            const databaseInfo = Store_1.default.items.databases?.find(({ name }) => name === this.schema.id);
            return databaseInfo?.version ? Version.decode(databaseInfo.version) : undefined;
        }
        async open(versionMinor, upgrade) {
            if (!this.schema.versions.length)
                throw new Error(`No versions in schema for database '${this.schema.id}'`);
            // eslint-disable-next-line @typescript-eslint/no-misused-promises,  no-async-promise-executor
            const databasePromise = new Promise(async (resolve, reject) => {
                const [, databaseVersionMinor] = (await this.getVersion()) ?? [];
                const newVersion = Version.encode(this.schema.versions.length, versionMinor ?? databaseVersionMinor ?? 0);
                const request = indexedDB.open(this.schema.id, newVersion);
                request.addEventListener("blocked", () => {
                    console.log("blocked");
                });
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                request.addEventListener("upgradeneeded", async (event) => {
                    const transaction = request.transaction;
                    if (!transaction)
                        return;
                    const database = request.result;
                    const [versionMajor] = Version.decode(event.newVersion ?? newVersion);
                    const [oldVersionMajor] = Version.decode(event.oldVersion);
                    for (let i = oldVersionMajor; i < versionMajor; i++)
                        await this.schema.versions[i](database, transaction);
                    await upgrade?.(database, transaction);
                    const databases = Store_1.default.items.databases ?? [];
                    const databaseInfo = databases.find(({ name }) => name === this.schema.id);
                    if (databaseInfo)
                        databaseInfo.version = newVersion;
                    else
                        databases.push({ name: this.schema.id, version: newVersion });
                    Store_1.default.items.databases = databases;
                });
                request.addEventListener("error", () => {
                    console.log("aaaaaaaaaaaaaaaaaaaa");
                    if (request.error?.message.includes("version")) {
                        console.info(`Database '${this.schema.id}' is from the future and must be disposed`);
                        delete this.database;
                        void this.dispose().then(() => {
                            resolve(this.open(versionMinor, upgrade));
                        });
                        return;
                    }
                    reject(new Error(`Cannot create database '${this.schema.id}', error: ${request.error?.message ?? "Unknown error"}`));
                });
                request.addEventListener("success", () => resolve(request.result));
            });
            this.database = databasePromise;
            const database = await databasePromise;
            database.addEventListener("close", () => {
                delete this.database;
                this.event.emit("close");
            });
            this.database = database;
            this.event.emit("open");
            return database;
        }
        async close() {
            if (!this.database)
                return;
            const database = this.database;
            delete this.database;
            (await database).close();
        }
    }
    (function (Database) {
        function schema(id, ...versions) {
            return {
                _schema: null,
                id,
                versions,
            };
        }
        Database.schema = schema;
        class Transaction {
            constructor(transaction) {
                this.transaction = transaction;
                this.event = new EventManager_2.EventManager(this);
                this.complete = false;
                this.errored = false;
                this.transaction.addEventListener("complete", () => {
                    this.complete = true;
                    this.event.emit("complete");
                });
                this.transaction.addEventListener("error", () => {
                    this.errored = true;
                    this.event.emit("error", { error: this.transaction.error });
                });
            }
            async get(name, key, index) {
                return this.do(() => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    let store = this.transaction.objectStore(name);
                    if (index !== undefined)
                        store = store.index(index);
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return store.get(key);
                });
            }
            async all(name, rangeOrKey, index) {
                if (Array.isArray(rangeOrKey)) {
                    return new Promise((resolve, reject) => {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                        let store = this.transaction.objectStore(name);
                        if (index !== undefined)
                            store = store.index(index);
                        const result = [];
                        const request = store.openCursor();
                        request.addEventListener("error", () => reject(request.error));
                        request.addEventListener("success", event => {
                            const cursor = request.result;
                            if (!cursor)
                                return resolve(result);
                            if (rangeOrKey.includes(cursor.key) || (!isNaN(+cursor.key) && rangeOrKey.includes(+cursor.key)))
                                result.push(cursor.value);
                            cursor.continue();
                        });
                    });
                }
                return this.do(() => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    let store = this.transaction.objectStore(name);
                    if (index !== undefined)
                        store = store.index(index);
                    if (typeof rangeOrKey === "string")
                        return store.getAll(rangeOrKey);
                    return store.getAll(rangeOrKey);
                });
            }
            async primaryKeys(name, rangeOrKey, index) {
                return this.do(() => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    let store = this.transaction.objectStore(name);
                    if (index !== undefined)
                        store = store.index(index);
                    return store.getAllKeys(rangeOrKey);
                });
            }
            async indexKeys(name, index, mapper) {
                return new Promise((resolve, reject) => {
                    const store = this.transaction.objectStore(name).index(index);
                    const regexDot = /\./g;
                    const keyPath = Arrays_1.default.resolve(store.keyPath)
                        .flatMap(key => key.split(regexDot));
                    const result = new Map();
                    const request = store.openCursor();
                    request.addEventListener("error", () => reject(request.error));
                    request.addEventListener("success", event => {
                        const cursor = request.result;
                        if (!cursor)
                            return resolve([...result.values()]);
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        const key = Objects_1.default.followPath(cursor.value, keyPath);
                        if ((typeof key === "string" || typeof key === "number") && !result.has(key))
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                            result.set(key, !mapper ? key : mapper(key, cursor.value));
                        cursor.continue();
                    });
                });
            }
            async set(name, key, value) {
                return this.do(() => this.transaction.objectStore(name)
                    .put(value, key))
                    .then(() => { });
            }
            async delete(name, key) {
                return this.do(() => this.transaction.objectStore(name)
                    .delete(key));
            }
            async keys(name) {
                return this.do(() => this.transaction.objectStore(name)
                    .getAllKeys());
            }
            async count(name) {
                return this.do(() => this.transaction.objectStore(name)
                    .count());
            }
            async clear(name) {
                return this.do(() => this.transaction.objectStore(name)
                    .clear());
            }
            async do(operation) {
                if (this.errored || this.complete)
                    throw new Error("Transaction is complete or has errored, no further operations are allowed");
                return new Promise((resolve, reject) => {
                    const request = operation();
                    request.addEventListener("error", () => reject(request.error));
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    request.addEventListener("success", () => resolve(request.result));
                });
            }
            async commit() {
                if (this.complete || this.errored)
                    return;
                this.complete = true;
                this.transaction.commit();
                return this.event.waitFor("complete");
            }
        }
        Database.Transaction = Transaction;
        class StagedTransaction {
            constructor(database, over, mode) {
                this.database = database;
                this.over = over;
                this.mode = mode;
                this.pending = [];
            }
            queue(staged) {
                const resultPromise = new Promise(resolve => {
                    if (typeof staged === "function")
                        this.pending.push(async (transaction) => resolve(await staged(transaction, ...[])));
                    else {
                        staged.resolve = resolve;
                        this.pending.push(staged);
                    }
                });
                void this.tryExhaustQueue();
                return resultPromise;
            }
            async tryExhaustQueue() {
                if (this.activeTransaction)
                    return this.activeTransaction;
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                this.activeTransaction = (async () => {
                    while (this.pending.length) {
                        const transactions = this.pending.splice(0, Infinity);
                        console.debug(`Found ${transactions.length} staged transactions over:`, ...this.over);
                        const start = performance.now();
                        await this.database.transaction(this.over, this.mode, async (transaction) => {
                            const transactionsByType = {};
                            for (const staged of transactions) {
                                if (typeof staged === "function") {
                                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                                    await staged(transaction);
                                    continue;
                                }
                                transactionsByType[staged.id] ??= [];
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                                transactionsByType[staged.id].push(staged);
                            }
                            for (const transactions of Object.values(transactionsByType)) {
                                const data = transactions.flatMap(staged => staged.data);
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                                const results = await transactions[0].function(transaction, ...data);
                                if (results.length !== data.length)
                                    throw new Error(`Invalid number of results for ${transactions[0].id} over ${this.over.join(", ")}`);
                                for (let i = 0; i < results.length; i++) {
                                    transactions[i].resolve(results[i]);
                                }
                            }
                        });
                        console.debug(`Completed ${transactions.length} staged transactions in ${performance.now() - start}ms over:`, ...this.over);
                    }
                })();
                await this.activeTransaction;
                delete this.activeTransaction;
            }
            await() {
                return this.tryExhaustQueue();
            }
            async transaction(initialiser) {
                return this.queue(transaction => initialiser(transaction));
            }
            async get(store, key, index) {
                return this.queue(transaction => transaction.get(store, key, index));
                // return this.queue({
                // 	id: `get:${String(store)}:${index ?? "/"}`,
                // 	data: [key],
                // 	function: async (transaction, ...data) =>
                // 		data.length === 1 ? [await transaction.get(store, key, index)]
                // 			: transaction.all(store, data, index),
                // });
            }
            async all(store, range, index) {
                return this.queue(transaction => transaction.all(store, range, index));
            }
            async primaryKeys(store, range, index) {
                return this.queue(transaction => transaction.primaryKeys(store, range, index));
            }
            async indexKeys(store, index, mapper) {
                return this.queue(transaction => transaction.indexKeys(store, index, mapper));
            }
            async set(store, key, value) {
                if (this.mode === "readonly")
                    throw new Error("Cannot modify store in readonly mode");
                return this.queue(transaction => transaction.set(store, key, value));
            }
            async delete(store, key) {
                if (this.mode === "readonly")
                    throw new Error("Cannot modify store in readonly mode");
                return this.queue(transaction => transaction.delete(store, key));
            }
            async keys(store) {
                return this.queue(transaction => transaction.keys(store));
            }
            async count(store) {
                return this.queue(transaction => transaction.count(store));
            }
            async clear(store) {
                if (this.mode === "readonly")
                    throw new Error("Cannot modify store in readonly mode");
                return this.queue(transaction => transaction.clear(store));
            }
        }
        Database.StagedTransaction = StagedTransaction;
    })(Database || (Database = {}));
    exports.default = Database;
});
define("model/ModelCacheDatabase", ["require", "exports", "utility/Database"], function (require, exports, Database_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Database_1.default.schema("modelCache", database => {
        database.createObjectStore("models");
    });
});
define("utility/Debug", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Debug = void 0;
    var Debug;
    (function (Debug) {
        // export let emulateBungieError = false;
        Debug.emulateBungieErrorSystemDisabled = false;
        Debug.collectionsDuplicates = false;
    })(Debug || (exports.Debug = Debug = {}));
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    window.Debug = Debug;
});
define("utility/endpoint/Endpoint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Endpoint {
        constructor(path, builder) {
            this.path = path;
            this.builder = builder;
        }
        async query(...args) {
            const path = this.resolvePath(...args);
            let headers;
            return this.fetch(path, ...args)
                .then(response => {
                headers = response.headers;
                return response.text();
            })
                .then(text => {
                if (path.endsWith(".json")) {
                    // text = text
                    // 	.replace(/\s*\/\/[^\n"]*(?=\n)/g, "")
                    // 	.replace(/(?<=\n)\s*\/\/[^\n]*(?=\n)/g, "")
                    // 	.replace(/,(?=[^}\]"\d\w_-]*?[}\]])/gs, "");
                    let parsed;
                    try {
                        parsed = JSON.parse(text);
                    }
                    catch (err) {
                        console.warn(text);
                        throw err;
                    }
                    const result = this.process(parsed);
                    Object.defineProperty(result, "_headers", {
                        enumerable: false,
                        get: () => headers,
                    });
                    return result;
                }
                throw new Error("Unknown file type");
            });
        }
        process(received) {
            return received;
        }
        async fetch(path, ...args) {
            path ??= this.resolvePath(...args);
            const request = {
                ...this.getDefaultRequest(...args),
                ...await this.builder?.(...args) ?? {},
            };
            let body;
            if (typeof request.body === "object") {
                if (request.headers?.["Content-Type"] === "application/x-www-form-urlencoded")
                    body = new URLSearchParams(Object.entries(request.body)).toString();
                else if (request.headers?.["Content-Type"] === undefined || request.headers?.["Content-Type"] === "application/json") {
                    request.headers ??= {};
                    request.headers["Content-Type"] = "application/json";
                    body = JSON.stringify(request.body);
                }
            }
            let search = "";
            if (request.search) {
                search = "?";
                if (typeof request.search === "object")
                    search += new URLSearchParams(Object.entries(request.search)).toString();
                else
                    search += request.search;
            }
            const params = [`${path}${search}`, {
                    ...request,
                    body,
                    headers: Object.fromEntries(Object.entries(await this.getHeaders(request?.headers, ...args)).filter(([key, value]) => typeof value === "string")),
                }];
            return fetch(...params);
        }
        resolvePath(...args) {
            return typeof this.path === "string" ? this.path : this.path(...args);
        }
        getDefaultRequest(...args) {
            return {};
        }
        // eslint-disable-next-line @typescript-eslint/require-await
        async getHeaders(headers, ...args) {
            return { ...headers };
        }
    }
    exports.default = Endpoint;
});
define("utility/Env", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Env {
        async load() {
            const origin = location.origin;
            const root = location.pathname.startsWith("/beta/") ? "/beta/" : "/";
            Object.assign(this, await fetch(origin + root + "env.json").then(response => response.json()));
            document.documentElement.classList.add(`environment-${this.DEEPSIGHT_ENVIRONMENT}`);
            Object.assign(window, { Env: this });
        }
        path(path) {
            if (path.startsWith("/"))
                path = path.slice(1);
            else if (path.startsWith("./"))
                path = path.slice(2);
            return this.DEEPSIGHT_PATH + path;
        }
    }
    exports.default = new Env;
});
define("utility/endpoint/bungie/endpoint/user/GetMembershipsForCurrentUser", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_1.default
        .at((profile) => "/User/GetMembershipsForCurrentUser/")
        .returning()
        .setProfile(profile => profile);
});
define("model/models/Memberships", ["require", "exports", "utility/endpoint/bungie/endpoint/user/GetMembershipsForCurrentUser"], function (require, exports, GetMembershipsForCurrentUser_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Memberships;
    (function (Memberships) {
        async function getCurrentDestinyMembership(profile) {
            if (!profile?.accessToken)
                return undefined;
            const memberships = await GetMembershipsForCurrentUser_1.default.query(profile);
            if (profile.membershipType !== undefined) {
                const membership = memberships.destinyMemberships.find(membership => membership.membershipType === profile.membershipType);
                if (membership)
                    return membership;
            }
            return getPrimaryDestinyMembership(memberships.destinyMemberships);
        }
        Memberships.getCurrentDestinyMembership = getCurrentDestinyMembership;
        function getPrimaryDestinyMembership(memberships) {
            const firstMembership = memberships[0];
            if (!firstMembership?.crossSaveOverride)
                return firstMembership;
            return memberships.find(membership => membership.membershipType === firstMembership.crossSaveOverride)
                ?? firstMembership;
        }
        Memberships.getPrimaryDestinyMembership = getPrimaryDestinyMembership;
    })(Memberships || (Memberships = {}));
    exports.default = Memberships;
});
define("utility/endpoint/bungie/endpoint/destiny2/GetProfile", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_2.default
        .at((membershipType, destinyMembershipId, components) => `/Destiny2/${membershipType}/Profile/${destinyMembershipId}/`)
        .request((membershipType, destinyMembershipId, components) => ({
        search: {
            components: components.join(","),
        },
    }))
        .returning();
});
define("utility/endpoint/bungie/endpoint/destiny2/SearchDestinyPlayerByBungieName", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_3.default
        .at("/Destiny2/SearchDestinyPlayerByBungieName/-1/")
        .request((displayName, displayNameCode) => ({
        method: "POST",
        body: {
            displayName,
            displayNameCode,
        },
    }))
        .returning()
        .setOptionalAuth();
});
define("utility/endpoint/bungie/endpoint/groupv2/GetUserClan", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_4.default
        .at((membershipType, destinyMembershipId, filter = 0 /* GroupsForMemberFilter.All */) => `/GroupV2/User/${membershipType}/${destinyMembershipId}/${filter}/${1 /* GroupType.Clan */}/`)
        .returning();
});
define("utility/ProfileManager", ["require", "exports", "model/models/Memberships", "utility/BungieID", "utility/Store", "utility/endpoint/bungie/endpoint/destiny2/GetProfile", "utility/endpoint/bungie/endpoint/destiny2/SearchDestinyPlayerByBungieName", "utility/endpoint/bungie/endpoint/groupv2/GetUserClan"], function (require, exports, Memberships_1, BungieID_1, Store_2, GetProfile_1, SearchDestinyPlayerByBungieName_1, GetUserClan_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProfileManager;
    (function (ProfileManager) {
        function isAuthenticated() {
            return !!get()?.data.accessToken;
        }
        ProfileManager.isAuthenticated = isAuthenticated;
        function byId(bungieId) {
            if (typeof bungieId === "object")
                bungieId = BungieID_1.default.stringify(bungieId);
            return (Store_2.default.items.profiles ?? {})[bungieId];
        }
        ProfileManager.byId = byId;
        function get() {
            const selectedProfileId = Store_2.default.items.selectedProfile;
            if (!selectedProfileId) {
                const profiles = Object.entries(Store_2.default.items.profiles ?? {});
                const authenticatedProfiles = profiles.filter(([, profile]) => profile.accessToken);
                if (!profiles.length || authenticatedProfiles.length > 1 || (!authenticatedProfiles.length && profiles.length > 1))
                    return undefined;
                const [idString, data] = authenticatedProfiles[0] ?? profiles[0];
                const id = BungieID_1.default.parse(idString);
                if (!id || !data)
                    return undefined;
                return { id, data };
            }
            const data = Store_2.default.items.profiles?.[selectedProfileId];
            if (!data)
                return undefined;
            const id = BungieID_1.default.parse(selectedProfileId);
            if (!id)
                return undefined;
            return { id, data };
        }
        ProfileManager.get = get;
        function update(bungieId, profile = {}) {
            if (typeof bungieId === "object")
                bungieId = BungieID_1.default.stringify(bungieId);
            const profiles = Store_2.default.items.profiles ?? {};
            profile = profiles[bungieId] = {
                ...profiles[bungieId],
                ...profile,
                lastModified: new Date().toISOString(),
            };
            Store_2.default.items.profiles = profiles;
            return profile;
        }
        ProfileManager.update = update;
        function remove(bungieId) {
            if (typeof bungieId === "object")
                bungieId = BungieID_1.default.stringify(bungieId);
            const profiles = Store_2.default.items.profiles ?? {};
            delete profiles[bungieId];
            Store_2.default.items.profiles = profiles;
        }
        ProfileManager.remove = remove;
        let reinitPromise;
        async function reinit(bungieId) {
            while (reinitPromise)
                await reinitPromise;
            const result = await (reinitPromise = reinitInternal(bungieId));
            reinitPromise = undefined;
            return result;
        }
        ProfileManager.reinit = reinit;
        async function reinitInternal(bungieId) {
            if (typeof bungieId === "object")
                bungieId = BungieID_1.default.stringify(bungieId);
            const profiles = Store_2.default.items.profiles ?? {};
            let storeProfile = profiles[bungieId] = {
                ...profiles[bungieId],
                lastModified: new Date().toISOString(),
            };
            let membership;
            if (storeProfile.accessToken)
                membership = await Memberships_1.default.getCurrentDestinyMembership(storeProfile);
            else {
                const id = BungieID_1.default.parse(bungieId);
                membership = id && await SearchDestinyPlayerByBungieName_1.default.query(id.name, id.code)
                    .then(memberships => Memberships_1.default.getPrimaryDestinyMembership(memberships))
                    .catch(err => {
                    console.warn(err);
                    return undefined;
                });
            }
            if (!membership) {
                delete profiles[bungieId];
                Store_2.default.items.profiles = profiles;
                return undefined;
            }
            const oldIdString = bungieId;
            bungieId = { name: membership.bungieGlobalDisplayName, code: membership.bungieGlobalDisplayNameCode ?? 0 };
            const idString = BungieID_1.default.stringify(bungieId);
            if (idString !== oldIdString)
                delete profiles[oldIdString];
            storeProfile = profiles[idString] = {
                ...storeProfile,
                membershipType: membership.membershipType,
                membershipId: membership.membershipId,
            };
            const profile = await GetProfile_1.default
                .setOptionalAuth(true)
                .query(membership.membershipType, membership.membershipId, [100 /* DestinyComponentType.Profiles */, 200 /* DestinyComponentType.Characters */]);
            const currentCharacter = Object.values(profile.characters.data ?? {})
                ?.sort(({ dateLastPlayed: dateLastPlayedA }, { dateLastPlayed: dateLastPlayedB }) => new Date(dateLastPlayedB).getTime() - new Date(dateLastPlayedA).getTime())?.[0];
            const clan = await GetUserClan_1.default.query(membership.membershipType, membership.membershipId);
            storeProfile.emblemHash = currentCharacter?.emblemHash;
            storeProfile.class = currentCharacter?.classType;
            storeProfile.callsign = clan?.results?.[0]?.group?.clanInfo?.clanCallsign ?? "";
            storeProfile.callsignLastModified = new Date().toISOString();
            Store_2.default.items.profiles = profiles;
            return storeProfile;
        }
    })(ProfileManager || (ProfileManager = {}));
    Object.assign(window, { ProfileManager });
    exports.default = ProfileManager;
});
define("utility/endpoint/bungie/BungieEndpoint", ["require", "exports", "utility/Debug", "utility/endpoint/Endpoint", "utility/Env", "utility/EventManager"], function (require, exports, Debug_1, Endpoint_1, Env_1, EventManager_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BungieEndpointImpl extends Endpoint_1.default {
        constructor(path, builder) {
            super(path, builder);
            this.allowedErrorStatuses = [];
            this.subdomain = "www";
        }
        allowErrorStatus(status) {
            this.allowedErrorStatuses.push(status);
            return this;
        }
        setSubdomain(subdomain) {
            this.subdomain = subdomain;
            return this;
        }
        setOptionalAuth(optionalAuth = true) {
            if (optionalAuth)
                this.optionalAuth = optionalAuth;
            else
                delete this.optionalAuth;
            return this;
        }
        setSkipAuthHeaders(skipAuthHeaders = true) {
            if (skipAuthHeaders)
                this.skipAuthHeaders = skipAuthHeaders;
            else
                delete this.skipAuthHeaders;
            return this;
        }
        setProfile(supplier) {
            this.profileSupplier = supplier;
            return this;
        }
        async query(...args) {
            const attempts = 3;
            const lastAttempt = attempts - 1;
            for (let attempt = 0; attempt < 3; attempt++) {
                let error401d;
                let headers;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const result = await this.fetch(undefined, ...args)
                    .then(response => {
                    headers = response.headers;
                    if (response.status === 401) {
                        error401d = new Error("Not authenticated");
                        return;
                    }
                    return response.text();
                })
                    .then(text => {
                    if (!text)
                        return;
                    try {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        let data = JSON.parse(text);
                        if (data?.ErrorStatus === "WebAuthRequired") {
                            error401d = Object.assign(new Error(data.Message ?? "Not authenticated"), data);
                            return;
                        }
                        if (Debug_1.Debug.emulateBungieErrorSystemDisabled) {
                            data = {
                                ErrorCode: 5,
                                ThrottleSeconds: 0,
                                ErrorStatus: "SystemDisabled",
                                Message: "This system is temporarily disabled for maintenance.",
                                MessageData: {},
                                headers,
                            };
                        }
                        if (data?.ErrorStatus && data.ErrorStatus !== "Success" && !this.allowedErrorStatuses.includes(data.ErrorStatus)) {
                            if (data.ErrorStatus === "SystemDisabled")
                                BungieEndpoint.event.emit("apiDown");
                            throw Object.assign(new Error(data.Message ?? data.ErrorStatus), data);
                        }
                        BungieEndpoint.event.emit("querySuccess");
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                        return ("Response" in data && data.Response ? data.Response : data);
                    }
                    catch (error) {
                        BungieEndpoint.event.emit("error", { error: error, responseText: text, headers });
                        throw error;
                    }
                });
                if (error401d) {
                    if (attempt >= lastAttempt) {
                        BungieEndpoint.event.emit("authenticationFailed");
                        throw error401d;
                    }
                    else {
                        await this.validateAuthorisation(true);
                        continue;
                    }
                }
                Object.defineProperty(result, "_headers", {
                    enumerable: false,
                    get: () => headers,
                });
                return result;
            }
            throw new Error("This should never happen");
        }
        resolvePath(...args) {
            return `https://${this.subdomain}.bungie.net/Platform${super.resolvePath(...args)}`;
        }
        getDefaultRequest() {
            return {
                credentials: "include",
            };
        }
        async getHeaders(headers, ...args) {
            return {
                ...this.skipAuthHeaders ? undefined : {
                    "Authorization": headers?.Authorization ? undefined : await this.getAuthorisation(...args),
                },
                "X-API-Key": Env_1.default.DEEPSIGHT_BUNGIE_API_KEY,
                ...headers,
            };
        }
        async getAuthorisation(...args) {
            if (!this.optionalAuth)
                await this.validateAuthorisation();
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            const profile = this.profileSupplier?.(...args) ?? window.ProfileManager.get()?.data;
            if (!profile)
                return undefined;
            return profile.accessToken ? `Bearer ${profile.accessToken}` : undefined;
        }
        async validateAuthorisation(force) {
            let authorisationPromise;
            BungieEndpoint.event.emit("validateAuthorisation", { setAuthorisationPromise: promise => void (authorisationPromise = promise), force });
            await authorisationPromise;
        }
    }
    var BungieEndpoint;
    (function (BungieEndpoint) {
        BungieEndpoint.event = EventManager_3.EventManager.make();
        function at(url) {
            return {
                request(builder) {
                    return {
                        endpoint() {
                            return new BungieEndpointImpl(url, builder);
                        },
                        returning() {
                            return new BungieEndpointImpl(url, builder);
                        },
                    };
                },
                returning() {
                    return new BungieEndpointImpl(url);
                },
            };
        }
        BungieEndpoint.at = at;
    })(BungieEndpoint || (BungieEndpoint = {}));
    exports.default = BungieEndpoint;
});
define("utility/endpoint/bungie/endpoint/RequestOAuthToken", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/Env"], function (require, exports, BungieEndpoint_5, Env_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_5.default
        .at("/app/oauth/token/")
        .request((profile) => ({
        method: "POST",
        headers: {
            Authorization: `Basic ${btoa(`${Env_2.default.DEEPSIGHT_BUNGIE_CLIENT_ID}:${Env_2.default.DEEPSIGHT_BUNGIE_API_SECRET}`)}`,
            "Content-Type": "application/x-www-form-urlencoded",
        },
        body: profile.accessTokenRefreshToken
            ? {
                grant_type: "refresh_token",
                refresh_token: profile.accessTokenRefreshToken,
            }
            : {
                grant_type: "authorization_code",
                code: profile.authCode,
            },
    }))
        .returning();
});
define("utility/Strings", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Strings;
    (function (Strings) {
        function includesAt(string, substring, index) {
            if (index < 0)
                index = string.length + index;
            if (index + substring.length > string.length)
                return false;
            for (let i = 0; i < substring.length; i++)
                if (string[i + index] !== substring[i])
                    return false;
            return true;
        }
        Strings.includesAt = includesAt;
        function sliceTo(string, substring, startAt) {
            const index = string.indexOf(substring, startAt);
            if (index === -1)
                return string;
            return string.slice(0, index);
        }
        Strings.sliceTo = sliceTo;
        function sliceAfter(string, substring, startAt) {
            const index = string.indexOf(substring, startAt);
            if (index === -1)
                return string;
            return string.slice(index + substring.length);
        }
        Strings.sliceAfter = sliceAfter;
        function trimTextMatchingFromStart(string, substring, startAt) {
            if (string.length < substring.length)
                return string;
            const index = string.indexOf(substring, startAt);
            if (index !== 0)
                return string;
            return string.slice(index + substring.length);
        }
        Strings.trimTextMatchingFromStart = trimTextMatchingFromStart;
        function trimTextMatchingFromEnd(string, substring, startAt) {
            if (string.length < substring.length)
                return string;
            const index = string.lastIndexOf(substring, startAt);
            if (index !== string.length - substring.length)
                return string;
            return string.slice(0, index);
        }
        Strings.trimTextMatchingFromEnd = trimTextMatchingFromEnd;
        function extractFromQuotes(string) {
            let substring = (string ?? "").trim();
            if (substring[0] === '"')
                substring = substring.slice(1);
            if (substring[substring.length - 1] === '"')
                substring = substring.slice(0, -1);
            return substring.trim();
        }
        Strings.extractFromQuotes = extractFromQuotes;
        function extractFromSquareBrackets(string) {
            let substring = (string ?? "");
            if (substring[0] === "[")
                substring = substring.slice(1).trimStart();
            if (substring[substring.length - 1] === "]")
                substring = substring.slice(0, -1).trimEnd();
            return substring;
        }
        Strings.extractFromSquareBrackets = extractFromSquareBrackets;
        function mergeRegularExpressions(flags, ...expressions) {
            let exprString = "";
            for (const expr of expressions)
                exprString += "|" + expr.source;
            return new RegExp(exprString.slice(1), flags);
        }
        Strings.mergeRegularExpressions = mergeRegularExpressions;
        function count(string, substring, stopAtCount = Infinity) {
            let count = 0;
            let lastIndex = -1;
            while (count < stopAtCount) {
                const index = string.indexOf(substring, lastIndex + 1);
                if (index === -1)
                    return count;
                count++;
                lastIndex = index;
            }
            return count;
        }
        Strings.count = count;
        function includesOnce(string, substring) {
            return count(string, substring, 2) === 1;
        }
        Strings.includesOnce = includesOnce;
        function getVariations(name) {
            const variations = [name];
            variations.push(name + "d", name + "ed");
            if (name.endsWith("d"))
                variations.push(...getVariations(name.slice(0, -1)));
            if (name.endsWith("ed"))
                variations.push(...getVariations(name.slice(0, -2)));
            if (name.endsWith("ing")) {
                variations.push(name.slice(0, -3));
                if (name[name.length - 4] === name[name.length - 5])
                    variations.push(name.slice(0, -4));
            }
            else {
                variations.push(name + "ing", name + name[name.length - 1] + "ing");
                if (name.endsWith("y"))
                    variations.push(name.slice(0, -1) + "ing");
            }
            if (name.endsWith("ion")) {
                variations.push(...getVariations(name.slice(0, -3)));
                if (name[name.length - 4] === name[name.length - 5])
                    variations.push(name.slice(0, -4));
            }
            else
                variations.push(name + "ion");
            if (name.endsWith("er"))
                variations.push(name.slice(0, -1), name.slice(0, -2));
            else {
                variations.push(name + "r", name + "er");
                if (name.endsWith("y"))
                    variations.push(name.slice(0, -1) + "ier");
            }
            if (name.endsWith("ier"))
                variations.push(name.slice(0, -3) + "y");
            variations.push(name + "s", name + "es");
            if (name.endsWith("s"))
                variations.push(name.slice(0, -1));
            else {
                if (name.endsWith("y"))
                    variations.push(name.slice(0, -1) + "ies");
            }
            return variations;
        }
        Strings.getVariations = getVariations;
        const REGEX_APOSTROPHE = /'/g;
        const REGEX_NON_WORD_MULTI = /\W+/g;
        function getWords(text) {
            return text.toLowerCase()
                .replace(REGEX_APOSTROPHE, "")
                .split(REGEX_NON_WORD_MULTI)
                .filter(Boolean);
        }
        Strings.getWords = getWords;
        function fuzzyMatches(a, b, options) {
            options ??= {};
            options.missingWordsThreshold ??= 0.4;
            options.maxMissingWordsForFuzzy = 4;
            const wordsA = getWords(a).map(getVariations);
            const wordsB = getWords(b).map(getVariations);
            let matches = 0;
            let misses = 0;
            let ia = 0;
            let ib = 0;
            NextMain: while (true) {
                const va = wordsA[ia];
                const vb = wordsB[ib];
                if (!va && !vb)
                    break;
                if (!va || !vb) {
                    ia++;
                    ib++;
                    misses++;
                    continue;
                }
                let loopMisses = 0;
                for (let ia2 = ia; ia2 < wordsA.length && loopMisses <= options.maxMissingWordsForFuzzy; ia2++) {
                    const va = wordsA[ia2];
                    if (va.some(va => vb.includes(va))) {
                        ia = ia2 + 1;
                        ib++;
                        matches++;
                        misses += loopMisses;
                        continue NextMain;
                    }
                    loopMisses++;
                }
                loopMisses = 0;
                for (let ib2 = ib; ib2 < wordsB.length && loopMisses <= options.maxMissingWordsForFuzzy; ib2++) {
                    const vb = wordsB[ib2];
                    if (vb.some(vb => va.includes(vb))) {
                        ia++;
                        ib = ib2 + 1;
                        matches++;
                        misses += loopMisses;
                        continue NextMain;
                    }
                    loopMisses++;
                }
                misses++;
                ia++;
                ib++;
            }
            return matches / (matches + misses) >= options.missingWordsThreshold;
        }
        Strings.fuzzyMatches = fuzzyMatches;
        const REGEX_NON_WORD_MULTI_PREV = /(?<=\W+)/g;
        function toTitleCase(text) {
            return text.split(REGEX_NON_WORD_MULTI_PREV)
                .map(word => word[0].toUpperCase() + word.slice(1))
                .join("");
        }
        Strings.toTitleCase = toTitleCase;
    })(Strings || (Strings = {}));
    exports.default = Strings;
});
define("utility/Time", ["require", "exports", "utility/Strings"], function (require, exports, Strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Time;
    (function (Time) {
        function floor(interval) {
            return Math.floor(Date.now() / interval) * interval;
        }
        Time.floor = floor;
        function ms(ms) { return ms; }
        Time.ms = ms;
        function seconds(seconds) { return seconds * 1000; }
        Time.seconds = seconds;
        function minutes(minutes) { return minutes * 1000 * 60; }
        Time.minutes = minutes;
        function hours(hours) { return hours * 1000 * 60 * 60; }
        Time.hours = hours;
        function days(days) { return days * 1000 * 60 * 60 * 24; }
        Time.days = days;
        function weeks(weeks) { return weeks * 1000 * 60 * 60 * 24 * 7; }
        Time.weeks = weeks;
        function months(months) { return Math.floor(months * 1000 * 60 * 60 * 24 * (365.2422 / 12)); }
        Time.months = months;
        function years(years) { return Math.floor(years * 1000 * 60 * 60 * 24 * 365.2422); }
        Time.years = years;
        function decades(decades) { return Math.floor(decades * 1000 * 60 * 60 * 24 * 365.2422 * 10); }
        Time.decades = decades;
        function centuries(centuries) { return Math.floor(centuries * 1000 * 60 * 60 * 24 * 365.2422 * 10 * 10); }
        Time.centuries = centuries;
        function millenia(millenia) { return Math.floor(millenia * 1000 * 60 * 60 * 24 * 365.2422 * 10 * 10 * 10); }
        Time.millenia = millenia;
        function relative(ms, options = { style: "short" }) {
            ms -= Date.now();
            const locale = navigator.language || "en-NZ";
            if (!locale.startsWith("en"))
                return relativeIntl(ms, locale, options);
            if (Math.abs(ms) < seconds(1))
                return "now";
            const ago = ms < 0;
            if (ago)
                ms = Math.abs(ms);
            let limit = options.components ?? Infinity;
            let value = ms;
            let result = ms > 0 && options.label !== false ? "in " : "";
            value = Math.floor(ms / years(1));
            ms -= value * years(1);
            if (value && limit-- > 0)
                result += `${value} year${value === 1 ? "" : "s"}${limit > 0 ? ", " : ""}`;
            value = Math.floor(ms / months(1));
            ms -= value * months(1);
            if (value && limit-- > 0)
                result += `${value} month${value === 1 ? "" : "s"}${limit > 0 ? ", " : ""}`;
            value = Math.floor(ms / weeks(1));
            ms -= value * weeks(1);
            if (value && limit-- > 0)
                result += `${value} week${value === 1 ? "" : "s"}${limit > 0 ? ", " : ""}`;
            value = Math.floor(ms / days(1));
            ms -= value * days(1);
            if (value && limit-- > 0)
                result += `${value} day${value === 1 ? "" : "s"}${limit > 0 ? ", " : ""}`;
            value = Math.floor(ms / hours(1));
            ms -= value * hours(1);
            if (value && limit-- > 0)
                result += `${value} hour${value === 1 ? "" : "s"}${limit > 0 ? ", " : ""}`;
            value = Math.floor(ms / minutes(1));
            ms -= value * minutes(1);
            if (value && limit-- > 0)
                result += `${value} minute${value === 1 ? "" : "s"}${limit > 0 ? ", " : ""}`;
            value = Math.floor(ms / seconds(1));
            if (value && limit-- > 0)
                result += `${value} second${value === 1 ? "" : "s"}`;
            result = Strings_1.default.trimTextMatchingFromEnd(result, ", ");
            return `${result}${ago && options.label !== false ? " ago" : ""}`;
        }
        Time.relative = relative;
        function relativeIntl(ms, locale, options) {
            const rtf = new Intl.RelativeTimeFormat(locale, options);
            let value = ms;
            value = Math.floor(ms / years(1));
            if (value)
                return rtf.format(value, "year");
            value = Math.floor(ms / months(1));
            if (value)
                return rtf.format(value, "month");
            value = Math.floor(ms / weeks(1));
            if (value)
                return rtf.format(value, "week");
            value = Math.floor(ms / days(1));
            if (value)
                return rtf.format(value, "day");
            value = Math.floor(ms / hours(1));
            if (value)
                return rtf.format(value, "hour");
            value = Math.floor(ms / minutes(1));
            if (value)
                return rtf.format(value, "minute");
            value = Math.floor(ms / seconds(1));
            return rtf.format(value, "second");
        }
        function absolute(ms, options = { dateStyle: "full", timeStyle: "medium" }) {
            const locale = navigator.language || "en-NZ";
            const rtf = new Intl.DateTimeFormat(locale, options);
            return rtf.format(ms);
        }
        Time.absolute = absolute;
    })(Time || (Time = {}));
    Object.assign(window, { Time });
    exports.default = Time;
});
define("utility/URL", ["require", "exports", "utility/BungieID", "utility/EventManager", "utility/Store"], function (require, exports, BungieID_2, EventManager_4, Store_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let params;
    let query;
    function updateURL() {
        let queryString = query.toString();
        if (queryString)
            queryString = `?${queryString}`;
        history.replaceState(null, "", `${location.origin}${location.pathname}${queryString}${location.hash}`);
    }
    let poppingState = false;
    EventManager_4.EventManager.global.subscribe("popstate", () => {
        poppingState = true;
        URL.event.emit("navigate");
        poppingState = false;
    });
    class URL {
        static get hash() {
            return location.hash.slice(1);
        }
        static set hash(value) {
            if (!poppingState)
                history.pushState(null, "", `${location.origin}${location.pathname}${location.search}${value ? `#${value}` : ""}`);
        }
        static get path() {
            let path = location.pathname.slice(1);
            if (!path.endsWith("/"))
                path += "/";
            if (path.startsWith("beta/"))
                path = path.slice(5);
            const bungieId = URL.extractBungieId(path);
            if (bungieId)
                path = path.slice(`${encodeURIComponent(bungieId.name)}.${`${bungieId.code}`.padStart(4, "0")}`.length + 1);
            return !path || path === "/" ? null : path;
        }
        static set path(value) {
            if (value && !value?.startsWith("/"))
                value = `/${value}`;
            const membershipOverride = viewManager.view?.noProfileInURL ? undefined : Store_3.default.items.selectedProfile;
            const membershipOverrideSegment = !membershipOverride ? "" : encodeURIComponent(membershipOverride.replace("#", "."));
            if (value && membershipOverrideSegment)
                value = `/${membershipOverrideSegment}${value}`;
            if (value && location.pathname.startsWith("/beta/"))
                value = `/beta${value}`;
            if (value?.endsWith("/"))
                value = value.slice(0, -1);
            value ||= "/";
            if (location.pathname === value)
                return;
            if (!poppingState)
                history.pushState(null, "", `${location.origin}${value}${location.search}`);
        }
        static extractBungieId(path) {
            const nextSlashIndex = path.indexOfOrUndefined("/");
            if (nextSlashIndex === undefined)
                return undefined;
            const segment = path.slice(0, nextSlashIndex);
            if (segment[segment.length - 5] !== ".")
                return undefined;
            return BungieID_2.default.parse(segment, true);
        }
        static get bungieID() {
            let path = location.pathname.slice(1);
            if (!path.endsWith("/"))
                path += "/";
            if (path.startsWith("beta/"))
                path = path.slice(5);
            const bungieId = URL.extractBungieId(path);
            if (!bungieId)
                return undefined;
            const name = bungieId.name;
            const code = +bungieId.code;
            const membershipOverride = Store_3.default.items.selectedProfile;
            if (membershipOverride && membershipOverride !== BungieID_2.default.stringify(bungieId))
                delete Store_3.default.items.selectedProfile;
            return { name, code };
        }
        static get params() {
            return params ??= new Proxy(query ??= new URLSearchParams(location.search), {
                has(params, key) {
                    return params.has(key);
                },
                get(params, key) {
                    return params.get(key);
                },
                set(params, key, value) {
                    params.set(key, value);
                    updateURL();
                    return true;
                },
                deleteProperty(params, key) {
                    params.delete(key);
                    updateURL();
                    return true;
                },
            });
        }
    }
    URL.event = EventManager_4.EventManager.make();
    exports.default = URL;
});
define("utility/endpoint/bungie/Bungie", ["require", "exports", "utility/BungieID", "utility/endpoint/bungie/BungieEndpoint", "utility/endpoint/bungie/endpoint/RequestOAuthToken", "utility/Env", "utility/EventManager", "utility/ProfileManager", "utility/Store", "utility/Time", "utility/URL"], function (require, exports, BungieID_3, BungieEndpoint_6, RequestOAuthToken_1, Env_3, EventManager_5, ProfileManager_1, Store_4, Time_1, URL_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BungieAPI = void 0;
    class BungieAPI {
        get lastDailyReset() {
            return this.nextDailyReset - Time_1.default.days(1);
        }
        get lastWeeklyReset() {
            return this.nextWeeklyReset - Time_1.default.weeks(1);
        }
        get lastTrialsReset() {
            return this.nextWeeklyReset - Time_1.default.days(4);
        }
        get nextDailyReset() {
            const time = new Date().setUTCHours(17, 0, 0, 0);
            return time < Date.now() ? time + Time_1.default.days(1) : time;
        }
        get nextWeeklyReset() {
            const now = Date.now();
            const week = now + (Time_1.default.weeks(1) - (now % Time_1.default.weeks(1))) - Time_1.default.days(1) - Time_1.default.hours(7);
            return week < Date.now() ? week + Time_1.default.weeks(1) : week;
        }
        constructor() {
            this.event = new EventManager_5.EventManager(this)
                .pipe("error", BungieEndpoint_6.default.event)
                .pipe("apiDown", BungieEndpoint_6.default.event)
                .pipe("querySuccess", BungieEndpoint_6.default.event);
            this.apiDown = false;
            BungieEndpoint_6.default.event.subscribe("authenticationFailed", () => this.resetAuthentication());
            BungieEndpoint_6.default.event.subscribe("validateAuthorisation", ({ setAuthorisationPromise, force }) => setAuthorisationPromise(this.validateAuthorisation(force)));
            BungieEndpoint_6.default.event.subscribe("apiDown", () => this.apiDown = true);
            BungieEndpoint_6.default.event.subscribe("querySuccess", () => this.apiDown = false);
            Object.assign(window, { Bungie: this });
        }
        get authenticated() {
            const profile = ProfileManager_1.default.get()?.data;
            return !!(profile?.authCode && profile.accessToken);
        }
        async authenticate(type) {
            let profile = Store_4.default.items.profiles?.[""];
            if (!profile)
                type = "start";
            if (type === "start") {
                const profiles = Store_4.default.items.profiles ?? {};
                profile = profiles[""] = { lastModified: new Date().toISOString() };
                Store_4.default.items.profiles = profiles;
            }
            if (!profile.authCode && !URL_1.default.params.code) {
                if (type !== "start") {
                    // the user didn't approve of starting auth yet
                    return false;
                }
                // step 1: get an auth code for this user
                const clientId = Env_3.default.DEEPSIGHT_BUNGIE_CLIENT_ID;
                if (!clientId)
                    throw new Error("Cannot authenticate with Bungie, no client ID in environment");
                location.href = `https://www.bungie.net/en/oauth/authorize?client_id=${clientId}&response_type=code`; // &state=${state}`;
                return false;
            }
            if (!profile.authCode) {
                // step 2: receive auth code from bungie oauth
                // received auth code
                const profiles = Store_4.default.items.profiles ?? {};
                profile = profiles[""] = {
                    ...profiles[""],
                    authCode: URL_1.default.params.code,
                    lastModified: new Date().toISOString(),
                };
                Store_4.default.items.profiles = profiles;
            }
            delete URL_1.default.params.code;
            // delete URL.params.state;
            if (!profile.accessToken) {
                // step 3: get an access token
                return await this.requestToken("new");
            }
            return false;
        }
        resetAuthentication() {
            delete URL_1.default.params.code;
            delete URL_1.default.params.state;
            const profiles = Store_4.default.items.profiles ?? {};
            const profile = profiles[""];
            if (profile) {
                delete profile.authCode;
                delete profile.accessToken;
                delete profile.accessTokenExpireTime;
                delete profile.accessTokenMembershipId;
                delete profile.accessTokenRefreshExpireTime;
                delete profile.accessTokenRefreshToken;
                profile.lastModified = new Date().toISOString();
                Store_4.default.items.profiles = profiles;
            }
            this.event.emit("resetAuthentication");
        }
        async validateAuthorisation(force = false) {
            if (!force && (ProfileManager_1.default.get()?.data?.accessTokenExpireTime ?? 0) > Date.now())
                return; // authorisation valid
            await this.requestToken("refresh");
        }
        async requestToken(type) {
            const idString = type === "refresh" ? BungieID_3.default.stringify(ProfileManager_1.default.get()?.id) ?? "" : "";
            let storeProfile = ProfileManager_1.default.byId(idString);
            if (!storeProfile)
                // no profile to request token for
                return false;
            if (type === "refresh" && !storeProfile.accessTokenRefreshToken)
                return false;
            if (type === "new" && !storeProfile.authCode)
                return false;
            const result = await RequestOAuthToken_1.default.query(storeProfile);
            if ("error" in result) {
                if (result.error === "invalid_grant") {
                    this.resetAuthentication();
                    throw Object.assign(new Error(result.error_description ?? "Invalid grant"), result);
                }
                return false;
            }
            storeProfile = ProfileManager_1.default.update(idString, {
                accessToken: result.access_token,
                accessTokenExpireTime: Date.now() + result.expires_in * 1000,
                accessTokenMembershipId: result.membership_id,
                accessTokenRefreshExpireTime: Date.now() + result.refresh_expires_in * 1000,
                accessTokenRefreshToken: result.refresh_token,
                lastModified: new Date().toISOString(),
            });
            if (type === "refresh") {
                this.event.emit("authenticated", { authType: type });
                return true;
            }
            const profile = await ProfileManager_1.default.reinit(idString);
            Store_4.default.items.selectedProfile = profile ? idString : undefined;
            if (!Store_4.default.items.selectedProfile)
                return false;
            location.reload();
            this.event.emit("authenticated", { authType: type });
            return true;
        }
    }
    exports.BungieAPI = BungieAPI;
    exports.default = new BungieAPI;
});
define("utility/maths/Maths", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Maths;
    (function (Maths) {
        /**
         * Note: This implementation matches DIM's to ensure consistency between apps.
         * See: https://github.com/DestinyItemManager/DIM/blob/83ec236416fae879c09f4aa93be7d3be4843510d/src/app/inventory/store/stats.ts#L582-L585
         * Also see: https://github.com/Bungie-net/api/issues/1029#issuecomment-531849137
         */
        function bankersRound(x) {
            const r = Math.round(x);
            return (x > 0 ? x : -x) % 1 === 0.5 ? (0 === r % 2 ? r : r - 1) : r;
        }
        Maths.bankersRound = bankersRound;
        function sum(...nums) {
            let result = 0;
            for (const num of nums)
                result += num;
            return result;
        }
        Maths.sum = sum;
        function average(...nums) {
            let result = 0;
            for (const num of nums)
                result += num;
            return result / nums.length;
        }
        Maths.average = average;
        function bits(number) {
            const result = new BitsSet();
            for (let i = 52; i >= 0; i--) {
                const v = 1 << i;
                if (number & v)
                    result.add(v);
            }
            return result;
        }
        Maths.bits = bits;
        class BitsSet extends Set {
            everyIn(type) {
                const t = type ?? 0;
                for (const bit of this)
                    if (!(t & bit))
                        return false;
                return true;
            }
            someIn(type) {
                const t = type ?? 0;
                for (const bit of this)
                    if (t & bit)
                        return true;
                return false;
            }
            every(predicate) {
                for (const bit of this)
                    if (!predicate(bit))
                        return false;
                return true;
            }
            some(predicate) {
                for (const bit of this)
                    if (predicate(bit))
                        return true;
                return false;
            }
        }
        Maths.BitsSet = BitsSet;
        function bitsn(flag) {
            const result = new BitsSetN();
            for (let i = 52n; i >= 0n; i--) {
                const v = 1n << i;
                if (flag & v)
                    result.add(v);
            }
            return result;
        }
        Maths.bitsn = bitsn;
        class BitsSetN extends Set {
            everyIn(type) {
                const t = type ?? 0n;
                for (const bit of this)
                    if (!(t & bit))
                        return false;
                return true;
            }
            someIn(type) {
                const t = type ?? 0n;
                for (const bit of this)
                    if (t & bit)
                        return true;
                return false;
            }
            every(predicate) {
                for (const bit of this)
                    if (!predicate(bit))
                        return false;
                return true;
            }
            some(predicate) {
                for (const bit of this)
                    if (predicate(bit))
                        return true;
                return false;
            }
        }
        Maths.BitsSetN = BitsSetN;
        function lerp(from, to, t) {
            return (1 - t) * from + t * to;
        }
        Maths.lerp = lerp;
        function unlerp(from, to, value) {
            return (value - from) / (to - from);
        }
        Maths.unlerp = unlerp;
    })(Maths || (Maths = {}));
    exports.default = Maths;
});
define("model/Model", ["require", "exports", "model/ModelCacheDatabase", "utility/Arrays", "utility/Database", "utility/endpoint/bungie/Bungie", "utility/EventManager", "utility/maths/Maths", "utility/Store", "utility/URL"], function (require, exports, ModelCacheDatabase_1, Arrays_2, Database_2, Bungie_1, EventManager_6, Maths_1, Store_5, URL_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Model;
    (function (Model) {
        Model.cacheDB = new Database_2.default(ModelCacheDatabase_1.default);
        Model.event = EventManager_6.EventManager.make();
        let loadId = Date.now();
        async function clearCache(force = false) {
            console.warn("Clearing cache...");
            loadId = Date.now();
            if (force) {
                await Model.cacheDB.dispose();
                console.warn("Cache cleared.");
                Model.event.emit("clearCache");
                return;
            }
            for (const store of (await Model.cacheDB.stores())) {
                if (store === "models") {
                    for (const key of await Model.cacheDB.keys("models")) {
                        const cached = await Model.cacheDB.get("models", key);
                        if (cached?.persist && !force)
                            continue;
                        await Model.cacheDB.delete("models", key);
                    }
                }
                else if (force) {
                    await Model.cacheDB.clear(store);
                }
            }
            console.warn("Cache cleared.");
            Model.event.emit("clearCache");
        }
        Model.clearCache = clearCache;
        /**
         * Custom model implementation
         */
        function create(name, model) {
            return new Impl(name, model);
        }
        Model.create = create;
        /**
         * Data not cached, with optional name
         */
        function createTemporary(generate, name = "") {
            return new Impl(name, {
                cache: false,
                generate,
            });
        }
        Model.createTemporary = createTemporary;
        /**
         * Data cached only in memory, with optional reset time & name
         */
        function createDynamic(resetTime, generate, name = "") {
            return new Impl(name, {
                cache: "Memory",
                resetTime,
                generate,
            });
        }
        Model.createDynamic = createDynamic;
        let resetting = 0;
        class Impl {
            async getModelVersion() {
                this.modelVersion ??= (await (typeof this.model.version === "function" ? this.model.version() : this.model.version)) ?? 0;
                return this.modelVersion;
            }
            getCacheTime() {
                return this.cacheTime ?? Date.now();
            }
            get loading() {
                return this.value === undefined
                    || this.value instanceof Promise
                    || (this.model.cache ? !this.isCacheValid() : false);
            }
            get loadingInfo() {
                return this._loadingInfo;
            }
            get latest() {
                return this._latest;
            }
            constructor(name, model) {
                this.name = name;
                this.model = model;
                this.event = new EventManager_6.EventManager(this);
                this.loadId = loadId;
                this.errored = false;
                Object.assign(this, model.api);
                if (model.resetOnDestinyMembershipChange) {
                    const reset = async () => {
                        resetting++;
                        await this.reset();
                        resetting--;
                        if (!resetting) {
                            // eslint-disable-next-line no-self-assign
                            URL_2.default.path = URL_2.default.path;
                            // eslint-disable-next-line no-self-assign
                            location.href = location.href;
                        }
                    };
                    Store_5.default.event.subscribe("setDestinyMembershipOverride", reset);
                    Store_5.default.event.subscribe("deleteDestinyMembershipOverride", reset);
                    Bungie_1.default.event.subscribe("resetAuthentication", reset);
                    Bungie_1.default.event.subscribe("authenticated", event => event.authType === "new" && reset());
                }
            }
            isCacheValid(cacheTime = this.cacheTime, version = this.version, resetTime = this.model.resetTime) {
                if (cacheTime === undefined)
                    return false;
                if (this.loadId !== loadId)
                    return false;
                if (this.modelVersion === undefined || this.modelVersion !== version)
                    return false;
                if (!this.model.cache)
                    return false;
                if (resetTime === undefined)
                    return true;
                if (typeof resetTime === "number")
                    return Date.now() < cacheTime + resetTime;
                return cacheTime > Bungie_1.default[`last${resetTime}Reset`];
            }
            async resolveCache(includeExpired = false) {
                if (!this.model.cache || this.model.cache === "Memory")
                    return undefined;
                const cached = await Model.cacheDB.get("models", this.name);
                if (!cached)
                    return undefined;
                await this.getModelVersion();
                if (includeExpired === true || this.isCacheValid(cached.cacheTime, cached.version, includeExpired === "initial" ? this.model.useCacheOnInitial : undefined)) {
                    // this cached value is valid
                    console.debug(`Using cached data for '${this.name}', cached at ${new Date(cached.cacheTime).toLocaleString()}`);
                    this._latest = this.value = (this.model.process?.(cached.value) ?? cached.value ?? null);
                    this.cacheTime = cached.cacheTime;
                    this.version = cached.version;
                    this.event.emit("loaded", { value: this.value ?? undefined, fresh: false });
                    return this.value ?? undefined;
                }
                // we don't purge the data anymore so that deepsight.gg can show your inventory even if bungie's api is down
                // console.debug(`Purging expired cache data for '${this.name}'`);
                // await this.reset();
                this.model.cacheInvalidated?.(cached.value);
                this.event.emit("invalidCache");
                return undefined;
            }
            async reset(value) {
                if (!this.model.reset)
                    this._latest = this.value = value = undefined;
                else {
                    if (!value) {
                        const cached = await Model.cacheDB.get("models", this.name);
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        value = cached?.value;
                    }
                    await this.model.reset?.(value);
                }
                await Model.cacheDB.delete("models", this.name);
                delete this.modelVersion;
                await this.getModelVersion();
            }
            get() {
                if (this.value !== undefined && !(this.value instanceof Promise))
                    if (!this.isCacheValid())
                        delete this.value;
                if (this.value === undefined || this.errored) {
                    if (this.name)
                        console.debug(`No value in memory for '${this.name}'`);
                    this.event.emit("loading");
                    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
                    const promise = new Promise(async (resolve, reject) => {
                        if (this.model.cache && this.model.cache !== "Memory") {
                            const cached = await this.resolveCache();
                            if (cached)
                                return resolve(cached);
                        }
                        if (!this.model.generate)
                            // this model can't be generated on its own, it must be initialised instead
                            // in this case, wait for the loaded event and return the new value
                            return resolve(this.event.waitFor("loaded")
                                .then(({ value }) => value));
                        const subscriptions = new Map();
                        let lastMessage = [];
                        const api = {
                            setCacheTime: (cacheTimeSupplier) => this.getCacheTime = cacheTimeSupplier,
                            emitProgress: (progress, messages, bubbled = false) => {
                                messages = Arrays_2.default.resolve(messages);
                                this._loadingInfo = { progress, messages };
                                // console.debug(`Load progress ${Math.floor(progress * 100)}%: ${messages.join(" ") || "Loading"}`);
                                if (!bubbled) {
                                    lastMessage = messages;
                                    for (const [model, handleSubUpdate] of [...subscriptions]) {
                                        model.event.unsubscribe("loadUpdate", handleSubUpdate);
                                        subscriptions.delete(model);
                                    }
                                }
                                this.event.emit("loadUpdate", { progress, messages });
                            },
                            subscribeProgress: (model, amount, from = 0) => {
                                if (model.loading) {
                                    if (subscriptions.has(model))
                                        return api;
                                    const handleSubUpdate = ({ progress: subAmount, messages }) => 
                                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                                    api.emitProgress(from + subAmount * amount, [...messages, ...lastMessage].filter(m => m), true);
                                    model.event.subscribe("loadUpdate", handleSubUpdate);
                                    subscriptions.set(model, handleSubUpdate);
                                    model.event.subscribeOnce("loaded", () => {
                                        model.event.unsubscribe("loadUpdate", handleSubUpdate);
                                        subscriptions.delete(model);
                                    });
                                }
                                return api;
                            },
                            subscribeProgressAndWait: (model, amount, from) => {
                                api.subscribeProgress(model, amount, from);
                                return model.await();
                            },
                            subscribeProgressAndWaitAll: (models, amount, from = 0) => {
                                const progresses = models.map(() => 0);
                                const messageses = models.map(() => []);
                                for (let i = 0; i < models.length; i++) {
                                    const model = models[i];
                                    if (!model.loading || subscriptions.has(model)) {
                                        progresses[i] = 1;
                                        continue;
                                    }
                                    const handleSubUpdate = ({ progress: subAmount, messages }) => {
                                        const progress = from + subAmount * amount;
                                        progresses[i] = progress;
                                        messageses[i] = messages;
                                        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                                        api.emitProgress(Maths_1.default.average(...progresses), [...messageses.flat(), ...lastMessage].filter(m => m), true);
                                    };
                                    model.event.subscribe("loadUpdate", handleSubUpdate);
                                    subscriptions.set(model, handleSubUpdate);
                                    model.event.subscribeOnce("loaded", () => {
                                        model.event.unsubscribe("loadUpdate", handleSubUpdate);
                                        subscriptions.delete(model);
                                    });
                                }
                                return Promise.all(models.map(model => model.await()));
                            },
                        };
                        const generated = Promise.resolve(this.model.generate?.(api));
                        void generated.catch(async (error) => {
                            console.error(`Model '${this.name}' failed to load:`, error);
                            if (this.model.useCacheOnError) {
                                const cached = await this.resolveCache(true);
                                if (cached) {
                                    api.emitProgress(1);
                                    return resolve(cached);
                                }
                            }
                            this.event.emit("errored", { error: error });
                            this.errored = true;
                            api.emitProgress(1);
                            reject(error);
                        });
                        void generated.then(async (value) => {
                            const result = await this.set(value);
                            api.emitProgress(1);
                            resolve(result);
                        });
                    });
                    this.errored = false;
                    this.value = promise ?? null;
                    return undefined;
                }
                if (this.value instanceof Promise)
                    return undefined;
                return this.value ?? undefined;
            }
            async set(value) {
                const filtered = (this.model.process?.(value) ?? value);
                this._latest = this.value = (filtered ?? null);
                this.cacheTime = Date.now();
                this.version = await this.getModelVersion();
                this.loadId = loadId;
                if (this.model.cache && this.model.cache !== "Memory") {
                    const cached = { cacheTime: this.cacheTime, value, version: this.version };
                    if (this.model.cache === "Global")
                        cached.persist = true;
                    void Model.cacheDB.set("models", this.name, cached);
                }
                this.event.emit("loaded", { value: filtered, fresh: true });
                if (this.name)
                    console.debug(`${!this.model.cache || this.model.cache === "Memory" ? "Loaded" : "Cached"} data for '${this.name}'`);
                return filtered;
            }
            async await(api, amount = 1, from = 0) {
                if (api)
                    return api.subscribeProgressAndWait(this, amount, from);
                return this.get() ?? (await Promise.resolve(this.value)) ?? undefined;
            }
        }
        Model.Impl = Impl;
    })(Model || (Model = {}));
    exports.default = Model;
});
define("model/models/Profile", ["require", "exports", "model/Model", "utility/BungieID", "utility/ProfileManager", "utility/Store", "utility/Time", "utility/endpoint/bungie/endpoint/destiny2/GetProfile", "utility/endpoint/bungie/endpoint/groupv2/GetUserClan"], function (require, exports, Model_1, BungieID_4, ProfileManager_2, Store_6, Time_2, GetProfile_2, GetUserClan_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeProfileResponseComponentMap(map) {
        return map;
    }
    const profileResponseComponentMap = makeProfileResponseComponentMap({
        vendorReceipts: 101 /* DestinyComponentType.VendorReceipts */,
        profileInventory: 102 /* DestinyComponentType.ProfileInventories */,
        profileCurrencies: 103 /* DestinyComponentType.ProfileCurrencies */,
        profile: 100 /* DestinyComponentType.Profiles */,
        platformSilver: 105 /* DestinyComponentType.PlatformSilver */,
        profileKiosks: 500 /* DestinyComponentType.Kiosks */,
        profilePlugSets: 305 /* DestinyComponentType.ItemSockets */,
        profileProgression: 104 /* DestinyComponentType.ProfileProgression */,
        profilePresentationNodes: 700 /* DestinyComponentType.PresentationNodes */,
        profileRecords: 900 /* DestinyComponentType.Records */,
        profileCollectibles: 800 /* DestinyComponentType.Collectibles */,
        profileTransitoryData: 1000 /* DestinyComponentType.Transitory */,
        metrics: 1100 /* DestinyComponentType.Metrics */,
        profileStringVariables: 1200 /* DestinyComponentType.StringVariables */,
        characters: 200 /* DestinyComponentType.Characters */,
        characterInventories: 201 /* DestinyComponentType.CharacterInventories */,
        characterProgressions: 202 /* DestinyComponentType.CharacterProgressions */,
        characterRenderData: 203 /* DestinyComponentType.CharacterRenderData */,
        characterActivities: 204 /* DestinyComponentType.CharacterActivities */,
        characterEquipment: 205 /* DestinyComponentType.CharacterEquipment */,
        characterKiosks: 500 /* DestinyComponentType.Kiosks */,
        characterPlugSets: 305 /* DestinyComponentType.ItemSockets */,
        characterUninstancedItemComponents: undefined,
        characterPresentationNodes: 700 /* DestinyComponentType.PresentationNodes */,
        characterRecords: 900 /* DestinyComponentType.Records */,
        characterCollectibles: 800 /* DestinyComponentType.Collectibles */,
        characterStringVariables: 1200 /* DestinyComponentType.StringVariables */,
        characterCraftables: 1300 /* DestinyComponentType.Craftables */,
        itemComponents: [
            300 /* DestinyComponentType.ItemInstances */,
            303 /* DestinyComponentType.ItemRenderData */,
            304 /* DestinyComponentType.ItemStats */,
            305 /* DestinyComponentType.ItemSockets */,
            310 /* DestinyComponentType.ItemReusablePlugs */,
            309 /* DestinyComponentType.ItemPlugObjectives */,
            306 /* DestinyComponentType.ItemTalentGrids */,
            308 /* DestinyComponentType.ItemPlugStates */,
            301 /* DestinyComponentType.ItemObjectives */,
            302 /* DestinyComponentType.ItemPerks */,
        ],
        characterCurrencyLookups: 600 /* DestinyComponentType.CurrencyLookups */,
        profileCommendations: 1400 /* DestinyComponentType.SocialCommendations */,
        characterLoadouts: 206 /* DestinyComponentType.CharacterLoadouts */,
    });
    class ComponentModel extends Model_1.default.Impl {
        constructor(type, bungieId) {
            const applicableKeys = [];
            for (const [key, applicableComponents] of Object.entries(profileResponseComponentMap)) {
                if (applicableComponents === undefined)
                    continue;
                const applicable = typeof applicableComponents === "number" ? applicableComponents === type
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                    : applicableComponents.includes(type);
                if (applicable)
                    applicableKeys.push(key);
            }
            super(`profile ${BungieID_4.default.stringify(bungieId)} component ${type} [${applicableKeys.join(",")}]`, {
                cache: "Session",
                resetTime: Time_2.default.seconds(20),
                useCacheOnInitial: Time_2.default.days(1),
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                generate: undefined,
                // resetOnDestinyMembershipChange: true,
            });
            this.type = type;
            this.bungieId = bungieId;
            this.applicableKeys = applicableKeys;
        }
        async update(response) {
            const newData = {};
            let hasNewData = false;
            for (const key of this.applicableKeys) {
                if (response[key] !== undefined) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    newData[key] = response[key];
                    hasNewData = true;
                }
            }
            if (hasNewData)
                await this.set(newData);
        }
    }
    const models = {};
    let lastOperation;
    function mergeProfile(profileInto, profileFrom) {
        const keys = new Set([...Object.keys(profileInto), ...Object.keys(profileFrom)]);
        keys.delete("_header");
        for (const key of keys) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            profileInto[key] = mergeProfileKey(key, profileInto[key], profileFrom[key]);
        }
    }
    function mergeProfileKey(key, value1, value2) {
        if (value1 && value2) {
            if (Array.isArray(profileResponseComponentMap[key]))
                return { ...value1, ...value2 };
            // overwrite if this is only a single component
            return value2;
        }
        return value1 ?? value2;
    }
    let isInitial = true;
    function Profile(...components) {
        const initial = isInitial;
        isInitial = false;
        components.sort();
        return Model_1.default.createDynamic(Time_2.default.seconds(30), async (api) => {
            // only allow one profile query at a time
            while (lastOperation)
                await lastOperation;
            const account = ProfileManager_2.default.get();
            if (!account || account.data.membershipType === undefined || account.data.membershipId === undefined)
                return {
                    lastModified: new Date(),
                    bungieID: { name: "", code: 0 },
                    responseMintedTimestamp: new Date().toISOString(),
                };
            const idString = BungieID_4.default.stringify(account.id);
            const result = {};
            const userModels = models[idString] ??= {};
            for (const component of components)
                userModels[component] ??= new ComponentModel(component, account.id);
            // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
            lastOperation = (async () => {
                api.emitProgress(0, "Fetching profile");
                const missingComponents = [];
                for (const component of components) {
                    const cached = await userModels[component]?.resolveCache(initial ? "initial" : undefined);
                    if (cached) {
                        mergeProfile(result, cached);
                    }
                    else
                        missingComponents.push(component);
                }
                if (!missingComponents.length)
                    // all components cached, no need to make a request to bungie
                    return;
                if (missingComponents.some(component => profileResponseComponentMap.itemComponents.includes(component)))
                    if (!missingComponents.includes(102 /* DestinyComponentType.ProfileInventories */) && !missingComponents.includes(201 /* DestinyComponentType.CharacterInventories */) && !missingComponents.includes(205 /* DestinyComponentType.CharacterEquipment */)) {
                        if (components.includes(201 /* DestinyComponentType.CharacterInventories */))
                            missingComponents.push(201 /* DestinyComponentType.CharacterInventories */);
                        if (components.includes(205 /* DestinyComponentType.CharacterEquipment */))
                            missingComponents.push(205 /* DestinyComponentType.CharacterEquipment */);
                        if (components.includes(102 /* DestinyComponentType.ProfileInventories */ || (!missingComponents.includes(201 /* DestinyComponentType.CharacterInventories */) && !missingComponents.includes(205 /* DestinyComponentType.CharacterEquipment */))))
                            missingComponents.push(102 /* DestinyComponentType.ProfileInventories */);
                    }
                api.emitProgress(1 / 3, "Fetching profile");
                const newData = await GetProfile_2.default
                    .setOptionalAuth(!!account.data.accessToken)
                    .query(account.data.membershipType, account.data.membershipId, missingComponents);
                mergeProfile(result, newData);
                result.bungieID = account.id;
                result.lastModified = new Date(newData._headers.get("Last-Modified") ?? Date.now());
                const currentCharacter = Object.values(result.characters.data ?? {})
                    ?.sort(({ dateLastPlayed: dateLastPlayedA }, { dateLastPlayed: dateLastPlayedB }) => new Date(dateLastPlayedB).getTime() - new Date(dateLastPlayedA).getTime())?.[0];
                let profile = ProfileManager_2.default.update(account.id, {
                    lastModified: result.lastModified.toISOString(),
                    emblemHash: currentCharacter?.emblemHash,
                    class: currentCharacter?.classType,
                });
                if (profile.callsign === undefined || !profile.callsignLastModified || Date.now() - new Date(profile.callsignLastModified).getTime() > Time_2.default.hours(1)) {
                    const clan = await GetUserClan_2.default.query(account.data.membershipType, account.data.membershipId);
                    profile = ProfileManager_2.default.update(account.id, {
                        callsign: clan?.results?.[0]?.group?.clanInfo?.clanCallsign ?? "",
                        callsignLastModified: new Date().toISOString(),
                    });
                }
                for (let i = 0; i < components.length; i++) {
                    const component = components[i];
                    api.emitProgress(2 / 3 + 1 / 3 * (i / components.length), "Storing profile");
                    await userModels[component].update(newData);
                }
            })().catch(async () => {
                const missingComponents = [];
                let hadComponents = false;
                for (const component of components) {
                    const cached = await userModels[component]?.resolveCache(true);
                    if (cached) {
                        hadComponents = true;
                        mergeProfile(result, cached);
                    }
                    else {
                        missingComponents.push(component);
                    }
                }
                if (hadComponents && missingComponents.length)
                    console.warn("Missing profile components in cache:", ...missingComponents);
            });
            await lastOperation;
            lastOperation = undefined;
            result.lastModified ??= new Date(Store_6.default.items.profiles?.[idString]?.lastModified ?? Date.now());
            return result;
        });
    }
    (function (Profile) {
        async function reset() {
            const promises = [];
            for (const component of Object.values(profileResponseComponentMap).flat()) {
                if (component) {
                    for (const bungieId of Object.keys(Store_6.default.items.profiles ?? {})) {
                        const id = BungieID_4.default.parse(bungieId);
                        if (!id)
                            continue;
                        models[bungieId] ??= {};
                        const model = models[bungieId][component] ??= new ComponentModel(component, id);
                        promises.push(model.reset());
                    }
                }
            }
            await Promise.all(promises);
        }
        Profile.reset = reset;
    })(Profile || (Profile = {}));
    exports.default = Profile;
});
define("model/models/state/IStateModification", ["require", "exports", "utility/EventManager", "utility/ProfileManager", "utility/Time"], function (require, exports, EventManager_7, ProfileManager_3, Time_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const BUNGIE_UNTRUSTWORTHINESS = Time_3.default.minutes(1);
    var IStateModification;
    (function (IStateModification) {
        const REGISTRY = {};
        IStateModification.event = new EventManager_7.EventManager({});
        function register(implementation) {
            return REGISTRY[implementation.type] = {
                ...implementation,
                add(modification) {
                    const profileStore = ProfileManager_3.default.get();
                    if (!profileStore || !profile)
                        return;
                    ProfileManager_3.default.update(profileStore.id, {
                        stateModifications: [
                            ...profileStore.data.stateModifications ?? [],
                            modification,
                        ],
                    });
                    try {
                        implementation.apply(profile, modification);
                    }
                    catch (err) {
                        console.warn(`Failed to apply ${implementation.type}:`, err, modification);
                    }
                    IStateModification.event.emit("apply");
                },
            };
        }
        IStateModification.register = register;
        function apply(profile) {
            // grab modifications
            const profileStore = ProfileManager_3.default.get();
            let modifications = profileStore?.data.stateModifications;
            if (!profileStore || !modifications?.length)
                return;
            // discard old/outdated modifications
            const profileTime = profile.lastModified.getTime();
            console.log("Profile time:", new Date(profileTime).toLocaleString());
            modifications = modifications.filter(modification => {
                if (modification.time < profileTime - BUNGIE_UNTRUSTWORTHINESS) {
                    console.log("Discarding old modification from", new Date(modification.time).toLocaleString(), modification);
                    return false;
                }
                return true;
            });
            // save what remains
            ProfileManager_3.default.update(profileStore.id, {
                stateModifications: modifications,
            });
            // apply what remains
            for (const modification of modifications) {
                const implementation = REGISTRY[modification.type];
                if (!implementation) {
                    console.warn(`Unknown profile state modification type '${modification.type}'`, modification);
                    continue;
                }
                try {
                    implementation.apply(profile, modification);
                }
                catch (err) {
                    console.warn(`Failed to apply ${implementation.type}:`, err, modification);
                }
            }
            IStateModification.event.emit("apply");
        }
        IStateModification.apply = apply;
    })(IStateModification || (IStateModification = {}));
    exports.default = IStateModification;
    Object.assign(window, { IStateModification });
});
define("ui/utility/LoadingManager", ["require", "exports", "model/Model", "utility/EventManager", "utility/endpoint/bungie/Bungie"], function (require, exports, Model_2, EventManager_8, Bungie_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LoadingManager {
        constructor() {
            this.event = new EventManager_8.EventManager(this);
            this.model = Model_2.default.createTemporary(async (api) => {
                api.emitProgress(0, "Loading");
                if (Bungie_2.default.authenticated)
                    await this.event.waitFor("end");
            });
            this.loaders = new Set();
            Object.assign(window, { Loading: this });
        }
        get loading() {
            return this.loaders.size > 0;
        }
        start(id) {
            const newlyLoading = this.loaders.size === 0;
            this.loaders.add(id);
            if (newlyLoading) {
                this.event.emit("start");
                this.model.get();
            }
        }
        end(id) {
            this.loaders.delete(id);
            if (!this.loaders.size)
                this.event.emit("end");
        }
        toggle(id, newState = !this.loaders.has(id)) {
            if (newState)
                this.start(id);
            else
                this.end(id);
        }
    }
    exports.default = new LoadingManager;
});
define("model/models/ProfileBatch", ["require", "exports", "model/Model", "model/models/Profile", "model/models/state/IStateModification", "ui/utility/LoadingManager", "utility/Time"], function (require, exports, Model_3, Profile_1, IStateModification_1, LoadingManager_1, Time_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const allComponentTypes = [
        100 /* DestinyComponentType.Profiles */,
        101 /* DestinyComponentType.VendorReceipts */,
        102 /* DestinyComponentType.ProfileInventories */,
        103 /* DestinyComponentType.ProfileCurrencies */,
        104 /* DestinyComponentType.ProfileProgression */,
        105 /* DestinyComponentType.PlatformSilver */,
        200 /* DestinyComponentType.Characters */,
        201 /* DestinyComponentType.CharacterInventories */,
        202 /* DestinyComponentType.CharacterProgressions */,
        203 /* DestinyComponentType.CharacterRenderData */,
        204 /* DestinyComponentType.CharacterActivities */,
        205 /* DestinyComponentType.CharacterEquipment */,
        206 /* DestinyComponentType.CharacterLoadouts */,
        300 /* DestinyComponentType.ItemInstances */,
        301 /* DestinyComponentType.ItemObjectives */,
        302 /* DestinyComponentType.ItemPerks */,
        303 /* DestinyComponentType.ItemRenderData */,
        304 /* DestinyComponentType.ItemStats */,
        305 /* DestinyComponentType.ItemSockets */,
        306 /* DestinyComponentType.ItemTalentGrids */,
        307 /* DestinyComponentType.ItemCommonData */,
        308 /* DestinyComponentType.ItemPlugStates */,
        309 /* DestinyComponentType.ItemPlugObjectives */,
        310 /* DestinyComponentType.ItemReusablePlugs */,
        400 /* DestinyComponentType.Vendors */,
        401 /* DestinyComponentType.VendorCategories */,
        402 /* DestinyComponentType.VendorSales */,
        500 /* DestinyComponentType.Kiosks */,
        600 /* DestinyComponentType.CurrencyLookups */,
        700 /* DestinyComponentType.PresentationNodes */,
        800 /* DestinyComponentType.Collectibles */,
        900 /* DestinyComponentType.Records */,
        1000 /* DestinyComponentType.Transitory */,
        1100 /* DestinyComponentType.Metrics */,
        1200 /* DestinyComponentType.StringVariables */,
        1300 /* DestinyComponentType.Craftables */,
        1400 /* DestinyComponentType.SocialCommendations */,
    ];
    allComponentTypes;
    const ProfileBatch = Model_3.default.createDynamic(Time_4.default.seconds(30), async (api) => {
        api.emitProgress(0, "Loading profile");
        const ProfileQuery = (0, Profile_1.default)(100 /* DestinyComponentType.Profiles */, 200 /* DestinyComponentType.Characters */, 104 /* DestinyComponentType.ProfileProgression */, 206 /* DestinyComponentType.CharacterLoadouts */, 201 /* DestinyComponentType.CharacterInventories */, 205 /* DestinyComponentType.CharacterEquipment */, 102 /* DestinyComponentType.ProfileInventories */, 300 /* DestinyComponentType.ItemInstances */, 309 /* DestinyComponentType.ItemPlugObjectives */, 304 /* DestinyComponentType.ItemStats */, 900 /* DestinyComponentType.Records */, 305 /* DestinyComponentType.ItemSockets */, 310 /* DestinyComponentType.ItemReusablePlugs */, 308 /* DestinyComponentType.ItemPlugStates */, 302 /* DestinyComponentType.ItemPerks */, 202 /* DestinyComponentType.CharacterProgressions */, 800 /* DestinyComponentType.Collectibles */, 204 /* DestinyComponentType.CharacterActivities */, // displaying whether items are currently obtainable
        1200 /* DestinyComponentType.StringVariables */);
        const profile = await ProfileQuery.await();
        Object.assign(window, { profile });
        return profile;
    }, "Profile");
    ProfileBatch.event.subscribe("loading", () => LoadingManager_1.default.start("profile"));
    ProfileBatch.event.subscribe("loaded", () => {
        IStateModification_1.default.apply(ProfileBatch.latest);
        LoadingManager_1.default.end("profile");
    });
    exports.default = ProfileBatch;
});
define("utility/decorator/Bound", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bound = Bound;
    exports.Final = Final;
    function Bound(target, key, descriptor) {
        return Bounder(target, key, descriptor);
    }
    function Final(target, key, descriptor) {
        return Bounder(target, key, descriptor);
    }
    function Bounder(target, key, descriptor) {
        return {
            configurable: false,
            enumerable: descriptor.enumerable,
            get() {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
                if (!this || this === target.prototype || this.hasOwnProperty(key) || typeof descriptor.value !== "function") {
                    return descriptor.value;
                }
                const value = descriptor.value.bind(this);
                Object.defineProperty(this, key, {
                    configurable: false,
                    enumerable: descriptor.enumerable,
                    value,
                });
                return value;
            },
        };
    }
    exports.default = Bound;
});
define("utility/endpoint/clarity/ClarityEndpoint", ["require", "exports", "utility/endpoint/Endpoint"], function (require, exports, Endpoint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ClarityEndpoint extends Endpoint_2.default {
        constructor(path, init) {
            super(path);
            Object.assign(this, init);
        }
        resolvePath() {
            return `https://database-clarity.github.io/Live-Clarity-Database/${super.resolvePath()}`;
        }
    }
    exports.default = ClarityEndpoint;
});
define("utility/endpoint/clarity/endpoint/GetClarityDescriptions", ["require", "exports", "utility/endpoint/clarity/ClarityEndpoint"], function (require, exports, ClarityEndpoint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new ClarityEndpoint_1.default("descriptions/clarity.json");
});
define("utility/endpoint/clarity/endpoint/GetClarityDatabase", ["require", "exports", "utility/endpoint/Endpoint", "utility/endpoint/clarity/endpoint/GetClarityDescriptions"], function (require, exports, Endpoint_3, GetClarityDescriptions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = (new class extends Endpoint_3.default {
        constructor() {
            super("");
        }
        async query() {
            const result = {
                ClarityDescriptions: await GetClarityDescriptions_1.default.query(),
            };
            Object.defineProperty(result, "_headers", {
                enumerable: false,
                get: () => new Headers(),
            });
            return result;
        }
    });
});
define("utility/endpoint/deepsight/DeepsightEndpoint", ["require", "exports", "utility/endpoint/Endpoint"], function (require, exports, Endpoint_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeepsightEndpoint extends Endpoint_4.default {
        constructor(path, init) {
            super(`/manifest/${path}`);
            Object.assign(this, init);
        }
    }
    exports.default = DeepsightEndpoint;
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightAdeptDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_1.default("DeepsightAdeptDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightBreakerSourceDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_2.default("DeepsightBreakerSourceDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightBreakerTypeDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_3.default("DeepsightBreakerTypeDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightCatalystDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_4.default("DeepsightCatalystDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightCollectionsDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_5.default("DeepsightCollectionsDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightDropTableDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_6.default("DeepsightDropTableDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightEmblemDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_7.default("DeepsightEmblemDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightMomentDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_8.default("DeepsightMomentDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightPlugCategorisation", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_9.default("DeepsightPlugCategorisation.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightSocketCategorisation", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_10.default("DeepsightSocketCategorisation.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightSocketExtendedDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_11.default("DeepsightSocketExtendedDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightTierTypeDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_12.default("DeepsightTierTypeDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightWallpaperDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_13.default("DeepsightWallpaperDefinition.json");
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightManifest", ["require", "exports", "utility/endpoint/Endpoint", "utility/endpoint/deepsight/endpoint/GetDeepsightAdeptDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightBreakerSourceDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightBreakerTypeDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightCatalystDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightCollectionsDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightDropTableDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightEmblemDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightMomentDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightPlugCategorisation", "utility/endpoint/deepsight/endpoint/GetDeepsightSocketCategorisation", "utility/endpoint/deepsight/endpoint/GetDeepsightSocketExtendedDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightTierTypeDefinition", "utility/endpoint/deepsight/endpoint/GetDeepsightWallpaperDefinition"], function (require, exports, Endpoint_5, GetDeepsightAdeptDefinition_1, GetDeepsightBreakerSourceDefinition_1, GetDeepsightBreakerTypeDefinition_1, GetDeepsightCatalystDefinition_1, GetDeepsightCollectionsDefinition_1, GetDeepsightDropTableDefinition_1, GetDeepsightEmblemDefinition_1, GetDeepsightMomentDefinition_1, GetDeepsightPlugCategorisation_1, GetDeepsightSocketCategorisation_1, GetDeepsightSocketExtendedDefinition_1, GetDeepsightTierTypeDefinition_1, GetDeepsightWallpaperDefinition_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = (new class extends Endpoint_5.default {
        constructor() {
            super("");
        }
        async query() {
            const result = {
                DeepsightMomentDefinition: await GetDeepsightMomentDefinition_1.default.query(),
                DeepsightWallpaperDefinition: await GetDeepsightWallpaperDefinition_1.default.query(),
                DeepsightDropTableDefinition: await GetDeepsightDropTableDefinition_1.default.query(),
                DeepsightPlugCategorisation: await GetDeepsightPlugCategorisation_1.default.query(),
                DeepsightSocketCategorisation: await GetDeepsightSocketCategorisation_1.default.query(),
                DeepsightTierTypeDefinition: await GetDeepsightTierTypeDefinition_1.default.query(),
                // DeepsightVendorDefinition: await GetDeepsightVendorDefinition.query(),
                DeepsightCollectionsDefinition: await GetDeepsightCollectionsDefinition_1.default.query(),
                DeepsightAdeptDefinition: await GetDeepsightAdeptDefinition_1.default.query(),
                DeepsightEmblemDefinition: await GetDeepsightEmblemDefinition_1.default.query(),
                DeepsightSocketExtendedDefinition: await GetDeepsightSocketExtendedDefinition_1.default.query(),
                DeepsightCatalystDefinition: await GetDeepsightCatalystDefinition_1.default.query(),
                DeepsightBreakerTypeDefinition: await GetDeepsightBreakerTypeDefinition_1.default.query(),
                DeepsightBreakerSourceDefinition: await GetDeepsightBreakerSourceDefinition_1.default.query(),
            };
            Object.defineProperty(result, "_headers", {
                enumerable: false,
                get: () => new Headers(),
            });
            return result;
        }
    });
});
define("model/models/manifest/IManifest", ["require", "exports", "model/Model", "utility/decorator/Bound"], function (require, exports, Model_4, Bound_1) {
    "use strict";
    var _ManifestItem_instances, _ManifestItem_generate;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ManifestItem = exports.IManifest = void 0;
    var IManifest;
    (function (IManifest) {
        function elapsed(elapsed) {
            if (elapsed < 1)
                return `${Math.floor(elapsed * 1_000)} s`;
            if (elapsed < 1_000)
                return `${Math.floor(elapsed)} ms`;
            if (elapsed < 60_000)
                return `${+(elapsed / 1_000).toFixed(2)} s`;
            return `${+(elapsed / 60_000).toFixed(2)} m`;
        }
        IManifest.elapsed = elapsed;
        let CacheComponentKey;
        (function (CacheComponentKey) {
            function get(componentName) {
                return `manifest [${componentName}]`;
            }
            CacheComponentKey.get = get;
            function getBundle(componentName) {
                return `manifest bundle [${componentName}]`;
            }
            CacheComponentKey.getBundle = getBundle;
        })(CacheComponentKey = IManifest.CacheComponentKey || (IManifest.CacheComponentKey = {}));
    })(IManifest || (exports.IManifest = IManifest = {}));
    class ManifestItem {
        static logQueryCounts() {
            console.debug("Query counts:", Object.fromEntries(Object.entries(ManifestItem["queryCounts"])
                .map(([over, counts]) => [over, Object.entries(counts)
                    .sort(([, a], [, b]) => b - a)])));
        }
        constructor(componentName, hostModel) {
            _ManifestItem_instances.add(this);
            this.componentName = componentName;
            this.hostModel = hostModel;
            this.memoryCache = {};
            this.stagedTransaction = Model_4.default.cacheDB.stagedTransaction([IManifest.CacheComponentKey.get(componentName)]);
            this.modelCache = Model_4.default.create(IManifest.CacheComponentKey.getBundle(componentName), {
                cache: "Global",
                generate: () => this.createCache(),
            });
        }
        get(index, key) {
            if (key === undefined)
                key = index, index = undefined;
            if (key === undefined || key === null)
                return undefined;
            const memoryCacheKey = `${index ?? "/"}:${key}`;
            if (memoryCacheKey in this.memoryCache)
                return this.memoryCache[memoryCacheKey] ?? undefined;
            return this.resolve(memoryCacheKey, key, index);
        }
        async resolve(memoryCacheKey, key, index, cached = true) {
            await this.loadCache();
            if (memoryCacheKey in this.memoryCache)
                return this.memoryCache[memoryCacheKey] ?? undefined;
            const counts = ManifestItem.queryCounts[this.componentName] ??= {};
            counts[key] ??= 0;
            counts[key]++;
            ManifestItem.queryCounts.ALL ??= {};
            ManifestItem.queryCounts.ALL[key] ??= 0;
            ManifestItem.queryCounts.ALL[key]++;
            const promise = this.stagedTransaction.get(IManifest.CacheComponentKey.get(this.componentName), `${key}`, index)
                .then(value => {
                if (cached) {
                    this.memoryCache[memoryCacheKey] = value ?? null;
                    this.updateManifestCache();
                }
                return value ?? undefined;
            });
            if (cached)
                this.memoryCache[memoryCacheKey] = promise;
            return promise;
        }
        all(index, key) {
            if (!this.manifestCacheState)
                return this.loadCache()
                    .then(() => this.all(index, key));
            const componentKey = IManifest.CacheComponentKey.get(this.componentName);
            if (index)
                return this.stagedTransaction.all(componentKey, `${key}`, index);
            return this.allCache ??= !this.allCached
                ? this.stagedTransaction.all(componentKey).then(this.filterAllNoDuplicates).then(all => this.allCache = all)
                : this.filterAllNoDuplicates(Object.values(this.memoryCache));
        }
        filterAllNoDuplicates(all) {
            const result = [];
            const hashes = new Set();
            for (const value of all) {
                if (value === null)
                    continue;
                if (value.hash === undefined) {
                    console.warn("Can't filter out duplicates for", this.componentName, "as there is no hash");
                    return all;
                }
                if (hashes.has(value.hash))
                    continue;
                result.push(value);
                hashes.add(value.hash);
            }
            return result;
        }
        primaryKeys(index, key) {
            const componentKey = IManifest.CacheComponentKey.get(this.componentName);
            if (index)
                return this.stagedTransaction.primaryKeys(componentKey, key === undefined ? undefined : `${key}`, index);
            return this.stagedTransaction.primaryKeys(componentKey);
        }
        indexKeys(index, mapper) {
            const componentKey = IManifest.CacheComponentKey.get(this.componentName);
            return this.stagedTransaction.indexKeys(componentKey, index, mapper);
        }
        async loadCache() {
            await (this.generationPromise ??= __classPrivateFieldGet(this, _ManifestItem_instances, "m", _ManifestItem_generate).call(this));
            delete this.generationPromise;
            if (this.manifestCacheState !== undefined)
                return this.manifestCacheState ? undefined : this.loadedManifestCache;
            this.manifestCacheState = false;
            return this.loadedManifestCache = (async () => {
                const bundleKey = IManifest.CacheComponentKey.getBundle(this.componentName);
                console.debug("Loading", bundleKey);
                const hasCache = !!await this.modelCache.resolveCache();
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                this.memoryCache = await this.modelCache.await();
                if (!hasCache) {
                    console.debug("Generating initial", bundleKey);
                    const cacheKeyRange = async (keyRange = this.cacheAllKeyRange && this.cacheAllKeyRange !== true ? this.cacheAllKeyRange : undefined) => {
                        const all = await this.stagedTransaction.all(IManifest.CacheComponentKey.get(this.componentName), keyRange);
                        for (const value of all) {
                            if ("hash" in value) {
                                const memoryCacheKey = `/:${value.hash}`;
                                this.memoryCache[memoryCacheKey] = value;
                            }
                        }
                    };
                    if (this.allCached !== undefined || this.cacheAllKeyRange !== undefined) {
                        await cacheKeyRange();
                    }
                    await this.cacheInitialiser?.(this.memoryCache, cacheKeyRange);
                    // save changes
                    clearTimeout(this.manifestCacheUpdateTimeout);
                    await this.modelCache.reset();
                    await this.modelCache.await();
                }
                if (this.allCached === false || this.allCached === true)
                    this.allCached = true;
                this.manifestCacheState = true;
                console.debug("Loaded", bundleKey);
                if (!this.subscribedToClearCache)
                    Model_4.default.event.subscribe("clearCache", () => {
                        delete this.manifestCacheState;
                        if (this.allCached === true)
                            this.allCached = false;
                    });
            })();
        }
        setPreCache(all, initialise) {
            this.cacheInitialiser = initialise;
            if (all) {
                this.allCached = all === true ? false : undefined;
                this.cacheAllKeyRange = all;
            }
        }
        async generate() {
        }
        createCache() {
            return JSON.parse(JSON.stringify(this.memoryCache));
        }
        updateManifestCache() {
            clearTimeout(this.manifestCacheUpdateTimeout);
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            this.manifestCacheUpdateTimeout = window.setTimeout(async () => {
                await this.modelCache.reset();
                await this.modelCache.await();
            }, 2000);
        }
    }
    exports.ManifestItem = ManifestItem;
    _ManifestItem_instances = new WeakSet(), _ManifestItem_generate = async function _ManifestItem_generate() {
        const hostCacheTime = this.hostModel.getCacheTime();
        const cacheTime = await Model_4.default.cacheDB.get("models", IManifest.CacheComponentKey.get(this.componentName)).then(cache => cache?.cacheTime ?? 0);
        if (cacheTime < hostCacheTime) {
            await this.generate();
            await Model_4.default.cacheDB.set("models", IManifest.CacheComponentKey.get(this.componentName), {
                cacheTime: hostCacheTime,
                value: null,
                version: "dynamic",
            });
        }
    };
    ManifestItem.queryCounts = {};
    __decorate([
        Bound_1.default
    ], ManifestItem.prototype, "filterAllNoDuplicates", null);
    Object.assign(window, { ManifestItem });
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightManifestVersions", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_14.default("versions.json");
});
define("model/models/manifest/DeepsightManifest", ["require", "exports", "model/Model", "model/models/manifest/IManifest", "utility/endpoint/deepsight/endpoint/GetDeepsightManifest", "utility/endpoint/deepsight/endpoint/GetDeepsightManifestVersions"], function (require, exports, Model_5, IManifest_1, GetDeepsightManifest_1, GetDeepsightManifestVersions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeepsightManifest = void 0;
    const DeepsightManifest = Model_5.default.create("deepsight manifest", {
        cache: "Global",
        version: async () => {
            const versions = await GetDeepsightManifestVersions_1.default.query();
            return `${Object.entries(versions)
                .filter((entry) => typeof entry[1] === "number")
                .map(([name, version]) => `${name}.${version}`)
                .sort()
                .join(",")}-2.deepsight.gg`;
        },
        async generate(api) {
            const deepsightComponents = await GetDeepsightManifest_1.default.query();
            const deepsightComponentNames = Object.keys(deepsightComponents);
            const cacheKeys = deepsightComponentNames.map(IManifest_1.IManifest.CacheComponentKey.get);
            await Model_5.default.cacheDB.upgrade((database, transaction) => {
                for (const cacheKey of cacheKeys) {
                    if (database.objectStoreNames.contains(cacheKey))
                        database.deleteObjectStore(cacheKey);
                    const store = database.createObjectStore(cacheKey);
                    switch (cacheKey) {
                        case "manifest [DeepsightMomentDefinition]":
                            if (!store.indexNames.contains("iconWatermark"))
                                store.createIndex("iconWatermark", "iconWatermark");
                            if (!store.indexNames.contains("id"))
                                store.createIndex("id", "id", { unique: true });
                            break;
                    }
                }
            });
            const totalLoad = deepsightComponentNames.length;
            await Model_5.default.cacheDB.transaction(deepsightComponentNames.map(IManifest_1.IManifest.CacheComponentKey.get), async (transaction) => {
                for (let i = 0; i < deepsightComponentNames.length; i++) {
                    const componentName = deepsightComponentNames[i];
                    const cacheKey = IManifest_1.IManifest.CacheComponentKey.get(componentName);
                    const startTime = performance.now();
                    console.info(`Caching objects from ${cacheKey}`);
                    api.emitProgress(i / totalLoad, "Storing manifest");
                    await transaction.clear(cacheKey);
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    for (const [itemId, itemValue] of Object.entries(deepsightComponents[componentName])) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        await transaction.set(cacheKey, itemId, itemValue);
                    }
                    console.info(`Finished caching objects from ${cacheKey} after ${IManifest_1.IManifest.elapsed(performance.now() - startTime)}`);
                }
            });
            return [...deepsightComponentNames];
        },
        process: componentNames => {
            const Manifest = Object.fromEntries(componentNames
                .map(componentName => [componentName, new IManifest_1.ManifestItem(componentName, DeepsightManifest)]));
            for (const componentName of componentNames) {
                Manifest[componentName].setPreCache(true);
            }
            Object.assign(window, { DeepsightManifest: Manifest });
            return Manifest;
        },
        reset: async (componentNames) => {
            for (const componentName of componentNames ?? []) {
                await Model_5.default.cacheDB.clear(IManifest_1.IManifest.CacheComponentKey.get(componentName));
                await Model_5.default.cacheDB.delete("models", IManifest_1.IManifest.CacheComponentKey.getBundle(componentName));
            }
        },
        cacheInvalidated: async (componentNames) => {
            for (const componentName of componentNames ?? []) {
                await Model_5.default.cacheDB.delete("models", IManifest_1.IManifest.CacheComponentKey.getBundle(componentName));
            }
        },
    });
    exports.DeepsightManifest = DeepsightManifest;
});
define("utility/endpoint/bungie/endpoint/destiny2/GetManifest", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_7.default
        .at("/Destiny2/Manifest/")
        .returning()
        .setOptionalAuth()
        .setSkipAuthHeaders();
});
define("model/models/manifest/DestinyManifest", ["require", "exports", "model/Model", "model/models/ProfileBatch", "model/models/manifest/DeepsightManifest", "model/models/manifest/IManifest", "utility/Env", "utility/Objects", "utility/endpoint/bungie/Bungie", "utility/endpoint/bungie/endpoint/destiny2/GetManifest"], function (require, exports, Model_6, ProfileBatch_1, DeepsightManifest_1, IManifest_2, Env_4, Objects_2, Bungie_3, GetManifest_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const elapsed = IManifest_2.IManifest.elapsed;
    const CacheComponentKey = IManifest_2.IManifest.CacheComponentKey;
    const ManifestURLs = Model_6.default.create("manifest urls", {
        cache: "Global",
        resetTime: 0,
        useCacheOnError: true,
        generate: () => GetManifest_1.default.query(),
    });
    const DestinyManifest = Model_6.default.create("destiny manifest", {
        cache: "Global",
        version: async () => {
            const manifest = await ManifestURLs.await();
            return `${manifest.version}-23.deepsight.gg`;
        },
        async generate(api) {
            const manifest = await ManifestURLs.await();
            const bungieComponentNames = Object.keys(manifest.jsonWorldComponentContentPaths.en);
            api.emitProgress(0, "Allocating stores for manifest");
            const cacheKeys = bungieComponentNames.map(CacheComponentKey.get);
            await Model_6.default.cacheDB.upgrade((database, transaction) => {
                for (const cacheKey of cacheKeys) {
                    if (database.objectStoreNames.contains(cacheKey))
                        database.deleteObjectStore(cacheKey);
                    const store = database.createObjectStore(cacheKey);
                    switch (cacheKey) {
                        case "manifest [DestinyInventoryItemDefinition]":
                            if (!store.indexNames.contains("iconWatermark"))
                                store.createIndex("iconWatermark", "iconWatermark");
                            if (!store.indexNames.contains("name"))
                                store.createIndex("name", "displayProperties.name");
                            if (!store.indexNames.contains("icon"))
                                store.createIndex("icon", "displayProperties.icon");
                            break;
                        case "manifest [DestinyRecordDefinition]":
                            if (!store.indexNames.contains("icon"))
                                store.createIndex("icon", "displayProperties.icon");
                            if (!store.indexNames.contains("name"))
                                store.createIndex("name", "displayProperties.name");
                            break;
                        case "manifest [DestinyCollectibleDefinition]":
                            if (!store.indexNames.contains("icon"))
                                store.createIndex("icon", "displayProperties.icon");
                            if (!store.indexNames.contains("name"))
                                store.createIndex("name", "displayProperties.name");
                            break;
                    }
                }
            });
            return [...bungieComponentNames, "DeepsightMomentDefinition"];
        },
        process: async (componentNames) => {
            const Manifest = Object.fromEntries(componentNames
                .map(componentName => [componentName, new DestinyManifestItem(componentName, DestinyManifest)]));
            for (const componentName of componentNames)
                await Manifest[componentName].initialise(Manifest);
            Object.assign(window, { Manifest, DestinyManifest: Manifest });
            return Manifest;
        },
        reset: async (componentNames) => {
            for (const componentName of componentNames ?? []) {
                await Model_6.default.cacheDB.clear(CacheComponentKey.get(componentName));
                await Model_6.default.cacheDB.delete("models", CacheComponentKey.getBundle(componentName));
                await Model_6.default.cacheDB.delete("models", CacheComponentKey.get(componentName));
            }
        },
        cacheInvalidated: async (componentNames) => {
            for (const componentName of componentNames ?? []) {
                await Model_6.default.cacheDB.delete("models", CacheComponentKey.getBundle(componentName));
            }
        },
    });
    exports.default = DestinyManifest;
    class DestinyManifestItem extends IManifest_2.ManifestItem {
        async generate() {
            const manifest = await ManifestURLs.await();
            const componentName = this.componentName;
            const cacheKey = CacheComponentKey.get(componentName);
            let startTime = performance.now();
            console.info(`Downloading ${cacheKey}`);
            // api.emitProgress((1 + i * 2) / totalLoad, "Downloading manifest");
            let data;
            let tryAgain = true;
            for (let i = 0; i < 5 && tryAgain; i++) {
                tryAgain = false;
                data = await fetch(Env_4.default.DEEPSIGHT_ENVIRONMENT === "dev" ? `/testiny/${componentName}.json` : `https://www.bungie.net${manifest.jsonWorldComponentContentPaths.en[componentName]}?corsfix=${i}`)
                    .then(response => response.json())
                    .catch(err => {
                    if (err.message.includes("Access-Control-Allow-Origin")) {
                        console.warn(`CORS error, trying again with a query string (attempt ${++i})`);
                        tryAgain = true;
                        return {};
                    }
                    throw err;
                });
            }
            console.info(`Finished downloading ${cacheKey} after ${elapsed(performance.now() - startTime)}`);
            startTime = performance.now();
            console.info(`Storing objects from ${cacheKey}`);
            // api.emitProgress((1 + i * 2 + 1) / totalLoad, "Storing manifest");
            const moments = cacheKey !== "manifest [DestinyInventoryItemDefinition]" ? []
                : await (await DeepsightManifest_1.DeepsightManifest.await()).DeepsightMomentDefinition.all();
            await Model_6.default.cacheDB.transaction([cacheKey], async (transaction) => {
                await transaction.clear(cacheKey);
                const replaceWatermarksByItemHash = Object.fromEntries(moments.flatMap(moment => (moment.itemHashes ?? [])
                    .map(itemHash => [itemHash, moment])) ?? []);
                for (const [key, definition] of Object.entries(data)) {
                    if (cacheKey === "manifest [DestinyInventoryItemDefinition]") {
                        const itemDef = definition;
                        // fix red war items that don't have watermarks for some reason
                        const replacementMoment = replaceWatermarksByItemHash[definition.hash];
                        if (replacementMoment) {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            itemDef.iconWatermark = replacementMoment.iconWatermark;
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            itemDef.iconWatermarkShelved = replacementMoment.iconWatermarkShelved;
                        }
                        else if (!itemDef.iconWatermark && itemDef.quality?.displayVersionWatermarkIcons.length) {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            itemDef.iconWatermark = itemDef.quality.displayVersionWatermarkIcons[0];
                        }
                    }
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    await transaction.set(cacheKey, key, definition);
                }
            });
            console.info(`Finished caching objects from ${cacheKey} after ${elapsed(performance.now() - startTime)}`);
        }
        async initialise(Manifest) {
            const componentName = this.componentName;
            switch (componentName) {
                case "DestinyInventoryItemDefinition": {
                    ////////////////////////////////////
                    // precache item hashes from profile
                    const profile = Bungie_3.default.authenticated ? await ProfileBatch_1.default.await() : undefined;
                    const itemHashes = new Set((profile?.profileInventory?.data?.items.map(item => item.itemHash) ?? [])
                        .concat(Object.values(profile?.characterInventories?.data ?? Objects_2.default.EMPTY)
                        .concat(Object.values(profile?.characterEquipment?.data ?? Objects_2.default.EMPTY))
                        .flatMap(inventory => inventory.items.map(item => item.itemHash))));
                    for (const itemSockets of Object.values(profile?.itemComponents?.sockets.data ?? Objects_2.default.EMPTY))
                        for (const socket of itemSockets.sockets ?? [])
                            if (socket.plugHash)
                                itemHashes.add(socket.plugHash);
                    for (const itemPlugsByItems of Object.values(profile?.itemComponents?.reusablePlugs.data ?? Objects_2.default.EMPTY))
                        for (const plugs of Object.values(itemPlugsByItems.plugs))
                            for (const plug of plugs)
                                itemHashes.add(plug.plugItemHash);
                    const { DeepsightCollectionsDefinition } = await DeepsightManifest_1.DeepsightManifest.await();
                    for (const momentItems of await DeepsightCollectionsDefinition.all())
                        for (const itemList of Object.values(momentItems.buckets))
                            for (const itemHash of itemList)
                                itemHashes.add(itemHash);
                    Manifest[componentName].setPreCache([...itemHashes], async (cache, cacheKeyRange) => {
                        ////////////////////////////////////
                        // precache plug items from cached item defs
                        let values = Object.values(cache);
                        const itemHashes = new Set();
                        for await (const itemDef of values)
                            if (itemDef?.inventory?.recipeItemHash)
                                if (!cache[`/:${itemDef.inventory.recipeItemHash}`])
                                    itemHashes.add(itemDef.inventory.recipeItemHash);
                        await cacheKeyRange([...itemHashes]);
                        itemHashes.clear();
                        values = Object.values(cache);
                        for await (const itemDef of values) {
                            for (const socketEntry of itemDef?.sockets?.socketEntries ?? []) {
                                if (!cache[`/:${socketEntry.singleInitialItemHash}`])
                                    itemHashes.add(socketEntry.singleInitialItemHash);
                                for (const plug of socketEntry.reusablePlugItems)
                                    if (!cache[`/:${plug.plugItemHash}`])
                                        itemHashes.add(plug.plugItemHash);
                                let plugSet = await Manifest.DestinyPlugSetDefinition.get(socketEntry.reusablePlugSetHash);
                                for (const plugItem of plugSet?.reusablePlugItems ?? [])
                                    if (!cache[`/:${plugItem.plugItemHash}`])
                                        itemHashes.add(plugItem.plugItemHash);
                                plugSet = await Manifest.DestinyPlugSetDefinition.get(socketEntry.randomizedPlugSetHash);
                                for (const plugItem of plugSet?.reusablePlugItems ?? [])
                                    if (!cache[`/:${plugItem.plugItemHash}`])
                                        itemHashes.add(plugItem.plugItemHash);
                            }
                        }
                        return cacheKeyRange([...itemHashes]);
                    });
                    break;
                }
                case "DestinyInventoryItemLiteDefinition":
                    break;
                case "DestinyRecordDefinition":
                    Manifest[componentName].setPreCache(true, async (cache) => {
                        const values = Object.values(cache);
                        for await (const value of values) {
                            if (value?.displayProperties.icon)
                                cache[`icon:${value.displayProperties.icon}`] ??= value;
                            if (value?.displayProperties.name)
                                cache[`name:${value.displayProperties.name}`] ??= value;
                        }
                        ////////////////////////////////////
                        // precache by precached invitems
                        await Manifest.DestinyInventoryItemDefinition.loadCache();
                        await Manifest.DestinyCollectibleDefinition.loadCache();
                        const itemDefs = Object.values(Manifest.DestinyInventoryItemDefinition["memoryCache"]);
                        for await (const itemDef of itemDefs) {
                            if (!itemDef)
                                continue;
                            const collectible = await Manifest.DestinyCollectibleDefinition.get(itemDef.collectibleHash);
                            if (collectible?.displayProperties.icon)
                                cache[`icon:${collectible.displayProperties.icon}`] ??= null;
                            if (itemDef.displayProperties.name)
                                cache[`name:${itemDef.displayProperties.name}`] ??= null;
                        }
                    });
                    break;
                default:
                    this.setPreCache(true);
            }
        }
    }
});
define("utility/endpoint/clarity/endpoint/GetClarityDatabaseVersions", ["require", "exports", "utility/endpoint/clarity/ClarityEndpoint"], function (require, exports, ClarityEndpoint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new ClarityEndpoint_2.default("versions.json");
});
define("model/models/manifest/ClarityManifest", ["require", "exports", "model/Model", "model/models/manifest/DestinyManifest", "model/models/manifest/IManifest", "utility/endpoint/clarity/endpoint/GetClarityDatabase", "utility/endpoint/clarity/endpoint/GetClarityDatabaseVersions"], function (require, exports, Model_7, DestinyManifest_1, IManifest_3, GetClarityDatabase_1, GetClarityDatabaseVersions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClarityManifest = void 0;
    const ClarityManifest = Model_7.default.create("clarity database", {
        cache: "Global",
        version: async () => {
            const versions = await GetClarityDatabaseVersions_1.default.query();
            return `${Object.entries(versions)
                .filter((entry) => typeof entry[1] === "number")
                .map(([name, version]) => `${name}.${version}`)
                .sort()
                .join(",")}-3.deepsight.gg`;
        },
        async generate(api) {
            const clarityComponents = await GetClarityDatabase_1.default.query();
            const clarityComponentNames = Object.keys(clarityComponents);
            const cacheKeys = clarityComponentNames.map(IManifest_3.IManifest.CacheComponentKey.get);
            await Model_7.default.cacheDB.upgrade((database, transaction) => {
                for (const cacheKey of cacheKeys) {
                    if (database.objectStoreNames.contains(cacheKey))
                        database.deleteObjectStore(cacheKey);
                    database.createObjectStore(cacheKey);
                }
            });
            const totalLoad = clarityComponentNames.length;
            await Model_7.default.cacheDB.transaction(clarityComponentNames.map(IManifest_3.IManifest.CacheComponentKey.get), async (transaction) => {
                for (let i = 0; i < clarityComponentNames.length; i++) {
                    const componentName = clarityComponentNames[i];
                    const cacheKey = IManifest_3.IManifest.CacheComponentKey.get(componentName);
                    const startTime = performance.now();
                    console.info(`Caching objects from ${cacheKey}`);
                    api.emitProgress(i / totalLoad, "Storing manifest");
                    await transaction.clear(cacheKey);
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    for (const [itemId, itemValue] of Object.entries(clarityComponents[componentName])) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        await transaction.set(cacheKey, itemId, itemValue);
                    }
                    console.info(`Finished caching objects from ${cacheKey} after ${IManifest_3.IManifest.elapsed(performance.now() - startTime)}`);
                }
            });
            return clarityComponentNames;
        },
        process: async (componentNames) => {
            const Manifest = Object.fromEntries(componentNames
                .map(componentName => [componentName, new IManifest_3.ManifestItem(componentName, ClarityManifest)]));
            const { DestinyInventoryItemDefinition } = await DestinyManifest_1.default.await();
            await DestinyInventoryItemDefinition.loadCache();
            const itemHashes = await DestinyInventoryItemDefinition.primaryKeys();
            for (const componentName of componentNames) {
                Manifest[componentName].setPreCache(true, cache => {
                    if (componentName === "ClarityDescriptions") {
                        for (const hash of itemHashes) {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            cache[`/:${hash}`] ??= null;
                        }
                    }
                });
            }
            Object.assign(window, Manifest);
            return Manifest;
        },
        reset: async (componentNames) => {
            for (const componentName of componentNames ?? []) {
                await Model_7.default.cacheDB.clear(IManifest_3.IManifest.CacheComponentKey.get(componentName));
                await Model_7.default.cacheDB.delete("models", IManifest_3.IManifest.CacheComponentKey.getBundle(componentName));
            }
        },
        cacheInvalidated: async (componentNames) => {
            for (const componentName of componentNames ?? []) {
                await Model_7.default.cacheDB.delete("models", IManifest_3.IManifest.CacheComponentKey.getBundle(componentName));
            }
        },
    });
    exports.ClarityManifest = ClarityManifest;
});
define("model/models/Manifest", ["require", "exports", "model/Model", "model/models/manifest/ClarityManifest", "model/models/manifest/DeepsightManifest", "model/models/manifest/DestinyManifest", "utility/Time"], function (require, exports, Model_8, ClarityManifest_1, DeepsightManifest_2, DestinyManifest_2, Time_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Manifest = Model_8.default.createDynamic(Time_5.default.seconds(30), async (api) => {
        api.emitProgress(0, "Loading manifest");
        const destinyManifest = await api.subscribeProgressAndWait(DestinyManifest_2.default, 1 / 3);
        const deepsightManifest = await api.subscribeProgressAndWait(DeepsightManifest_2.DeepsightManifest, 1 / 3, 1 / 3);
        const clarityManifest = await api.subscribeProgressAndWait(ClarityManifest_1.ClarityManifest, 1 / 3, 2 / 3);
        api.setCacheTime(() => Math.max(DestinyManifest_2.default.getCacheTime(), DeepsightManifest_2.DeepsightManifest.getCacheTime(), ClarityManifest_1.ClarityManifest.getCacheTime()));
        return {
            ...destinyManifest,
            ...deepsightManifest,
            ...clarityManifest,
        };
    });
    exports.default = Manifest;
});
define("model/models/Activities", ["require", "exports", "model/models/Manifest", "model/models/ProfileBatch", "utility/Objects"], function (require, exports, Manifest_1, ProfileBatch_2, Objects_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Activities;
    (function (Activities_1) {
        async function await(profile) {
            profile ??= await ProfileBatch_2.default.await();
            const { DestinyActivityDefinition } = await Manifest_1.default.await();
            const characterActivities = (await Promise.all(Object.values(profile.characterActivities?.data ?? Objects_3.default.EMPTY)
                .flatMap(activities => activities.availableActivities)
                .map(async (activity) => DestinyActivityDefinition.get(activity.activityHash))))
                .filter((activity) => !!activity);
            const Activities = [];
            const activityHashes = new Set();
            for (const activity of characterActivities) {
                if (activityHashes.has(activity.hash))
                    continue;
                Activities.push(activity);
                activityHashes.add(activity.hash);
            }
            Object.assign(window, { Activities });
            return Activities;
        }
        Activities_1.await = await;
    })(Activities || (Activities = {}));
    exports.default = Activities;
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightStats", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_15.default("DeepsightStats.json");
});
define("model/models/DeepsightStats", ["require", "exports", "model/Model", "utility/endpoint/deepsight/endpoint/GetDeepsightStats"], function (require, exports, Model_9, GetDeepsightStats_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Model_9.default.createDynamic("Daily", () => GetDeepsightStats_1.default.query());
});
define("model/models/enum/AmmoTypes", ["require", "exports", "model/models/enum/EnumModel"], function (require, exports, EnumModel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const AmmoTypes = EnumModel_1.default.create('AmmoTypes', {
        // eslint-disable-next-line @typescript-eslint/require-await
        async generate() {
            const emptyDisplayProperties = {
                name: '',
                description: '',
                iconHash: 0,
                icon: '',
                iconSequences: [],
                highResIcon: '',
                hasIcon: false,
            };
            const types = [
                {
                    enumValue: 0 /* DestinyAmmunitionType.None */,
                    displayProperties: { ...emptyDisplayProperties },
                },
                {
                    enumValue: 4 /* DestinyAmmunitionType.Unknown */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Unknown' },
                },
                {
                    enumValue: 1 /* DestinyAmmunitionType.Primary */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Primary', icon: '/img/destiny_content/ammo_types/primary.png' },
                },
                {
                    enumValue: 2 /* DestinyAmmunitionType.Special */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Special', icon: '/img/destiny_content/ammo_types/special.png' },
                },
                {
                    enumValue: 3 /* DestinyAmmunitionType.Heavy */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Heavy', icon: '/img/destiny_content/ammo_types/heavy.png' },
                },
            ];
            return {
                array: types,
                primary: types.find(type => type.enumValue === 1 /* DestinyAmmunitionType.Primary */),
                special: types.find(type => type.enumValue === 2 /* DestinyAmmunitionType.Special */),
                heavy: types.find(type => type.enumValue === 3 /* DestinyAmmunitionType.Heavy */),
            };
        },
    });
    exports.default = AmmoTypes;
});
define("model/models/enum/ClassTypes", ["require", "exports", "model/models/enum/EnumModel", "model/models/Manifest"], function (require, exports, EnumModel_2, Manifest_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ClassTypes = EnumModel_2.default.create("ClassTypes", {
        async generate() {
            const { DestinyClassDefinition } = await Manifest_2.default.await();
            const types = (await DestinyClassDefinition.all())
                .map(type => ({ ...type, enumValue: type.classType }));
            const result = {
                array: types,
                titan: types.find(type => type.classType === 0 /* DestinyClass.Titan */),
                hunter: types.find(type => type.classType === 1 /* DestinyClass.Hunter */),
                warlock: types.find(type => type.classType === 2 /* DestinyClass.Warlock */),
            };
            result.titan.displayProperties.icon = "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/class_titan.svg";
            result.hunter.displayProperties.icon = "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/class_hunter.svg";
            result.warlock.displayProperties.icon = "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/class_warlock.svg";
            return result;
        },
    });
    exports.default = ClassTypes;
});
define("model/models/enum/DamageTypes", ["require", "exports", "model/models/enum/EnumModel", "model/models/Manifest"], function (require, exports, EnumModel_3, Manifest_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const DamageTypes = EnumModel_3.default.create("DamageTypes", {
        async generate() {
            const { DestinyDamageTypeDefinition } = await Manifest_3.default.await();
            const types = await DestinyDamageTypeDefinition.all();
            return {
                array: types,
                none: types.find(type => type.enumValue === 0 /* DamageType.None */),
                kinetic: types.find(type => type.enumValue === 1 /* DamageType.Kinetic */),
                void: types.find(type => type.enumValue === 4 /* DamageType.Void */),
                solar: types.find(type => type.enumValue === 3 /* DamageType.Thermal */),
                arc: types.find(type => type.enumValue === 2 /* DamageType.Arc */),
                stasis: types.find(type => type.enumValue === 6 /* DamageType.Stasis */),
                strand: types.find(type => type.enumValue === 7 /* DamageType.Strand */),
                raid: types.find(type => type.enumValue === 5 /* DamageType.Raid */),
            };
        },
    });
    exports.default = DamageTypes;
});
define("model/models/enum/EnumModelMap", ["require", "exports", "model/models/enum/AmmoTypes", "model/models/enum/BreakerTypes", "model/models/enum/ClassTypes", "model/models/enum/DamageTypes"], function (require, exports, AmmoTypes_1, BreakerTypes_1, ClassTypes_1, DamageTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const EnumModelMap = {
        kinetic: [DamageTypes_1.default, 1 /* DamageType.Kinetic */],
        arc: [DamageTypes_1.default, 2 /* DamageType.Arc */],
        void: [DamageTypes_1.default, 4 /* DamageType.Void */],
        solar: [DamageTypes_1.default, 3 /* DamageType.Thermal */],
        stasis: [DamageTypes_1.default, 6 /* DamageType.Stasis */],
        strand: [DamageTypes_1.default, 7 /* DamageType.Strand */],
        primary: [AmmoTypes_1.default, 1 /* DestinyAmmunitionType.Primary */],
        special: [AmmoTypes_1.default, 2 /* DestinyAmmunitionType.Special */],
        heavy: [AmmoTypes_1.default, 3 /* DestinyAmmunitionType.Heavy */],
        titan: [ClassTypes_1.default, 0 /* DestinyClass.Titan */],
        hunter: [ClassTypes_1.default, 1 /* DestinyClass.Hunter */],
        warlock: [ClassTypes_1.default, 2 /* DestinyClass.Warlock */],
        barrier: [BreakerTypes_1.default, 1 /* DestinyBreakerType.ShieldPiercing */],
        "shield-piercing": [BreakerTypes_1.default, 1 /* DestinyBreakerType.ShieldPiercing */],
        overload: [BreakerTypes_1.default, 2 /* DestinyBreakerType.Disruption */],
        disruption: [BreakerTypes_1.default, 2 /* DestinyBreakerType.Disruption */],
        unstoppable: [BreakerTypes_1.default, 3 /* DestinyBreakerType.Stagger */],
        stagger: [BreakerTypes_1.default, 3 /* DestinyBreakerType.Stagger */],
    };
    exports.default = EnumModelMap;
});
define("ui/utility/Classes", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventoryClasses = exports.Classes = void 0;
    var Classes;
    (function (Classes) {
        Classes["Logo"] = "logo";
        Classes["Active"] = "active";
        Classes["Hidden"] = "hidden";
        Classes["Disabled"] = "disabled";
        Classes["WarningText"] = "warning-text";
        Classes["SmallText"] = "small-text";
        Classes["ShowIfAPIDown"] = "show-if-api-down";
        Classes["ShowIfExtraInfo"] = "show-if-extra-info";
        Classes["ShowIfNotExtraInfo"] = "show-if-not-extra-info";
    })(Classes || (exports.Classes = Classes = {}));
    var InventoryClasses;
    (function (InventoryClasses) {
        InventoryClasses["Item"] = "item";
    })(InventoryClasses || (exports.InventoryClasses = InventoryClasses = {}));
});
define("ui/utility/DimensionalCache", ["require", "exports", "utility/decorator/Bound"], function (require, exports, Bound_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DimensionalCache {
        static get(element) {
            let cache = DimensionalCache.map.get(element);
            if (!cache) {
                cache = new DimensionalCache(element);
                DimensionalCache.map.set(element, cache);
            }
            return cache;
        }
        constructor(element) {
            this.cleanupInterval = window.setInterval(this.tryCleanup, 1000);
            this.element = new WeakRef(element);
            window.addEventListener("resize", this.reset);
        }
        tryCleanup() {
            if (this.element.deref())
                return;
            window.removeEventListener("resize", this.reset);
            window.clearInterval(this.cleanupInterval);
        }
        reset() {
            this.tryCleanup();
            delete this._width;
            delete this._height;
            delete this._top;
            delete this._left;
            delete this._bottom;
            delete this._right;
            delete this._scrollWidth;
            delete this._scrollHeight;
            delete this._scrollTop;
            delete this._scrollLeft;
            delete this._scrollBottom;
            delete this._scrollRight;
        }
        get width() {
            return this._width ??= this.element.deref()?.clientWidth ?? 0;
        }
        get height() {
            return this._height ??= this.element.deref()?.clientHeight ?? 0;
        }
        get top() {
            return this._top ??= this.element.deref()?.clientTop ?? 0;
        }
        get left() {
            return this._left ??= this.element.deref()?.clientLeft ?? 0;
        }
        get bottom() {
            return this._bottom ??= this.top + this.height;
        }
        get right() {
            return this._right ??= this.left + this.width;
        }
        get scrollWidth() {
            return this._scrollWidth ??= this.element.deref()?.scrollWidth ?? 0;
        }
        get scrollHeight() {
            return this._scrollHeight ??= this.element.deref()?.scrollHeight ?? 0;
        }
        get scrollTop() {
            return this._scrollTop ??= this.element.deref()?.scrollTop ?? 0;
        }
        get scrollLeft() {
            return this._scrollLeft ??= this.element.deref()?.scrollLeft ?? 0;
        }
        get scrollBottom() {
            return this._scrollBottom ??= this.scrollTop + this.height;
        }
        get scrollRight() {
            return this._scrollRight ??= this.scrollLeft + this.width;
        }
    }
    DimensionalCache.map = new WeakMap();
    exports.default = DimensionalCache;
    __decorate([
        Bound_2.default
    ], DimensionalCache.prototype, "tryCleanup", null);
    __decorate([
        Bound_2.default
    ], DimensionalCache.prototype, "reset", null);
});
define("utility/Async", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Async;
    (function (Async) {
        async function sleep(ms, signal) {
            // let stack = new Error().stack;
            // stack = stack?.slice(stack.indexOf("\n") + 1);
            // stack = stack?.slice(stack.indexOf("\n") + 1);
            // stack = stack?.slice(0, stack.indexOf("\n"));
            // console.log("sleep", stack);
            if (!signal) {
                return new Promise(resolve => {
                    window.setTimeout(() => resolve(undefined), ms);
                });
            }
            if (signal.aborted) {
                return true;
            }
            return new Promise(resolve => {
                // eslint-disable-next-line prefer-const
                let timeoutId;
                const onAbort = () => {
                    window.clearTimeout(timeoutId);
                    resolve(true);
                };
                timeoutId = window.setTimeout(() => {
                    signal.removeEventListener("abort", onAbort);
                    resolve(false);
                }, ms);
                signal.addEventListener("abort", onAbort, { once: true });
            });
        }
        Async.sleep = sleep;
        function debounce(...args) {
            let ms;
            let callback;
            if (typeof args[0] === "function") {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                [callback, ...args] = args;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                return debounceByPromise(callback, ...args);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                [ms, callback, ...args] = args;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                return debounceByTime(ms, callback, ...args);
            }
        }
        Async.debounce = debounce;
        const debouncedByTime = new WeakMap();
        function debounceByTime(ms, callback, ...args) {
            let info = debouncedByTime.get(callback);
            if (info && Date.now() - info.last < ms) {
                const newAbortController = new AbortController();
                info.queued = sleep(Date.now() - info.last + ms, newAbortController.signal).then(aborted => {
                    if (aborted) {
                        return info?.queued;
                    }
                    delete info.queued;
                    delete info.abortController;
                    info.last = Date.now();
                    return callback(...args);
                });
                info.abortController?.abort();
                info.abortController = newAbortController;
                return info.queued;
            }
            if (!info) {
                debouncedByTime.set(callback, info = { last: 0 });
            }
            info.last = Date.now();
            return callback(...args);
        }
        const debouncedByPromise = new WeakMap();
        function debounceByPromise(callback, ...args) {
            const debounceInfo = debouncedByPromise.get(callback);
            if (debounceInfo?.nextQueued) {
                return debounceInfo.promise;
            }
            const realCallback = () => {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    const result = callback(...args);
                    const promise = Promise.resolve(result);
                    debouncedByPromise.set(callback, {
                        promise,
                        nextQueued: false,
                    });
                    promise.catch(reason => {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection", { promise, reason }));
                    });
                    return promise;
                }
                catch (error) {
                    window.dispatchEvent(new ErrorEvent("error", { error }));
                    return;
                }
            };
            if (debounceInfo) {
                debounceInfo.nextQueued = true;
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                return debounceInfo.promise.catch(realCallback).then(realCallback);
            }
            else {
                return realCallback();
            }
        }
        function schedule(...args) {
            let ms = 0;
            let callback;
            let debounceMs = false;
            let signal;
            if (typeof args[0] === "function") {
                // (cb, ...args)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                [callback, ...args] = args;
            }
            else if (typeof args[1] === "function") {
                // (ms, cb, ...args)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                [ms, callback, ...args] = args;
            }
            else if (typeof args[2] === "function") {
                // (ms, debounce | signal, cb, ...args)
                if (typeof args[1] === "object") {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    [ms, signal, callback, ...args] = args;
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    [ms, debounceMs, callback, ...args] = args;
                }
            }
            else {
                // (ms, debounce, signal, cb, ...args)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                [ms, debounceMs, signal, callback, ...args] = args;
            }
            if (debounceMs === true) {
                debounceMs = ms;
            }
            const cancelCallbacks = [];
            // eslint-disable-next-line prefer-const
            let timeoutId;
            const result = {
                cancelled: false,
                completed: false,
                cancel: () => {
                    if (result.cancelled || result.completed) {
                        return;
                    }
                    signal?.removeEventListener("abort", result.cancel);
                    result.cancelled = true;
                    window.clearTimeout(timeoutId);
                    for (const callback of cancelCallbacks) {
                        try {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument
                            const result = callback(...args);
                            const promise = Promise.resolve(result);
                            promise.catch(reason => {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection", { promise, reason }));
                            });
                        }
                        catch (error) {
                            window.dispatchEvent(new ErrorEvent("error", { error }));
                        }
                    }
                    cancelCallbacks.length = 0;
                    args.length = 0;
                },
                onCancel: callback => {
                    if (result.completed) {
                        return result;
                    }
                    if (result.cancelled) {
                        try {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument
                            const result = callback(...args);
                            const promise = Promise.resolve(result);
                            promise.catch(reason => {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection", { promise, reason }));
                            });
                        }
                        catch (error) {
                            window.dispatchEvent(new ErrorEvent("error", { error }));
                        }
                    }
                    else {
                        cancelCallbacks.push(callback);
                    }
                    return result;
                },
            };
            signal?.addEventListener("abort", result.cancel, { once: true });
            timeoutId = window.setTimeout(() => {
                if (result.cancelled) {
                    return;
                }
                signal?.removeEventListener("abort", result.cancel);
                result.completed = true;
                cancelCallbacks.length = 0;
                try {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument
                    const result = debounceMs ? debounce(debounceMs, callback, ...args) : callback(...args);
                    const promise = Promise.resolve(result);
                    promise.catch(reason => {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection", { promise, reason }));
                    });
                }
                catch (error) {
                    window.dispatchEvent(new ErrorEvent("error", { error }));
                }
            }, ms);
            return result;
        }
        Async.schedule = schedule;
        /**
         * Create an AbortSignal that will be emitted after `ms`.
         * @param ms The time until the signal will be emitted.
         * @param controller An optional existing `AbortController`.
         * @param message An optional custom timeout message.
         */
        function timeout(ms, controller = new AbortController(), message = `Timed out after ${ms} ms`) {
            schedule(ms, () => controller.abort(message));
            return controller.signal;
        }
        Async.timeout = timeout;
    })(Async || (Async = {}));
    exports.default = Async;
});
define("ui/utility/TooltipManager", ["require", "exports", "ui/component/Component", "ui/utility/Classes", "ui/utility/DimensionalCache", "utility/Async"], function (require, exports, Component_1, Classes_1, DimensionalCache_1, Async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tooltip = exports.TooltipWrapper = exports.TooltipClasses = void 0;
    var TooltipClasses;
    (function (TooltipClasses) {
        TooltipClasses["Storage"] = "tooltip-storage";
        TooltipClasses["Surface"] = "tooltip-surface";
        TooltipClasses["Reversed"] = "tooltip-reversed";
        TooltipClasses["_ScrollableEnabled"] = "tooltip--scrollable-enabled";
        TooltipClasses["Main"] = "tooltip";
        TooltipClasses["Wrapper"] = "tooltip-wrapper";
        TooltipClasses["Extra"] = "tooltip-extra";
        TooltipClasses["Header"] = "tooltip-header";
        TooltipClasses["Title"] = "tooltip-title";
        TooltipClasses["Subtitle"] = "tooltip-subtitle";
        TooltipClasses["Rarity"] = "tooltip-tier";
        TooltipClasses["Content"] = "tooltip-content";
        TooltipClasses["Footer"] = "tooltip-footer";
        TooltipClasses["Hints"] = "tooltip-hints";
        TooltipClasses["Forced1pxBigger"] = "tooltip-forced-1px-bigger";
        TooltipClasses["Scrollable"] = "tooltip-scrollable";
        TooltipClasses["Scrollable_Enabled"] = "tooltip-scrollable--enabled";
    })(TooltipClasses || (exports.TooltipClasses = TooltipClasses = {}));
    class TooltipWrapper extends Component_1.default {
        onMake(tooltip) {
            this.classes.add(TooltipClasses.Wrapper);
            this.tooltip = tooltip.appendTo(this);
        }
    }
    exports.TooltipWrapper = TooltipWrapper;
    class Tooltip extends Component_1.default {
        get extra() {
            return this._extra ??= Tooltip.create()
                .classes.add(TooltipClasses.Extra)
                .appendTo(this.wrapper);
        }
        get hints() {
            return this._hints ??= Component_1.default.create()
                .classes.add(TooltipClasses.Hints)
                .appendTo(this.footer);
        }
        onMake() {
            this.classes.add(TooltipClasses.Main);
            this.wrapper = TooltipWrapper.create([this]);
            this.header = Component_1.default.create("header")
                .classes.add(TooltipClasses.Header)
                .appendTo(this);
            this.title = Component_1.default.create("h2")
                .classes.add(TooltipClasses.Title)
                .appendTo(this.header);
            this.subtitle = Component_1.default.create()
                .classes.add(TooltipClasses.Subtitle)
                .appendTo(this.header);
            this.rarity = Component_1.default.create()
                .classes.add(TooltipClasses.Rarity)
                .appendTo(this.header);
            this.content = Component_1.default.create()
                .classes.add(TooltipClasses.Content)
                .appendTo(this);
            this.footer = Component_1.default.create("footer")
                .classes.add(TooltipClasses.Footer)
                .appendTo(this);
        }
        setPadding(padding) {
            this.style.set("--mouse-offset", `${padding}px`);
            return this;
        }
        setScrollableComponent(component) {
            this.scrollableComponent = component;
            return this;
        }
    }
    exports.Tooltip = Tooltip;
    var TooltipManager;
    (function (TooltipManager) {
        const tooltipStorage = Component_1.default.create()
            .classes.add(TooltipClasses.Storage)
            .appendTo(document.body);
        const tooltipSurface = Component_1.default.create()
            .classes.add(TooltipClasses.Surface)
            .appendTo(document.body);
        const surfaceCache = DimensionalCache_1.default.get(tooltipSurface.element);
        let tooltipsEnabled = window.innerWidth > 800;
        function create(initialiser) {
            let tooltip;
            return {
                get() {
                    if (tooltip)
                        return tooltip;
                    tooltip = initialiser(Tooltip.create());
                    tooltip.wrapper.appendTo(tooltipStorage);
                    return tooltip;
                },
                createRaw: () => initialiser(Tooltip.create()),
            };
        }
        TooltipManager.create = create;
        function show(tooltipClass, initialiser, hidePreviousIfSame = true) {
            const tooltip = tooltipClass.get();
            hideTooltips(hidePreviousIfSame ? undefined : tooltip);
            if (!tooltipsEnabled)
                return;
            tooltip.classes.remove(TooltipClasses.Forced1pxBigger);
            void Promise.resolve(initialiser(tooltip))
                .then(async () => {
                await Async_1.default.sleep(1);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (window.chrome) {
                    if (tooltip.element.clientHeight % 2 !== Component_1.default.window.height % 2)
                        tooltip.classes.add(TooltipClasses.Forced1pxBigger);
                }
                const scrollable = tooltip?.["scrollableComponent"]?.element;
                if (!scrollable)
                    return;
                scrollable.classList.add(TooltipClasses.Scrollable);
                scrollable.classList.toggle(TooltipClasses.Scrollable_Enabled, scrollable.scrollHeight > scrollable.clientHeight);
                tooltip.classes.toggle(scrollable.scrollHeight > scrollable.clientHeight, TooltipClasses._ScrollableEnabled);
                await Async_1.default.sleep(1);
                const cache = DimensionalCache_1.default.get(scrollable);
                cache.reset();
            });
            tooltip.wrapper
                .classes.remove(Classes_1.Classes.Hidden)
                .appendTo(tooltipSurface);
        }
        TooltipManager.show = show;
        function hideTooltips(current) {
            for (const child of tooltipSurface.element.children) {
                const childComponent = child.component?.deref();
                if (!childComponent) {
                    console.warn("Not a valid tooltip", child);
                    child.remove();
                    continue;
                }
                if (childComponent !== current)
                    hide(childComponent.tooltip);
            }
        }
        function hide(tooltip) {
            if (tooltip.wrapper.classes.has(Classes_1.Classes.Hidden))
                // already hiding
                return;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            const hideLock = tooltip.TOOLTIP_HIDE_LOCK = Math.random();
            const persistTooltips = document.documentElement.classList.contains("persist-tooltips");
            if (!persistTooltips)
                tooltip.wrapper.classes.add(Classes_1.Classes.Hidden);
            void Async_1.default.sleep(500).then(() => {
                if (!tooltip.wrapper.classes.has(Classes_1.Classes.Hidden))
                    // tooltip has been shown again, don't touch
                    return;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (tooltip.TOOLTIP_HIDE_LOCK !== hideLock)
                    // a different call of this method is responsible for hiding the tooltip now
                    return;
                if (!persistTooltips)
                    tooltip.wrapper.appendTo(tooltipStorage);
            });
        }
        TooltipManager.hide = hide;
        Component_1.default.event.subscribe("setTooltip", ({ component, tooltip: tooltipClass, handler }) => {
            const tooltip = tooltipClass.get();
            component.event.until("clearTooltip", event => event
                .subscribe("mouseover", () => {
                if (tooltip.owner?.deref() === component)
                    return; // this tooltip is already shown
                tooltip.owner = new WeakRef(component);
                TooltipManager.show(tooltipClass, handler.initialise, handler.differs?.(tooltip));
            })
                .subscribe("mouseout", event => {
                if (component.element.contains(document.elementFromPoint(event.clientX, event.clientY)))
                    return;
                hideTooltip();
            }));
            void component.event.waitFor("clearTooltip")
                .then(hideTooltip);
            function hideTooltip() {
                if (tooltip.owner?.deref() === component) {
                    delete tooltip.owner;
                    TooltipManager.hide(tooltip);
                }
            }
        });
        let reversed;
        document.body.addEventListener("mousemove", event => {
            const switchTooltipAt = (800 / 1920) * Component_1.default.window.width;
            const switchTooltipDirection = reversed && event.clientX < switchTooltipAt
                || !reversed && event.clientX > Component_1.default.window.width - switchTooltipAt;
            if (switchTooltipDirection && [...tooltipSurface.element.children].some(tooltip => !tooltip.classList.contains(Classes_1.Classes.Hidden))) {
                tooltipSurface.classes.toggle(TooltipClasses.Reversed);
                reversed = !reversed;
            }
            tooltipSurface.element.scrollLeft = surfaceCache.scrollWidth - Component_1.default.window.width - event.clientX;
            tooltipSurface.element.scrollTop = surfaceCache.scrollHeight - Component_1.default.window.height - Component_1.default.window.height / 2 - event.clientY;
        });
        document.body.addEventListener("wheel", event => {
            const [child] = tooltipSurface.element.children;
            if (!child)
                return;
            const childComponent = child.component?.deref();
            if (!childComponent) {
                console.warn("Not a valid tooltip", child);
                child.remove();
                return;
            }
            const tooltip = childComponent.tooltip;
            const scrollable = tooltip?.["scrollableComponent"]?.element;
            if (!scrollable)
                return;
            const cache = DimensionalCache_1.default.get(scrollable);
            if (cache.scrollHeight < cache.height)
                return;
            if (event.deltaY > 0 && cache.height + scrollable.scrollTop >= cache.scrollHeight)
                return;
            if (event.deltaY < 0 && scrollable.scrollTop <= 0)
                return;
            event.preventDefault();
            if (tooltip["scrollTop"] === undefined || Math.sign(event.deltaY) !== Math.sign(tooltip["scrollTop"] - scrollable.scrollTop))
                tooltip["scrollTop"] = scrollable.scrollTop;
            tooltip["scrollTop"] += event.deltaY;
            if (tooltip["scrollTop"] + cache.height > cache.scrollHeight)
                tooltip["scrollTop"] = cache.scrollHeight - cache.height;
            if (tooltip["scrollTop"] < 0)
                tooltip["scrollTop"] = 0;
            scrollable.scrollTop = tooltip["scrollTop"];
        });
        window.addEventListener("resize", () => {
            tooltipsEnabled = Component_1.default.window.width > 800;
            hideTooltips();
        });
    })(TooltipManager || (TooltipManager = {}));
    exports.default = TooltipManager;
});
define("utility/maths/Vector2", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IVector2 = void 0;
    var IVector2;
    (function (IVector2) {
        function ZERO() {
            return { x: 0, y: 0 };
        }
        IVector2.ZERO = ZERO;
        function distance(v1, v2) {
            return Math.sqrt((v2.x - v1.x) ** 2 + (v2.y - v1.y) ** 2);
        }
        IVector2.distance = distance;
        function distanceWithin(v1, v2, within) {
            return (v2.x - v1.x) ** 2 + (v2.y - v1.y) ** 2 < within ** 2;
        }
        IVector2.distanceWithin = distanceWithin;
    })(IVector2 || (exports.IVector2 = IVector2 = {}));
});
define("ui/component/Component", ["require", "exports", "utility/EventManager", "utility/decorator/Bound"], function (require, exports, EventManager_9, Bound_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComponentDeclaration = exports.TextManager = exports.StyleManager = exports.AttributeManager = exports.ClassManager = void 0;
    const SVG_ELEMENTS = new Set([
        "svg",
        "g",
        "path",
        "circle",
        "line",
    ]);
    class ComponentWindow {
        constructor() {
            this.event = new EventManager_9.EventManager(this, window);
            this._width = 0;
            this._height = 0;
            this.recalculateDimensions();
            window.addEventListener("resize", this.recalculateDimensions);
        }
        recalculateDimensions() {
            this._width = window.innerWidth;
            this._height = window.innerHeight;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
    }
    __decorate([
        Bound_3.default
    ], ComponentWindow.prototype, "recalculateDimensions", null);
    class Component {
        static create(type, args) {
            if (typeof type === "object") {
                args = type;
                type = undefined;
            }
            type ??= this.defaultType;
            const element = SVG_ELEMENTS.has(type) ? document.createElementNS("http://www.w3.org/2000/svg", type)
                : document.createElement(type);
            const component = new Component(element);
            if (this !== Component)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                component.make(this, ...args ?? []);
            return component;
        }
        static get(element) {
            if (!element)
                return undefined;
            let component = element.component?.deref();
            if (component)
                return component;
            component = new Component(element);
            if (this !== Component)
                component.make(this);
            return component;
        }
        static byClassName(className) {
            return [...document.getElementsByClassName(className)]
                .map(element => element.component?.deref())
                .filter((component) => !!component);
        }
        static makeable() {
            return {
                of(cls) {
                    var _a;
                    const result = (_a = class extends cls {
                        },
                        __setFunctionName(_a, "result"),
                        _a.addSuper = true,
                        _a);
                    return result;
                },
            };
        }
        get classes() {
            const classes = new ClassManager(this);
            Object.defineProperty(this, "classes", {
                value: classes,
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return classes;
        }
        get attributes() {
            const attributes = new AttributeManager(this);
            Object.defineProperty(this, "attributes", {
                value: attributes,
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return attributes;
        }
        get data() {
            const data = new AttributeManager(this, "data");
            Object.defineProperty(this, "data", {
                value: data,
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return data;
        }
        get style() {
            const style = new StyleManager(this);
            Object.defineProperty(this, "style", {
                value: style,
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return style;
        }
        get text() {
            const text = new TextManager(this);
            Object.defineProperty(this, "text", {
                value: text,
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return text;
        }
        constructor(element) {
            this.element = element;
            if (this.constructor !== Component)
                throw new Error("Custom components may not provide a constructor. Use onMake");
            element.component = new WeakRef(this);
            Object.defineProperty(this, "event", {
                configurable: true,
                get: () => {
                    const event = new EventManager_9.EventManager(this, new WeakRef(this.element));
                    Object.defineProperty(this, "event", {
                        value: event,
                    });
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return event;
                },
            });
        }
        as(cls) {
            return this instanceof cls ? this : undefined;
        }
        asType() {
            return this;
        }
        make(cls, ...args) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            Object.setPrototypeOf(this, cls.prototype);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (cls.addSuper)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                this.super = this;
            this.onMake(...args);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return this;
        }
        tweak(tweaker, ...args) {
            tweaker?.(this, ...args);
            return this;
        }
        onMake(...args) { }
        parent(selector) {
            if (selector && !this.element.parentElement?.matches(selector))
                return undefined;
            return Component.get(this.element.parentElement ?? undefined);
        }
        hasContents() {
            return this.element.childNodes.length > 0;
        }
        *children() {
            for (const child of this.element.children)
                yield Component.get(child);
        }
        append(...elements) {
            this.element.append(...elements.map(element => element instanceof Component ? element.element : element)
                .filter((element) => element !== undefined));
            return this;
        }
        prepend(...elements) {
            this.element.prepend(...elements.map(element => element instanceof Component ? element.element : element)
                .filter((element) => element !== undefined));
            return this;
        }
        appendTo(componentOrParentNode) {
            if (componentOrParentNode instanceof Component)
                componentOrParentNode = componentOrParentNode.element;
            if (componentOrParentNode)
                componentOrParentNode.appendChild(this.element);
            else
                this.element.remove();
            return this;
        }
        prependTo(componentOrParentNode) {
            if (componentOrParentNode instanceof Component)
                componentOrParentNode = componentOrParentNode.element;
            if (componentOrParentNode)
                componentOrParentNode.insertBefore(this.element, componentOrParentNode.firstChild);
            else
                this.element.remove();
            return this;
        }
        insertToBefore(componentOrParentNode, pivot) {
            if (componentOrParentNode instanceof Component)
                componentOrParentNode = componentOrParentNode.element;
            if (pivot instanceof Component)
                pivot = pivot.element;
            if (componentOrParentNode && (!pivot || pivot.parentElement === componentOrParentNode))
                componentOrParentNode.insertBefore(this.element, pivot);
            else
                this.element.remove();
            return this;
        }
        insertToAfter(componentOrParentNode, pivot) {
            if (componentOrParentNode instanceof Component)
                componentOrParentNode = componentOrParentNode.element;
            if (pivot instanceof Component)
                pivot = pivot.element;
            if (componentOrParentNode && (!pivot || pivot.parentElement === componentOrParentNode))
                componentOrParentNode.insertBefore(this.element, pivot?.nextSibling);
            else
                this.element.remove();
            return this;
        }
        indexInto(componentOrParentNode, index) {
            this.data.set("index", `${index}`);
            if (componentOrParentNode instanceof Component)
                componentOrParentNode = componentOrParentNode.element;
            const children = componentOrParentNode.children;
            let low = 0;
            let high = children.length - 1;
            while (low <= high) {
                const mid = Math.floor((low + high) / 2);
                const indexString = children[mid].dataset.index;
                if (!indexString)
                    console.error("Unindexed element", children[mid], "in parent node", componentOrParentNode);
                const childIndex = +(indexString ?? 0);
                if (childIndex === index) {
                    low = mid;
                    break;
                }
                if (childIndex < index)
                    low = mid + 1;
                else
                    high = mid - 1;
            }
            if (low < children.length)
                componentOrParentNode.insertBefore(this.element, children[low]);
            else
                componentOrParentNode.appendChild(this.element);
            return this;
        }
        remove() {
            this.element.remove();
        }
        removeContents(filter) {
            while (this.element.lastChild)
                if (!filter || filter(this.element.lastChild))
                    this.element.lastChild.remove();
            return this;
        }
        setTooltip(tooltip, handler) {
            Component.event.emit("setTooltip", { component: this, tooltip, handler });
            return this;
        }
        clearTooltip() {
            this.event.emit("clearTooltip");
            return this;
        }
        exists() {
            return document.contains(this.element);
        }
        index() {
            const siblings = this.parent()?.element.children ?? [];
            for (let i = 0; i < siblings.length; i++)
                if (siblings[i] === this.element)
                    return i;
            return -1;
        }
        contains(...nodes) {
            for (let node of nodes) {
                if (!node)
                    return false;
                if (node instanceof Component)
                    node = node.element;
                if (!this.element.contains(node))
                    return false;
            }
            return true;
        }
        getRect(uncache = false) {
            if (uncache)
                delete this.rect;
            return this.rect ??= this.element.getBoundingClientRect();
        }
        uncacheRect() {
            delete this.rect;
        }
        intersects(position, uncache = false) {
            const rect = this.getRect(uncache);
            if (position.x < rect.left || position.x >= rect.left + rect.width)
                return false;
            if (position.y < rect.top || position.y >= rect.top + rect.height)
                return false;
            return true;
        }
        isFocused() {
            return document.activeElement === this.element;
        }
        focus() {
            this.element.focus();
        }
        blur() {
            this.element.blur();
        }
    }
    exports.ComponentDeclaration = Component;
    Component.window = new ComponentWindow();
    Component.event = EventManager_9.EventManager.make();
    Component.defaultType = "div";
    exports.default = Component;
    class ClassManager {
        constructor(host) {
            this.host = new WeakRef(host);
        }
        all() {
            const host = this.host.deref();
            return [...host?.element.classList ?? []];
        }
        add(...classes) {
            const host = this.host.deref();
            host?.element.classList.add(...classes.filter(Boolean));
            return host;
        }
        remove(...classes) {
            const host = this.host.deref();
            host?.element.classList.remove(...classes.filter(Boolean));
            return host;
        }
        removeWhere(filter) {
            const host = this.host.deref();
            host?.element.classList.remove(...[...host.element.classList].filter(filter));
            return host;
        }
        toggle(present, ...classes) {
            const host = this.host.deref();
            const element = host?.element;
            if (element) {
                if (typeof present === "string") {
                    classes.unshift(present);
                    for (const cls of classes)
                        if (cls)
                            element.classList.toggle(cls);
                }
                else if (present)
                    element.classList.add(...classes.filter(Boolean));
                else
                    element.classList.remove(...classes.filter(Boolean));
            }
            return host;
        }
        has(...classes) {
            const host = this.host.deref();
            return classes.every(cls => host?.element.classList.contains(cls));
        }
        some(...classes) {
            const host = this.host.deref();
            return classes.some(cls => host?.element.classList.contains(cls));
        }
        until(promise, consumer) {
            const addedClasses = new Set();
            const removedClasses = new Set();
            void promise.then(() => {
                const element = this.host.deref()?.element;
                element?.classList.add(...removedClasses);
                element?.classList.remove(...addedClasses);
            });
            const manipulator = {
                add: (...classes) => {
                    const host = this.host.deref();
                    host?.element?.classList.add(...classes);
                    for (const cls of classes)
                        addedClasses.add(cls);
                    return host;
                },
                remove: (...classes) => {
                    const host = this.host.deref();
                    host?.element?.classList.remove(...classes);
                    for (const cls of classes)
                        removedClasses.add(cls);
                    return host;
                },
            };
            consumer?.(manipulator);
            return consumer ? this.host.deref() : manipulator;
        }
    }
    exports.ClassManager = ClassManager;
    class AttributeManager {
        constructor(host, prefix) {
            this.prefix = prefix ? `${prefix}-` : "";
            this.host = new WeakRef(host);
        }
        get(name) {
            return this.host.deref()?.element.getAttribute(`${this.prefix}${name}`);
        }
        add(name) {
            const host = this.host.deref();
            host?.element.setAttribute(`${this.prefix}${name}`, "");
            return host;
        }
        toggle(present, name, value = "") {
            const host = this.host.deref();
            if (present)
                host?.element.setAttribute(`${this.prefix}${name}`, value);
            else
                host?.element.removeAttribute(`${this.prefix}${name}`);
            return host;
        }
        set(name, value) {
            const host = this.host.deref();
            if (value === undefined)
                host?.element.removeAttribute(`${this.prefix}${name}`);
            else
                host?.element.setAttribute(`${this.prefix}${name}`, value);
            return host;
        }
        remove(name) {
            const host = this.host.deref();
            host?.element.removeAttribute(`${this.prefix}${name}`);
            return host;
        }
    }
    exports.AttributeManager = AttributeManager;
    class StyleManager {
        constructor(host) {
            this.host = new WeakRef(host);
        }
        // public get (name: string) {
        // 	return this.host.deref()?.element.style.getPropertyValue(name);
        // }
        set(name, value) {
            const host = this.host.deref();
            if (value === undefined)
                return this.remove(name);
            else
                host?.element.style.setProperty(name, value);
            return host;
        }
        remove(name) {
            const host = this.host.deref();
            host?.element.style.removeProperty(name);
            return host;
        }
    }
    exports.StyleManager = StyleManager;
    class TextManager {
        constructor(host) {
            this.host = new WeakRef(host);
        }
        get() {
            return this.host.deref()?.element.textContent;
        }
        set(text) {
            const host = this.host.deref();
            if (host) {
                this.remove();
                if (text !== undefined)
                    host.element.append(...this.createTextElements(text));
            }
            return host;
        }
        add(text) {
            const host = this.host.deref();
            if (host)
                host.element.append(...this.createTextElements(text));
            return host;
        }
        remove() {
            const host = this.host.deref();
            if (host)
                for (const child of [...host.element.childNodes])
                    if (child.nodeType === Node.TEXT_NODE || (child.nodeType === Node.ELEMENT_NODE && child.classList?.contains("text")))
                        child.remove();
            return host;
        }
        createTextElements(text) {
            const formatting = {
                italic: false,
                bold: false,
                underline: false,
                strikethrough: false,
            };
            const result = [];
            let segment = "";
            for (let i = 0; i < text.length; i++) {
                if (text[i] !== "[" || (text[i + 2] !== "]" && (text[i + 1] !== "/" || text[i + 3] !== "]"))) {
                    segment += text[i];
                    continue;
                }
                // changing formatting
                if (segment.length) {
                    result.push(this.wrapText(segment, formatting));
                }
                switch (text[i + 1]) {
                    case "b":
                        formatting.bold = true;
                        break;
                    case "i":
                        formatting.italic = true;
                        break;
                    case "u":
                        formatting.underline = true;
                        break;
                    case "s":
                        formatting.strikethrough = true;
                        break;
                    case "/":
                        switch (text[i + 2]) {
                            case "b":
                                formatting.bold = false;
                                break;
                            case "i":
                                formatting.italic = false;
                                break;
                            case "u":
                                formatting.underline = false;
                                break;
                            case "s":
                                formatting.strikethrough = false;
                                break;
                        }
                        i += 1;
                        break;
                    default:
                        segment += text[i];
                        continue;
                }
                i += 2;
                segment = "";
            }
            const finalSegment = this.wrapText(segment, formatting);
            if (!result.length && finalSegment.tagName === "SPAN")
                return [document.createTextNode(segment)];
            result.push(finalSegment);
            return result;
        }
        wrapText(text, { bold, italic, underline, strikethrough }) {
            let textWrapper;
            if (!bold && !italic && !underline && !strikethrough) {
                textWrapper = document.createElement("span");
                textWrapper.classList.add("text");
            }
            else {
                const formatting = [];
                if (bold)
                    formatting.push(document.createElement("b"));
                if (italic)
                    formatting.push(document.createElement("i"));
                if (underline)
                    formatting.push(document.createElement("u"));
                if (strikethrough)
                    formatting.push(document.createElement("s"));
                for (const textElement of formatting)
                    textElement.classList.add("text");
                for (let i = 1; i < formatting.length; i++)
                    formatting[i - 1].appendChild(formatting[i]);
                textWrapper = formatting[0];
            }
            textWrapper.textContent = text;
            return textWrapper;
        }
    }
    exports.TextManager = TextManager;
});
define("ui/destiny/component/EnumIcon", ["require", "exports", "ui/component/Component"], function (require, exports, Component_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnumIconClasses = void 0;
    var EnumIconClasses;
    (function (EnumIconClasses) {
        EnumIconClasses["Main"] = "enum-icon";
        EnumIconClasses["Mask"] = "enum-icon-mask";
    })(EnumIconClasses || (exports.EnumIconClasses = EnumIconClasses = {}));
    class EnumIcon extends Component_2.default {
        static async applyIconVar(component, model, id, varName = "--icon", onApply) {
            const applied = await EnumIcon.applyIcon(model, id, iconPath => component.style.set(varName, `url(${iconPath})`));
            onApply?.(applied);
            return applied;
        }
        static async applyIcon(model, id, applicator) {
            const iconPath = await this.getIconPath(model, id);
            if (!iconPath)
                return false;
            applicator(iconPath);
            return true;
        }
        static async getIconPath(model, id) {
            const definition = await model.get(id);
            let iconPath = definition?.displayProperties.icon;
            if (!iconPath)
                return undefined;
            if (iconPath.startsWith("/"))
                iconPath = `https://www.bungie.net${iconPath}`;
            return iconPath;
        }
        async onMake(model, id) {
            this.classes.add(EnumIconClasses.Main, `${EnumIconClasses.Main}-${model.id}`);
            const iconPath = await EnumIcon.getIconPath(model, id);
            if (iconPath)
                this.attributes.set("src", iconPath);
        }
    }
    EnumIcon.defaultType = "img";
    exports.default = EnumIcon;
});
define("ui/utility/DisplayProperties", ["require", "exports", "model/models/Manifest", "model/models/ProfileBatch", "model/models/enum/EnumModelMap", "ui/component/Component", "ui/destiny/component/EnumIcon", "utility/Strings"], function (require, exports, Manifest_4, ProfileBatch_3, EnumModelMap_1, Component_3, EnumIcon_1, Strings_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Display;
    (function (Display) {
        Display.DESTINY_MANIFEST_MISSING_ICON_PATH = '/img/misc/missing_icon_d2.png';
        function make(name, description = '', others) {
            return {
                name,
                description,
                iconHash: 0,
                icon: '',
                iconSequences: [],
                hasIcon: false,
                highResIcon: '',
                ...others,
            };
        }
        Display.make = make;
        function icon(displayProperties, wrapped = true, allowMissing = false) {
            let url = displayProperties === undefined ? undefined : typeof displayProperties === 'string' ? displayProperties
                : getIconURL('displayProperties' in displayProperties ? displayProperties.displayProperties : displayProperties);
            if (!url)
                return undefined;
            if (url === Display.DESTINY_MANIFEST_MISSING_ICON_PATH && !allowMissing)
                return undefined;
            if (!url.startsWith('https://') && !url.startsWith('./'))
                url = `https://www.bungie.net${url}`;
            return wrapped ? `url("${url}")` : url;
        }
        Display.icon = icon;
        function name(displayProperties, orElse) {
            return displayProperties === undefined ? orElse
                : ('displayProperties' in displayProperties ? displayProperties.displayProperties : displayProperties).name
                    ?? orElse;
        }
        Display.name = name;
        function subtitle(displayProperties, orElse) {
            return displayProperties === undefined ? orElse
                : ('displayProperties' in displayProperties ? displayProperties.displayProperties : displayProperties).subtitle
                    ?? orElse;
        }
        Display.subtitle = subtitle;
        const interpolationRegex = /(\{var:\d+\})|(\[[\w-]+\])/g;
        async function applyDescription(component, description, options) {
            component.removeContents();
            if (!description)
                return [];
            const character = typeof options === 'string' ? options : options?.character;
            options = typeof options === 'string' ? {} : options;
            options ??= {};
            options.character = character;
            let resolveKeywords;
            options.keywords = new Promise(resolve => resolveKeywords = resolve);
            if (options?.singleLine)
                description = description.replace(/(\s*\n\s*)+/g, ' \xa0 / \xa0 ');
            const { DestinyTraitDefinition } = await Manifest_4.default.await();
            let traits = await DestinyTraitDefinition.all();
            traits = traits.filter(trait => trait.displayProperties.name && trait.displayProperties.description && trait.displayHint === 'keyword');
            for (const trait of traits) {
                const name = trait.displayProperties.nameLowerCase ??= trait.displayProperties.name.toLowerCase();
                trait.displayProperties.nameLowercaseVariations ??= Strings_2.default.getVariations(name);
            }
            const split = description.split(interpolationRegex);
            if (split.length < 2) {
                const addedTraits = applyDescriptionHighlightKeywords(component, description, traits);
                options.keywords = addedTraits;
                resolveKeywords(addedTraits);
                return addedTraits;
            }
            const addedKeywords = [];
            const { profileStringVariables, characterStringVariables } = ProfileBatch_3.default.latest ?? {};
            for (const section of split) {
                if (!section)
                    continue;
                switch (section[0]) {
                    case '[': {
                        const iconName = section
                            .slice(1, -1)
                            .toLowerCase()
                            .replace(/\W+/g, '-');
                        const enumIconPath = EnumModelMap_1.default[iconName];
                        if (!enumIconPath) {
                            console.warn('No entry in EnumModelMap for', iconName);
                            component.text.add(section);
                            break;
                        }
                        component.append(EnumIcon_1.default.create([...enumIconPath]));
                        break;
                    }
                    case '{': {
                        const hash = section.slice(5, -1);
                        const value = characterStringVariables?.data?.[character]?.integerValuesByHash[+hash]
                            ?? profileStringVariables?.data?.integerValuesByHash[+hash]
                            ?? 0;
                        component.append(Component_3.default.create('span')
                            .classes.add('var')
                            .text.set(`${value}`));
                        break;
                    }
                    default:
                        addedKeywords.push(...applyDescriptionHighlightKeywords(component, section, traits));
                }
            }
            options.keywords = addedKeywords;
            resolveKeywords(addedKeywords);
            return options.keywords;
        }
        Display.applyDescription = applyDescription;
        function applyDescriptionHighlightKeywords(component, description, traits) {
            const addedKeywords = [];
            let matching = traits;
            let keyword = '';
            let holding = '';
            let holdingSpaceIndex;
            let rawSection = '';
            for (let i = 0; i < description.length; i++) {
                const char = description[i];
                if (keyword !== undefined) {
                    if ((char === ' ' || char === '\n' || char === '(') && !keyword) {
                        rawSection += char;
                        continue;
                    }
                    holding += char;
                    keyword += char.toLowerCase();
                    const nextChar = description[i + 1];
                    const nextCharIsWordBreak = nextChar === ' ' || nextChar === '\n' || nextChar === ',' || nextChar === '.' || nextChar === ';' || nextChar === ':' || nextChar === ')';
                    const variations = Strings_2.default.getVariations(keyword);
                    matching = matching.filter(trait => variations.some(keyword => trait.displayProperties.nameLowercaseVariations.some(name => name.startsWith(keyword))));
                    if (!matching.length) {
                        keyword = char === ' ' || char === '\n' || char === '(' ? '' : undefined;
                        matching = traits;
                        if (holdingSpaceIndex) {
                            holding = holding.slice(0, -(i - holdingSpaceIndex));
                            i = holdingSpaceIndex;
                            keyword = '';
                        }
                        rawSection += holding;
                        holding = '';
                        holdingSpaceIndex = undefined;
                    }
                    else if (matching.length === 1 && nextCharIsWordBreak && matching[0].displayProperties.nameLowercaseVariations.some(name => variations.includes(name))) {
                        addedKeywords.push(matching[0]);
                        component.text.add(rawSection);
                        component.append(Component_3.default.create('span')
                            .classes.add('description-keyword')
                            .text.set(Strings_2.default.toTitleCase(holding)));
                        keyword = undefined;
                        holding = '';
                        rawSection = '';
                        matching = traits;
                        holdingSpaceIndex = undefined;
                    }
                    else if (char === ' ') {
                        holdingSpaceIndex ??= i;
                    }
                }
                else {
                    if (char === ' ' || char === '\n' || char === '(') {
                        keyword = '';
                    }
                    rawSection += char;
                }
            }
            if (rawSection)
                component.text.add(rawSection);
            return addedKeywords;
        }
        function description(displayProperties) {
            return displayProperties === undefined ? undefined
                : ('displayProperties' in displayProperties ? displayProperties.displayProperties : displayProperties)
                    .description;
        }
        Display.description = description;
        function descriptionIfShortOrName(detailedDisplayProperties, simpleDisplayProperties) {
            if (detailedDisplayProperties === undefined) {
                if (simpleDisplayProperties === undefined)
                    return undefined;
                else
                    detailedDisplayProperties = simpleDisplayProperties;
            }
            detailedDisplayProperties = 'displayProperties' in detailedDisplayProperties ? detailedDisplayProperties.displayProperties : detailedDisplayProperties;
            if (detailedDisplayProperties.description?.length && (detailedDisplayProperties.description?.length ?? 0) < 32)
                return detailedDisplayProperties.description;
            if (detailedDisplayProperties.name?.length && (detailedDisplayProperties.name?.length ?? 0) < 32 || !simpleDisplayProperties)
                return detailedDisplayProperties.name;
            simpleDisplayProperties = 'displayProperties' in simpleDisplayProperties ? simpleDisplayProperties.displayProperties : simpleDisplayProperties;
            return simpleDisplayProperties?.name;
        }
        Display.descriptionIfShortOrName = descriptionIfShortOrName;
        function nameIfShortOrName(detailedDisplayProperties, simpleDisplayProperties) {
            if (detailedDisplayProperties === undefined) {
                if (simpleDisplayProperties === undefined)
                    return undefined;
                else
                    detailedDisplayProperties = simpleDisplayProperties;
            }
            detailedDisplayProperties = 'displayProperties' in detailedDisplayProperties ? detailedDisplayProperties.displayProperties : detailedDisplayProperties;
            if (detailedDisplayProperties.name?.length && (detailedDisplayProperties.name?.length ?? 0) < 32 || !simpleDisplayProperties)
                return detailedDisplayProperties.name;
            simpleDisplayProperties = 'displayProperties' in simpleDisplayProperties ? simpleDisplayProperties.displayProperties : simpleDisplayProperties;
            return simpleDisplayProperties?.name;
        }
        Display.nameIfShortOrName = nameIfShortOrName;
        function getIconURL(displayProperties) {
            const icon = displayProperties?.icon;
            // if (icon?.endsWith(".png"))
            // 	return icon;
            return icon
                ?? displayProperties?.iconSequences
                    ?.flatMap(icon => icon.frames.filter(frame => frame.endsWith('.png')))?.[0]
                ?? icon;
        }
    })(Display || (Display = {}));
    exports.default = Display;
});
define("model/models/enum/EnumModel", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class EnumModel {
        static create(id, definition) {
            const model = new EnumModel(id);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
            Object.assign(model, definition);
            EnumModel.generators.push(() => {
                const promise = definition.generate().then(all => model.all = all);
                EnumModel.promises?.push(promise);
                return promise;
            });
            return model;
        }
        static async awaitAll() {
            if (EnumModel.generators) {
                (EnumModel.promises ??= []).push(...EnumModel.generators.map(generator => generator()));
                delete EnumModel.generators;
            }
            if (EnumModel.promises)
                await Promise.all(EnumModel.promises);
            delete EnumModel.promises;
        }
        constructor(id) {
            this.id = id;
        }
        get(id) {
            if (!Array.isArray(id)) {
                const byHash = this.all.array.find(def => def.enumValue === +id || def.hash === +id);
                if (byHash)
                    return byHash;
                const nameLowerCase = `${id}`.toLowerCase();
                if (!nameLowerCase)
                    // match none on zero length
                    return undefined;
                const matching = this.all.array.filter(type => type.displayProperties.nameLowerCase?.startsWith(nameLowerCase));
                if (matching.length > 1)
                    // return undefined on more than one match too
                    return undefined;
                return matching[0];
            }
            id = id.map(hash => +hash);
            return this.all.array.find(def => !Array.isArray(def.enumValue) ? id.includes(def.enumValue)
                : def.enumValue.every(enumValue => id.includes(enumValue)));
        }
        nameOf(id) {
            const def = this.get(id);
            return Object.entries(this.all)
                .find(([, d]) => d === def)?.[0];
        }
    }
    EnumModel.generators = [];
    EnumModel.promises = [];
    exports.default = EnumModel;
});
define("model/models/enum/BreakerTypes", ["require", "exports", "model/models/enum/EnumModel", "model/models/Manifest"], function (require, exports, EnumModel_4, Manifest_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const BreakerTypes = EnumModel_4.default.create("BreakerTypes", {
        async generate() {
            const { DestinyBreakerTypeDefinition } = await Manifest_5.default.await();
            const types = await DestinyBreakerTypeDefinition.all();
            return {
                array: types,
                barrier: types.find(type => type.enumValue === 1 /* DestinyBreakerType.ShieldPiercing */),
                overload: types.find(type => type.enumValue === 2 /* DestinyBreakerType.Disruption */),
                unstoppable: types.find(type => type.enumValue === 3 /* DestinyBreakerType.Stagger */),
            };
        },
    });
    exports.default = BreakerTypes;
});
define("model/models/items/BreakerType", ["require", "exports", "model/models/enum/BreakerTypes"], function (require, exports, BreakerTypes_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BreakerType;
    (function (BreakerType) {
        async function apply(manifest, item) {
            item.breakerTypes = await getBreakerTypes(manifest, item)
                .then(types => types.map(type => BreakerTypes_2.default.get(type))
                .filter((type) => !!type));
        }
        BreakerType.apply = apply;
        async function getBreakerTypes(manifest, item) {
            const { DeepsightBreakerTypeDefinition } = manifest;
            const breakerTypes = await Promise.resolve(DeepsightBreakerTypeDefinition.all())
                .then(types => types.toObject(type => [type.hash, type]));
            const traitSockets = item.getSockets("Perk/Trait", "Intrinsic/Exotic");
            const plugs = !item.bucket.isCollections() ? traitSockets.flatMap(socket => socket.plugs)
                : (await Promise.all(traitSockets.map(socket => socket.getPool()))).flat();
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            return plugs
                .flatMap((plug) => breakerTypes[plug?.definition?.hash]?.types ?? [])
                .concat(breakerTypes[item.definition.hash]?.types)
                .distinct()
                .filter(type => type !== undefined);
        }
    })(BreakerType || (BreakerType = {}));
    exports.default = BreakerType;
});
define("model/models/items/Catalyst", ["require", "exports", "utility/maths/Maths"], function (require, exports, Maths_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Catalyst;
    (function (Catalyst) {
        async function apply(manifest, profile, item) {
            item.catalyst = await resolve(manifest, profile, item);
        }
        Catalyst.apply = apply;
        async function resolve(manifest, profile, item) {
            const { DeepsightCatalystDefinition, DestinyRecordDefinition } = manifest;
            const catalyst = await DeepsightCatalystDefinition.get(item.definition.hash);
            const record = item.catalyst?.record
                ?? await DestinyRecordDefinition.get(catalyst?.record);
            if (!record || !catalyst)
                return undefined;
            const state = profile?.profileRecords?.data?.records?.[record.hash]
                ?? Object.values(profile?.characterRecords?.data ?? {})
                    ?.find(records => records?.records?.[record.hash])
                    ?.records?.[record.hash]
                ?? ({
                    state: 16 /* DestinyRecordState.Invisible */ | 8 /* DestinyRecordState.Obscured */ | 4 /* DestinyRecordState.ObjectiveNotCompleted */,
                    objectives: [],
                    rewardVisibilty: [],
                    intervalObjectives: [],
                    intervalsRedeemedCount: 0,
                });
            const primaryObjectives = state.objectives.filter(objective => catalyst.primaryObjectiveHashes.includes(objective.objectiveHash));
            return {
                record,
                state,
                progress: primaryObjectives.map(objective => Math.min(objective.progress ?? 0, objective.completionValue)).splat(Maths_2.default.sum),
                completionValue: primaryObjectives.map(objective => objective.completionValue).splat(Maths_2.default.sum),
                complete: primaryObjectives.every(objective => objective.complete),
                progressDescription: catalyst.progressDescription,
            };
        }
    })(Catalyst || (Catalyst = {}));
    exports.default = Catalyst;
});
define("model/models/items/Collectibles", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Collectibles;
    (function (Collectibles) {
        async function apply(manifest, profile, item) {
            update(profile, item);
            item.collectible = item.collectible ?? await manifest.DestinyCollectibleDefinition.get(item.definition.collectibleHash);
        }
        Collectibles.apply = apply;
        function update(profile, item) {
            item.collectibleState = get(profile, item.definition.collectibleHash)?.state;
        }
        Collectibles.update = update;
        function isAcquired(profile, collectibleHash) {
            const state = get(profile, collectibleHash)?.state ?? 0 /* DestinyCollectibleState.None */;
            return !(state & 1 /* DestinyCollectibleState.NotAcquired */);
        }
        Collectibles.isAcquired = isAcquired;
        function get(profile, collectibleHash) {
            return profile?.profileCollectibles?.data?.collectibles[collectibleHash]
                ?? Object.values(profile?.characterCollectibles?.data ?? {})[0]?.collectibles[collectibleHash];
        }
        Collectibles.get = get;
    })(Collectibles || (Collectibles = {}));
    exports.default = Collectibles;
});
define("model/models/items/Plugs", ["require", "exports", "model/models/Manifest", "model/models/items/Objectives", "utility/Arrays"], function (require, exports, Manifest_6, Objectives_1, Arrays_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Perk = exports.Plug = exports.Socket = exports.PlugType = void 0;
    const _ = undefined;
    var PlugType;
    (function (PlugType) {
        PlugType.None = "None";
        function check(type, ...fragments) {
            if (!type)
                return false;
            let found = false;
            let hadNot = false;
            let hadNotNot = false;
            for (let query of fragments) {
                let not = false;
                if (query[0] === "!") {
                    not = true;
                    query = query.slice(1);
                }
                else if (found)
                    // already found one and this isn't an inverted check, so skip it
                    continue;
                const startsWith = query[0] === "=" ? type === query.slice(1) : type.startsWith(query);
                if (startsWith && not)
                    return false; // if any "not"s match, early exit
                hadNot ||= not;
                found ||= startsWith;
                hadNotNot ||= !not;
            }
            return hadNotNot ? found : hadNot;
        }
        PlugType.check = check;
    })(PlugType || (exports.PlugType = PlugType = {}));
    class Socket {
        static filterByPlugs(sockets, ...anyOfTypes) {
            return sockets.filter((socket) => socket?.socketedPlug?.is(...anyOfTypes) ?? false);
        }
        static filterExcludePlugs(sockets, ...anyOfTypes) {
            return sockets.filter((socket) => socket?.socketedPlug?.isNot(...anyOfTypes) ?? false);
        }
        static filterType(sockets, ...anyOfTypes) {
            if (!anyOfTypes.length)
                return [];
            return sockets.filter((socket) => socket?.is(...anyOfTypes) ?? false);
        }
        static filterExcludeType(sockets, ...anyOfTypes) {
            return sockets.filter((socket) => socket?.isNot(...anyOfTypes) ?? false);
        }
        static async resolve(manifest, init, item, index) {
            const socket = new Socket();
            Object.assign(socket, init);
            delete socket.objectives;
            socket.item = item;
            socket.index = index;
            const { DeepsightSocketCategorisation } = manifest;
            const categorisation = await DeepsightSocketCategorisation.get(item?.definition.hash);
            socket.type = categorisation?.categorisation[index]?.fullName ?? "None";
            if (socket.type === "Cosmetic/Shader")
                return socket; // skip shader init
            if (item.bucket.isCollections() && socket.is("Cosmetic/Ornament") && item.moment?.hash !== 34 /* MomentHashes.IntoTheLight */)
                return socket; // skip ornament init in collections
            let plugSetHash = socket.definition.randomizedPlugSetHash ?? socket.definition.reusablePlugSetHash;
            const recipeItem = item.deepsight?.pattern?.recipe;
            const isAdept = item.baseItem;
            if (recipeItem && index !== undefined && !isAdept) {
                // skip recipes for adepts, that's just for reshaping the first two perks
                const recipeSocket = recipeItem.sockets?.socketEntries[index];
                if (recipeSocket) {
                    plugSetHash = recipeSocket.randomizedPlugSetHash ?? recipeSocket.reusablePlugSetHash;
                }
            }
            socket.plugSetHash = plugSetHash;
            await socket.refresh(manifest, init);
            return socket;
        }
        constructor() {
            this.type = PlugType.None;
            this.types = new Set();
            this.index = 0;
        }
        async refresh(manifest, refresh) {
            this.category = refresh.category;
            this.state = refresh.state;
            const { DestinyPlugSetDefinition, DeepsightSocketExtendedDefinition } = manifest;
            let plugs = _
                ?? (this.state ? refresh.plugs ?? [] : undefined)
                ?? this.plugs?.slice()
                ?? (!this.plugSetHash ? undefined : (await DestinyPlugSetDefinition.get(this.plugSetHash))?.reusablePlugItems)
                ?? (this.plugSetHash ? undefined : (await DeepsightSocketExtendedDefinition.get(this.item?.definition.hash))?.sockets[this.index]?.rewardPlugItems)
                ?? [];
            if (!this.state && !this.plugs)
                plugs = plugs.concat(this.definition.reusablePlugItems);
            plugs = plugs.distinct(plug => plug.plugItemHash);
            const currentPlugHash = this.state?.plugHash ?? this.definition.singleInitialItemHash;
            let plugListChanged = false;
            const plugsListHash = plugs.map(plug => plug.plugItemHash).join(",");
            if (this.plugsListHash !== plugsListHash) {
                this.plugsListHash = plugsListHash;
                const newPlugsList = [];
                for (const plug of plugs)
                    newPlugsList.push(await Plug.resolve(manifest, plug, this.item));
                plugListChanged = true;
                this.plugs = newPlugsList;
            }
            if (this.socketedPlug?.plugItemHash !== currentPlugHash) {
                let socketedPlug = this.plugs.find(plug => plug.plugItemHash === currentPlugHash);
                if (!socketedPlug && currentPlugHash) {
                    socketedPlug = await Plug.resolveFromHash(manifest, currentPlugHash, this.state?.isEnabled ?? true, this.item);
                    plugListChanged = true;
                    if (socketedPlug && this.state)
                        this.plugs.push(socketedPlug);
                }
                this.socketedPlug = socketedPlug;
                if (this.socketedPlug)
                    this.socketedPlug.socketed = true;
            }
            for (const plug of this.plugs) {
                await plug.refresh(manifest, refresh, this.item);
                if (plugListChanged)
                    this.types.add(plug.type);
            }
            if (this.socketedPlug) {
                await this.socketedPlug.refresh(manifest, refresh, this.item);
                if (plugListChanged)
                    this.types.add(this.socketedPlug.type);
            }
            if (plugListChanged) {
                if (this.types.size <= 1) {
                    const [type] = this.types;
                    this.type = type ?? PlugType.None;
                }
                else {
                    const smallestFirst = Array.from(this.types)
                        .sort((a, b) => a.length - b.length);
                    const smallest = smallestFirst[0];
                    if (smallestFirst.every(type => type.startsWith(smallest)))
                        this.type = smallest;
                    if (this.type === PlugType.None) {
                        // we still don't have a type, so now we grab the smallest type and see how much we can shorten it to make all match
                        let type = smallestFirst[0];
                        while (type.length) {
                            type = type.slice(0, -1);
                            if (!type.includes("/"))
                                break;
                            if (smallestFirst.every(t => t.startsWith(type))) {
                                this.type = type;
                                break;
                            }
                        }
                    }
                }
            }
        }
        getPool(...anyOfTypes) {
            if (this.plugPool && !(this.plugPool instanceof Promise))
                return anyOfTypes.length === 0 ? this.plugPool : this.plugPool.filter(plug => plug.is(...anyOfTypes));
            return (async () => {
                const plugPool = this.plugPool = await (this.plugPool ??= (async () => {
                    const manifest = await Manifest_6.default.await();
                    const { DestinyPlugSetDefinition, DeepsightSocketExtendedDefinition } = manifest;
                    const plugSetHash = this.definition.randomizedPlugSetHash ?? this.definition.reusablePlugSetHash;
                    const plugs = !plugSetHash
                        ? (await DeepsightSocketExtendedDefinition.get(this.item?.definition.hash))?.sockets[this.index]?.rewardPlugItems
                        : await Promise.resolve(DestinyPlugSetDefinition.get(this.definition.randomizedPlugSetHash ?? this.definition.reusablePlugSetHash))
                            .then(plugSet => plugSet?.reusablePlugItems ?? [])
                            .then((plugs) => plugs.concat(this.definition.reusablePlugItems));
                    return !plugs ? [] : Promise.all(plugs.map(plug => Plug.resolve(manifest, plug)));
                })());
                return anyOfTypes.length === 0 ? plugPool : plugPool.filter(plug => plug.is(...anyOfTypes));
            })();
        }
        is(...anyOfTypes) {
            return PlugType.check(this.type, ...anyOfTypes);
        }
        isNot(...anyOfTypes) {
            return !PlugType.check(this.type, ...anyOfTypes);
        }
        getPlugs(...anyOfTypes) {
            return (anyOfTypes.length === 0 ? this.plugs : this.plugs?.filter(plug => plug.is(...anyOfTypes)))
                ?? Arrays_3.default.EMPTY;
        }
        getPlug(...anyOfTypes) {
            return this.getPlugs(...anyOfTypes)[0];
        }
    }
    exports.Socket = Socket;
    class Plug {
        static async resolveFromHash(manifest, hash, enabled, item) {
            return Plug.resolve(manifest, {
                plugItemHash: hash,
                canInsert: true,
                enabled,
            }, item);
        }
        getCategorisationAs(category) {
            return this.categorisation?.category === category ? this.categorisation : undefined;
        }
        static async resolve(manifest, plugBase, item) {
            const manifestCacheTime = Manifest_6.default.getCacheTime();
            // generic caching doesn't work bcuz we store socketed & objectives data on instances
            // const genericHash = Plug.getGenericPlugHash(plugBase);
            // if (genericHash) {
            // 	if (Plug.plugGenericCacheTime < manifestCacheTime) {
            // 		Plug.plugGenericCacheTime = manifestCacheTime;
            // 		Plug.plugGenericCache = {};
            // 	}
            // 	const genericCached = this.plugGenericCache[genericHash];
            // 	if (genericCached)
            // 		return genericCached;
            // }
            const plug = new Plug();
            Object.assign(plug, plugBase);
            plug.socketed = false;
            if (Plug.plugDefCacheTime < manifestCacheTime) {
                Plug.plugDefCacheTime = manifestCacheTime;
                Plug.plugDefCache = {};
            }
            const plugDef = Plug.plugDefCache[plug.plugItemHash] ??= await Plug.resolvePlugDef(manifest, plug.plugItemHash, item);
            Object.assign(plug, plugDef);
            // if (genericHash)
            // 	this.plugGenericCache[genericHash] = plug;
            return plug;
        }
        // private static getGenericPlugHash (plugBase: DestinyItemPlugBase | DestinyItemSocketEntryPlugItemRandomizedDefinition) {
        // 	if ("enabled" in plugBase)
        // 		return plugBase.enableFailIndexes?.length || plugBase.insertFailIndexes?.length ? undefined
        // 			: `${plugBase.plugItemHash}:${plugBase.enabled ? "enabled" : "disabled"}:${plugBase.canInsert ? "canInsert" : "noInsert"}`;
        // 	return plugBase.craftingRequirements?.materialRequirementHashes?.length || !plugBase.craftingRequirements?.unlockRequirements?.length ? undefined
        // 		: `${plugBase.plugItemHash}:${plugBase.currentlyCanRoll ? "currentlyCanRoll" : "currentlyCannotRoll"}:${plugBase.craftingRequirements?.requiredLevel ?? 0}`;
        // }
        static async resolvePlugDef(manifest, hash, item) {
            const { DestinyInventoryItemDefinition, DeepsightPlugCategorisation, ClarityDescriptions } = manifest;
            // let start = Date.now();
            const definition = await DestinyInventoryItemDefinition.get(hash);
            // console.log("invtime", Date.now() - start);
            // start = Date.now();
            const clarity = definition && await ClarityDescriptions.get(hash);
            // console.log("claritytime", Date.now() - start);
            // start = Date.now();
            const categorisation = await DeepsightPlugCategorisation.get(hash);
            // console.log("cattime", Date.now() - start);
            // start = Date.now();
            return {
                definition,
                clarity,
                categorisation,
                type: categorisation?.fullName ?? "Unknown",
                perks: await Promise.all((definition?.perks ?? []).map(perk => Perk.resolve(manifest, perk))),
            };
        }
        constructor() { }
        is(...anyOfTypes) {
            return PlugType.check(this.type, ...anyOfTypes);
        }
        isNot(...anyOfTypes) {
            return !PlugType.check(this.type, ...anyOfTypes);
        }
        async refresh(manifest, refresh, item) {
            this.objectives = await Objectives_1.default.resolve(manifest, refresh.objectives[this.plugItemHash] ?? [], this, item);
        }
    }
    exports.Plug = Plug;
    (() => {
        Object.assign(window, { Plug });
    })();
    // private static plugGenericCacheTime = 0;
    // private static plugGenericCache: Record<string, Plug> = {};
    Plug.plugDefCacheTime = 0;
    Plug.plugDefCache = {};
    Plug.initialisedPlugTypes = {};
    class Perk {
        static async resolve({ DestinySandboxPerkDefinition }, perkEntry) {
            const perk = new Perk();
            Object.assign(perk, perkEntry);
            perk.definition = await DestinySandboxPerkDefinition.get(perk.perkHash);
            return perk;
        }
    }
    exports.Perk = Perk;
    var Plugs;
    (function (Plugs) {
        function resetInitialisedPlugTypes() {
            Plug.initialisedPlugTypes = {};
        }
        Plugs.resetInitialisedPlugTypes = resetInitialisedPlugTypes;
        function logInitialisedPlugTypes() {
            console.debug("Initialised plugs:", Plug.initialisedPlugTypes);
        }
        Plugs.logInitialisedPlugTypes = logInitialisedPlugTypes;
        function getSocketData(profile, item) {
            const { socketCategories, socketEntries } = item.definition.sockets ?? {};
            const states = profile?.itemComponents?.sockets.data?.[item.reference.itemInstanceId]?.sockets ?? [];
            const plugs = profile?.itemComponents?.reusablePlugs.data?.[item.reference.itemInstanceId]?.plugs ?? {};
            const objectivesByPlug = profile?.itemComponents?.plugObjectives?.data?.[item.reference.itemInstanceId]?.objectivesPerPlug ?? {};
            return {
                states,
                entries: socketEntries,
                categories: socketCategories,
                plugs,
                objectives: objectivesByPlug,
            };
        }
        async function apply(manifest, profile, item) {
            const { states, entries, categories, plugs, objectives } = getSocketData(profile, item);
            return item.sockets = (async () => {
                const sockets = await Promise.all((entries ?? [])
                    .map(async (definition, i) => Socket.resolve(manifest, {
                    definition,
                    state: states[i],
                    category: categories?.find(category => category.socketIndexes.includes(i)),
                    plugs: plugs[i],
                    objectives,
                }, item, i)));
                item.sockets = sockets;
                return item.sockets;
            })();
        }
        Plugs.apply = apply;
        async function refresh(manifest, profile, item) {
            const { states, categories, plugs, objectives } = getSocketData(profile, item);
            for (let i = 0; i < item.sockets.length; i++) {
                const socket = item.sockets[i];
                await socket?.refresh(manifest, {
                    state: states[i],
                    category: categories?.find(category => category.socketIndexes.includes(i)),
                    plugs: plugs[i],
                    objectives,
                });
            }
        }
        Plugs.refresh = refresh;
    })(Plugs || (Plugs = {}));
    exports.default = Plugs;
});
define("model/models/items/Objectives", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Objectives;
    (function (Objectives) {
        async function resolve(manifest, objectives, plug, item) {
            const result = [];
            for (const objective of objectives) {
                result.push({
                    hash: objective.objectiveHash,
                    progress: objective,
                    plug,
                    definition: plug?.objectives?.find(e => e.hash === objective.objectiveHash)?.definition
                        ?? await manifest.DestinyObjectiveDefinition.get(objective.objectiveHash),
                });
            }
            return result;
        }
        Objectives.resolve = resolve;
    })(Objectives || (Objectives = {}));
    exports.default = Objectives;
});
define("model/models/items/Deepsight", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Deepsight;
    (function (Deepsight) {
        async function apply(manifest, profile, item) {
            item.shaped = item.bucket.isCollections() ? undefined : await resolveShaped(item);
            item.deepsight = await resolve(manifest, profile, item);
        }
        Deepsight.apply = apply;
        async function resolve(manifest, profile, item) {
            const pattern = await resolvePattern(manifest, profile, item);
            return {
                resonance: !item.bucket.isCollections() && await resolveResonance(item),
                pattern,
                activation: !item.bucket.isCollections() && !item.shaped && !pattern?.progress?.complete && await resolveActivation(item),
            };
        }
        async function resolveShaped(item) {
            if (!(item.reference.state & 8 /* ItemState.Crafted */))
                return undefined;
            return {
                level: await findObjective(item, objective => objective.definition.uiStyle === 2 /* DestinyObjectiveUiStyle.CraftingWeaponLevel */),
                progress: await findObjective(item, objective => objective.definition.uiStyle === 3 /* DestinyObjectiveUiStyle.CraftingWeaponLevelProgress */),
            };
        }
        async function resolveResonance(item) {
            const sockets = await item.sockets;
            return sockets?.some(socket => socket?.state?.isVisible && socket.socketedPlug?.is("Extractable/DeepsightResonance"));
        }
        async function resolveActivation(item) {
            const sockets = await item.sockets;
            return sockets?.some(socket => socket?.socketedPlug?.is("Extractable/DeepsightActivation"));
        }
        async function resolvePattern(manifest, profile, item) {
            const { DestinyInventoryItemDefinition } = manifest;
            const recipe = await DestinyInventoryItemDefinition.get(item.definition.inventory?.recipeItemHash);
            const result = {
                recipe,
                ...await resolvePatternRecord(manifest, profile, item),
            };
            if (!result.record && !result.recipe)
                return undefined;
            return result;
        }
        async function resolvePatternRecord(manifest, profile, item) {
            const { DestinyCollectibleDefinition, DestinyRecordDefinition } = manifest;
            if (item.definition.displayProperties.icon === "/img/misc/missing_icon_d2.png")
                return undefined;
            let record = item.deepsight?.pattern?.record;
            if (!record) {
                const collectible = await DestinyCollectibleDefinition.get(item.definition.collectibleHash);
                record = collectible ? await DestinyRecordDefinition.get("icon", collectible?.displayProperties.icon ?? null)
                    : await DestinyRecordDefinition.get("name", item.definition.displayProperties.name);
                if (item.moment?.hash === 34 /* MomentHashes.IntoTheLight */ && item.tier?.hash !== 2759499571 /* ItemTierTypeHashes.Exotic */)
                    return undefined;
                if (record?.recordTypeName !== "Weapon Pattern")
                    return undefined;
            }
            return {
                record,
                progress: resolvePatternProgress(record, profile, item),
            };
        }
        function resolvePatternProgress(record, profile, item) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            const progress = profile?.profileRecords?.data?.records[record?.hash]
                ?? Object.values(profile?.characterRecords?.data ?? {}) // bungie bad, sometimes patterns are character scoped
                    .map(records => records.records[record?.hash])
                    .find(record => record);
            if (!progress?.objectives)
                return undefined;
            if (progress.objectives.length !== 1) {
                console.warn(`Incomprehensible pattern record for '${item.definition.displayProperties.name}'`, progress);
                return undefined;
            }
            if (!progress.objectives[0].completionValue)
                return undefined;
            return progress.objectives[0];
        }
        async function findObjective(item, predicate) {
            const sockets = await item.sockets ?? [];
            for (const objective of sockets.flatMap(socket => socket?.plugs?.flatMap(plug => plug.objectives) ?? [])) {
                if (objective && predicate(objective))
                    return objective;
            }
            return undefined;
        }
    })(Deepsight || (Deepsight = {}));
    exports.default = Deepsight;
});
define("model/models/items/Moment", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Moment;
    (function (Moment) {
        async function apply(manifest, item) {
            item.moment = await resolve(manifest, item);
        }
        Moment.apply = apply;
        async function resolve({ DeepsightMomentDefinition }, item) {
            if (!item.definition.iconWatermark)
                return undefined;
            // skip engrams
            if (item.definition.itemType === 8 /* DestinyItemType.Engram */ || item.definition.traitHashes?.includes(1465704995))
                return undefined;
            const moment = await DeepsightMomentDefinition.get("iconWatermark", item.definition.iconWatermark);
            if (moment)
                return moment;
            console.warn(`Unable to determine moment of '${item.definition.displayProperties.name}' (${item.definition.hash})`, item);
            return undefined;
        }
    })(Moment || (Moment = {}));
    exports.default = Moment;
});
define("model/models/items/Perks", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const _ = undefined;
    var Perks;
    (function (Perks) {
        async function apply(manifest, profile, item) {
            item.perks = (await resolve(manifest, profile, item))
                ?.filter((perk) => !!perk);
        }
        Perks.apply = apply;
        async function resolve({ DestinySandboxPerkDefinition }, profile, item) {
            if (!item.definition.perks?.length)
                return undefined;
            const perkRefs = _
                // only applies to instanced items
                ?? profile.itemComponents?.perks.data?.[item.reference.itemInstanceId]?.perks
                // `perks.data` is always {}
                ?? (profile.characterUninstancedItemComponents && Object.values(profile.characterUninstancedItemComponents))
                    ?.find(uninstancedItemComponents => uninstancedItemComponents?.perks?.data?.[item.definition.hash]?.perks)
                    ?.perks?.data?.[item.definition.hash]?.perks
                // `uninstancedItemPerks` is always {}
                ?? (profile.characterProgressions?.data && Object.values(profile.characterProgressions.data))
                    ?.find(progression => progression.uninstancedItemPerks[item.definition.hash])
                    ?.uninstancedItemPerks[item.definition.hash].perks;
            return Promise.all(item.definition.perks.map(async (perk) => {
                const result = perk;
                const definition = await DestinySandboxPerkDefinition.get(perk.perkHash);
                if (!definition)
                    return undefined;
                result.definition = definition;
                result.reference = perkRefs?.find(ref => ref.perkHash === perk.perkHash);
                return result;
            }));
        }
    })(Perks || (Perks = {}));
    exports.default = Perks;
});
define("model/models/items/PowerCap", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PowerCap;
    (function (PowerCap) {
        async function apply({ DestinyPowerCapDefinition }, item) {
            item.powerCap = await DestinyPowerCapDefinition.get(item?.definition.quality?.versions[item.definition.quality.currentVersion]?.powerCapHash);
        }
        PowerCap.apply = apply;
    })(PowerCap || (PowerCap = {}));
    exports.default = PowerCap;
});
define("model/models/items/Source", ["require", "exports", "utility/endpoint/bungie/Bungie"], function (require, exports, Bungie_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SourceType = void 0;
    const _ = undefined;
    var SourceType;
    (function (SourceType) {
        SourceType[SourceType["Playlist"] = 0] = "Playlist";
        SourceType[SourceType["Rotator"] = 1] = "Rotator";
        SourceType[SourceType["Repeatable"] = 2] = "Repeatable";
        SourceType[SourceType["New"] = 3] = "New";
    })(SourceType || (exports.SourceType = SourceType = {}));
    var Source;
    (function (Source) {
        async function apply(manifest, profile, item) {
            if (!item.bucket.isCollections())
                return;
            item.sources = await resolve(manifest, profile, item);
        }
        Source.apply = apply;
        async function resolve(manifest, profile, item) {
            const dropTableSources = await resolveDropTables(manifest, profile, item);
            if (!dropTableSources?.length)
                return undefined;
            return dropTableSources ?? [];
        }
        async function resolveDropTables(manifest, profile, item) {
            const { DeepsightDropTableDefinition } = manifest;
            const hash = item.definition.hash;
            let dropTables = await DeepsightDropTableDefinition.all();
            dropTables = dropTables.filter(table => false
                || table.dropTable?.[hash]
                || table.encounters?.some(encounter => encounter.dropTable?.[hash])
                || table.master?.dropTable?.[hash]
                || table.rotations?.drops?.some(drop => drop === hash || typeof drop === "object" && hash in drop)
                || table.rotations?.masterDrops?.some(drop => drop === hash || typeof drop === "object" && hash in drop));
            if (!dropTables.length)
                return undefined;
            return Promise.all(dropTables.map(table => resolveDropTable(manifest, profile, table, item)));
        }
        async function resolveDropTable(manifest, profile, table, item) {
            const { DestinyActivityDefinition, DestinyActivityModifierDefinition, DestinyInventoryItemDefinition } = manifest;
            const intervals = table.rotations?.current ?? 0;
            const activityDefinition = await DestinyActivityDefinition.get(table.hash);
            const masterActivityDefinition = await DestinyActivityDefinition.get(table.master?.activityHash);
            const type = _
                ?? (table.availability === "rotator" ? SourceType.Rotator : undefined)
                ?? (table.availability === "repeatable" ? SourceType.Repeatable : undefined)
                ?? (table.availability === "new" ? SourceType.New : undefined)
                ?? SourceType.Playlist;
            const hash = item.definition.hash;
            const dropDef = table.dropTable?.[hash]
                ?? table.encounters?.find(encounter => encounter.dropTable?.[hash])?.dropTable?.[hash]
                ?? table.master?.dropTable?.[hash];
            const rotatedDrop = resolveRotation(table.rotations?.drops, intervals);
            const isRotationDrop = rotatedDrop === hash || typeof rotatedDrop === "object" && hash in rotatedDrop;
            const rotatedMasterDrop = resolveRotation(table.rotations?.masterDrops, intervals);
            const isMasterRotationDrop = rotatedMasterDrop === hash || typeof rotatedMasterDrop === "object" && hash in rotatedMasterDrop;
            const isMaster = !!table.master?.dropTable?.[hash] || isMasterRotationDrop;
            const isRotatingChallengeRelevant = isMaster
                ? isMasterRotationDrop || !table.rotations?.masterDrops
                : isRotationDrop || !table.rotations?.drops;
            const activeChallenges = (!table.rotations?.challenges || !isRotatingChallengeRelevant ? []
                : (table.availability === "rotator"
                    ? await Promise.all(table.rotations.challenges.map(hash => DestinyActivityModifierDefinition.get(hash)))
                    : [await DestinyActivityModifierDefinition.get(resolveRotation(table.rotations.challenges, intervals))])).filter((challenge) => challenge !== undefined);
            return {
                dropTable: table,
                activityDefinition: activityDefinition,
                masterActivityDefinition,
                activeChallenges,
                isActiveDrop: (!!table.rotations?.drops && isRotationDrop)
                    || (!!table.availability && !!activityDefinition?.activityModeHashes?.includes(2394616003 /* ActivityModeHashes.Strikes */)),
                isActiveMasterDrop: !!table.master?.availability && isMaster,
                type,
                endTime: table.endTime ? new Date(table.endTime).getTime() : type === SourceType.Rotator ? Bungie_4.default.nextWeeklyReset : undefined,
                requiresQuest: !dropDef?.requiresQuest ? undefined : (await DestinyInventoryItemDefinition.get(dropDef.requiresQuest) ?? null),
                requiresItems: !dropDef?.requiresItems?.length ? undefined : await Promise.all(dropDef.requiresItems.map(async (hash) => (await DestinyInventoryItemDefinition.get(hash)) ?? null)),
                purchaseOnly: dropDef?.purchaseOnly,
            };
        }
        function resolveRotation(rotation, intervals) {
            return !rotation?.length ? undefined : rotation?.[intervals % rotation.length];
        }
        function isWeeklyChallenge(objective) {
            return objective?.displayProperties?.name === "Weekly Dungeon Challenge"
                || objective?.displayProperties?.name === "Weekly Raid Challenge";
        }
        Source.isWeeklyChallenge = isWeeklyChallenge;
    })(Source || (Source = {}));
    exports.default = Source;
});
define("ui/destiny/utility/Stat", ["require", "exports", "utility/Store"], function (require, exports, Store_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IStatDistribution = exports.ARMOUR_GROUP_STATS_MAX = exports.ARMOUR_STAT_MAX_VISUAL = exports.ARMOUR_STAT_MAX = exports.ARMOUR_STAT_MIN = exports.ARMOUR_STAT_GROUPS = exports.STAT_DISPLAY_ORDER = exports.Stat = void 0;
    // for reference:
    1591432999 /* StatHashes.Accuracy */;
    // Don't use bungie-api/ts/destiny2.StatHashes because it's a const enum and we use the names for css classes
    var Stat;
    (function (Stat) {
        // Unrendered
        Stat[Stat["Attack"] = 1480404414] = "Attack";
        Stat[Stat["Defense"] = 3897883278] = "Defense";
        Stat[Stat["Power"] = 1935470627] = "Power";
        Stat[Stat["InventorySize"] = 1931675084] = "InventorySize";
        Stat[Stat["Mystery1"] = 1885944937] = "Mystery1";
        Stat[Stat["Mystery2"] = 3291498656] = "Mystery2";
        // weapons
        Stat[Stat["Stability"] = 155624089] = "Stability";
        Stat[Stat["Range"] = 1240592695] = "Range";
        Stat[Stat["Magazine"] = 3871231066] = "Magazine";
        Stat[Stat["AmmoCapacity"] = 925767036] = "AmmoCapacity";
        Stat[Stat["RPM"] = 4284893193] = "RPM";
        Stat[Stat["DrawTime"] = 447667954] = "DrawTime";
        Stat[Stat["AirborneEffectiveness"] = 2714457168] = "AirborneEffectiveness";
        Stat[Stat["AimAssistance"] = 1345609583] = "AimAssistance";
        Stat[Stat["RecoilDirection"] = 2715839340] = "RecoilDirection";
        Stat[Stat["Zoom"] = 3555269338] = "Zoom";
        Stat[Stat["ChargeTime"] = 2961396640] = "ChargeTime";
        // armour
        Stat[Stat["Mobility"] = 2996146975] = "Mobility";
        Stat[Stat["Resilience"] = 392767087] = "Resilience";
        Stat[Stat["Recovery"] = 1943323491] = "Recovery";
        Stat[Stat["Discipline"] = 1735777505] = "Discipline";
        Stat[Stat["Intellect"] = 144602215] = "Intellect";
        Stat[Stat["Strength"] = 4244567218] = "Strength";
        // ghosts
        Stat[Stat["GhostEnergyCapacity"] = 237763788] = "GhostEnergyCapacity";
        Stat[Stat["ModCost"] = 514071887] = "ModCost";
    })(Stat || (exports.Stat = Stat = {}));
    exports.STAT_DISPLAY_ORDER = {
        [Stat.RPM]: -1,
        [Stat.AirborneEffectiveness]: { after: Stat.Stability },
        [Stat.AimAssistance]: { after: Stat.AirborneEffectiveness },
        [Stat.Zoom]: { after: Stat.AimAssistance },
        [Stat.RecoilDirection]: { after: Stat.Zoom },
        [Stat.Magazine]: 1001,
        [Stat.AmmoCapacity]: 1002,
    };
    exports.ARMOUR_STAT_GROUPS = [
        [Stat.Mobility, Stat.Resilience, Stat.Recovery],
        [Stat.Discipline, Stat.Intellect, Stat.Strength],
    ];
    exports.ARMOUR_STAT_MIN = 2;
    exports.ARMOUR_STAT_MAX = 30;
    exports.ARMOUR_STAT_MAX_VISUAL = 44;
    exports.ARMOUR_GROUP_STATS_MAX = 34;
    exports.IStatDistribution = new class StatDistributionManager {
        constructor() {
            this.enabled = {};
            this.preferred = {};
        }
        isEnabled(stat, classType) {
            let enabled = this.enabled[classType]?.[stat];
            if (enabled === undefined) {
                this.enabled[classType] ??= {};
                this.enabled[classType][stat] = enabled = Store_7.default.get(`preferredStatDistribution.${classType}.${Stat[stat]}.enabled`) ?? false;
            }
            return enabled;
        }
        getPreferredValue(stat, classType) {
            let preferred = this.preferred[classType]?.[stat];
            if (preferred === undefined) {
                this.preferred[classType] ??= {};
                this.preferred[classType][stat] = preferred = Store_7.default.get(`preferredStatDistribution.${classType}.${Stat[stat]}`) ?? Math.floor(exports.ARMOUR_GROUP_STATS_MAX / 3);
            }
            return preferred;
        }
        setIsEnabled(stat, classType, enabled) {
            if (this.isEnabled(stat, classType) === enabled)
                return;
            this.enabled[classType][stat] = enabled;
            Store_7.default.set(`preferredStatDistribution.${classType}.${Stat[stat]}.enabled`, enabled);
        }
        setPreferredValue(stat, classType, value) {
            if (this.getPreferredValue(stat, classType) === value)
                return;
            this.preferred[classType][stat] = value;
            Store_7.default.set(`preferredStatDistribution.${classType}.${Stat[stat]}`, value);
        }
        get(item) {
            if (!item.stats || !exports.ARMOUR_STAT_GROUPS.flat().some(stat => item.stats?.values[stat]?.roll))
                return { overall: 0, groups: exports.ARMOUR_STAT_GROUPS.map(_ => 0) };
            const result = { overall: 0, groups: [] };
            let total = 0;
            let groups = 0;
            for (const group of exports.ARMOUR_STAT_GROUPS) {
                let groupEnabledNearnessTotal = 0;
                let groupDisabledTotal = 0;
                let stats = 0;
                for (const stat of group) {
                    const statValue = item.stats.values[stat]?.roll ?? 0;
                    if (!this.isEnabled(stat, item.definition.classType)) {
                        groupDisabledTotal += statValue;
                        continue;
                    }
                    groupDisabledTotal += statValue;
                    const nearness = 1 - Math.abs(this.getPreferredValue(stat, item.definition.classType) - statValue) / exports.ARMOUR_STAT_MAX;
                    groupEnabledNearnessTotal += nearness;
                    stats++;
                }
                if (groupDisabledTotal) {
                    const qualityOfDisabledStats = groupDisabledTotal / exports.ARMOUR_GROUP_STATS_MAX;
                    groupEnabledNearnessTotal += qualityOfDisabledStats;
                    stats++;
                }
                const groupDistribution = groupEnabledNearnessTotal / stats;
                result.groups.push(groupDistribution);
                total += groupDistribution;
                groups++;
            }
            result.overall = total / groups;
            return result;
        }
    };
});
define("model/models/items/Stats", ["require", "exports", "model/models/items/Plugs", "ui/destiny/utility/Stat", "utility/maths/Maths"], function (require, exports, Plugs_1, Stat_1, Maths_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Stats;
    (function (Stats) {
        async function apply(manifest, profile, item) {
            item.stats = await resolve(manifest, profile, item);
        }
        Stats.apply = apply;
        async function resolve(manifest, profile, item) {
            if (!item.definition.stats)
                return undefined;
            const { DestinyStatGroupDefinition, DestinyStatDefinition } = manifest;
            const statGroupDefinition = item.stats?.definition ?? await DestinyStatGroupDefinition.get(item.definition.stats?.statGroupHash);
            if (!statGroupDefinition)
                return undefined;
            const intrinsicStats = item.definition.investmentStats;
            const sockets = (await item.sockets) ?? [];
            const statRolls = Plugs_1.Socket.filterByPlugs(sockets, 'Intrinsic')
                .flatMap(socket => socket.socketedPlug.definition?.investmentStats ?? []);
            const stats = profile?.itemComponents?.stats.data?.[item.reference.itemInstanceId]?.stats ?? item.definition.stats.stats;
            if (stats)
                for (const random of statRolls)
                    if (random && !random.isConditionallyActive)
                        stats[random.statTypeHash] ??= { statHash: random.statTypeHash, value: random.value };
            const masterworkStats = item.bucket.isCollections() ? [] : Plugs_1.Socket.filterByPlugs(sockets, 'Masterwork', 'Intrinsic/FrameEnhanced')
                .flatMap(socket => socket.socketedPlug.definition?.investmentStats ?? []);
            const modStats = item.bucket.isCollections() ? [] : Plugs_1.Socket.filterExcludePlugs(sockets, 'Intrinsic', 'Masterwork')
                .flatMap(socket => socket.socketedPlug.definition?.investmentStats ?? []);
            const chargeStats = item.bucket.isCollections() ? [] : Plugs_1.Socket.filterByPlugs(sockets, 'Mod/Armor')
                .flatMap(socket => socket.socketedPlug.getCategorisationAs(3 /* DeepsightPlugCategory.Mod */)?.armourChargeStats ?? []);
            const result = {};
            for (const [hashString, { value }] of Object.entries(stats ?? {})) {
                const hash = +hashString;
                const statDefinition = item.stats?.values[hash]?.definition ?? await DestinyStatDefinition.get(hash);
                if (!statDefinition) {
                    console.warn('Unknown stat', hash, 'value', value);
                    continue;
                }
                const displayIndex = statGroupDefinition.scaledStats.findIndex(stat => stat.statHash === hash);
                const display = statGroupDefinition.scaledStats[displayIndex];
                const stat = result[hash] = {
                    hash,
                    value,
                    definition: statDefinition,
                    max: hash === Stat_1.Stat.ChargeTime && item.definition.itemSubType === 11 /* DestinyItemSubType.FusionRifle */ ? 1000 : display?.maximumValue ?? 100,
                    bar: !(display?.displayAsNumeric ?? false),
                    order: Stat_1.STAT_DISPLAY_ORDER[hash] ?? (displayIndex === -1 ? 10000 : displayIndex),
                    intrinsic: 0,
                    roll: 0,
                    mod: 0,
                    masterwork: 0,
                    subclass: !item.definition.itemCategoryHashes?.includes(50 /* ItemCategoryHashes.Subclasses */) ? 0 : value,
                    charge: 0,
                };
                const statDisplay = statGroupDefinition.scaledStats.find(statDisplay => statDisplay.statHash === hash);
                function interpolate(value) {
                    if (!statDisplay?.displayInterpolation.length)
                        return value;
                    const start = statDisplay.displayInterpolation.findLast(stat => stat.value <= value) ?? statDisplay.displayInterpolation[0];
                    const end = statDisplay.displayInterpolation.find(stat => stat.value > value) ?? statDisplay.displayInterpolation[statDisplay.displayInterpolation.length - 1];
                    if (start === end)
                        return start.weight;
                    const t = (value - start.value) / (end.value - start.value);
                    return Maths_3.default.bankersRound(start.weight + t * (end.weight - start.weight));
                }
                for (const intrinsic of intrinsicStats)
                    if (hash === intrinsic?.statTypeHash && !intrinsic.isConditionallyActive)
                        stat.intrinsic += intrinsic.value;
                for (const random of statRolls)
                    if (hash === random?.statTypeHash && !random.isConditionallyActive)
                        stat.roll += random.value;
                for (const masterwork of masterworkStats)
                    if (hash === masterwork.statTypeHash && !masterwork.isConditionallyActive)
                        stat.masterwork += masterwork.value;
                for (const mod of modStats)
                    if (hash === mod?.statTypeHash && !mod.isConditionallyActive)
                        stat.mod += mod.value;
                let chargeCount = 0;
                for (const mod of chargeStats)
                    if (hash === mod?.statTypeHash)
                        stat.charge = typeof mod.value === 'number' ? mod.value : mod.value[chargeCount++];
                const { intrinsic, roll, masterwork, mod } = stat;
                stat.intrinsic = interpolate(intrinsic + roll);
                stat.roll = interpolate(roll);
                stat.mod = interpolate(intrinsic + roll + mod) - stat.intrinsic;
                stat.masterwork = interpolate(intrinsic + roll + masterwork) - stat.intrinsic;
            }
            return {
                values: result,
                definition: statGroupDefinition,
                block: item.definition.stats,
            };
        }
    })(Stats || (Stats = {}));
    exports.default = Stats;
});
define("model/models/items/Tier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Tier;
    (function (Tier) {
        async function apply({ DeepsightTierTypeDefinition }, item) {
            item.tier = await DeepsightTierTypeDefinition.get(item.definition.inventory?.tierTypeHash);
        }
        Tier.apply = apply;
    })(Tier || (Tier = {}));
    exports.default = Tier;
});
define("model/models/state/StateItemTransfer", ["require", "exports", "model/models/items/Bucket", "model/models/state/IStateModification", "utility/Arrays"], function (require, exports, Bucket_1, IStateModification_2, Arrays_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = IStateModification_2.default.register({
        type: "item/transfer",
        apply(profile, modification) {
            const [fromBucket, fromCharacterId, fromSubBucketDefinition] = Bucket_1.Bucket.parseId(modification.fromBucket);
            if (fromSubBucketDefinition)
                throw new Error("Cannot transfer items from a sub bucket");
            const [toBucket, toCharacterId, toSubBucketDefinition] = Bucket_1.Bucket.parseId(modification.toBucket);
            if (toSubBucketDefinition)
                throw new Error("Cannot transfer items to a sub bucket");
            if (fromBucket === "collections" || toBucket === "collections")
                throw new Error("Cannot transfer items to or from collections");
            const fromEquipped = modification.fromEquipped ? "characterEquipment" : "characterInventories";
            const from = !fromCharacterId ? profile.profileInventory?.data?.items : profile[fromEquipped]?.data?.[fromCharacterId].items;
            if (!from)
                throw new Error(`Cannot find bucket '${modification.fromBucket}' to transfer item from`);
            const item = from.find(item => item.itemInstanceId === modification.item);
            if (!item)
                throw new Error(`Cannot find item '${modification.item}' in bucket '${modification.fromBucket}'`);
            if (item.bucketHash !== fromBucket)
                throw new Error(`Bad state! Expected item '${modification.item}' bucket state to be '${fromBucket}', was '${item.bucketHash}'`);
            const toEquipped = modification.toEquipped ? "characterEquipment" : "characterInventories";
            const to = !toCharacterId ? profile.profileInventory?.data?.items : profile[toEquipped]?.data?.[toCharacterId].items;
            if (!to)
                throw new Error(`Cannot find bucket '${modification.fromBucket}' to transfer item to`);
            if (from !== to) {
                Arrays_4.default.removeSwap(from, item);
                to.push(item);
            }
            item.bucketHash = toBucket;
        },
    });
});
define("model/models/state/StateLock", ["require", "exports", "model/models/state/IStateModification"], function (require, exports, IStateModification_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = IStateModification_3.default.register({
        type: "item/lock",
        apply(profile, modification) {
            const tryLock = (item) => {
                if (item.itemInstanceId !== modification.item)
                    return;
                const mutable = item;
                if (modification.locked)
                    mutable.state |= 1 /* ItemState.Locked */;
                else
                    mutable.state &= ~1 /* ItemState.Locked */;
            };
            for (const item of profile.profileInventory?.data?.items ?? [])
                tryLock(item);
            for (const character of Object.values(profile.characterInventories?.data ?? {}))
                for (const item of character.items)
                    tryLock(item);
            for (const character of Object.values(profile.characterEquipment?.data ?? {}))
                for (const item of character.items)
                    tryLock(item);
        },
    });
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/items/EquipItem", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_8, ProfileManager_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_8.default
        .at("/Destiny2/Actions/Items/EquipItem/")
        .request((item, character) => {
        return {
            method: "POST",
            body: {
                itemId: item.reference.itemInstanceId,
                characterId: character,
                membershipType: ProfileManager_4.default.get()?.data.membershipType,
            },
        };
    })
        .endpoint();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/items/PullFromPostmaster", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_9, ProfileManager_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_9.default
        .at("/Destiny2/Actions/Items/PullFromPostmaster/")
        .request(async (item, character) => {
        if (!item.reference.itemInstanceId)
            throw new Error("Item has no instance ID");
        return {
            method: "POST",
            body: {
                itemReferenceHash: item.definition.hash,
                stackSize: item.reference.quantity,
                itemId: item.reference.itemInstanceId,
                characterId: character,
                membershipType: ProfileManager_5.default.get()?.data.membershipType,
            },
        };
    })
        .endpoint();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/items/SetLockState", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_10, ProfileManager_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_10.default
        .at("/Destiny2/Actions/Items/SetLockState/")
        .request((item, locked) => {
        if (!item.reference.itemInstanceId)
            throw new Error("Item has no instance ID");
        return {
            method: "POST",
            body: {
                state: locked,
                itemId: item.reference.itemInstanceId,
                characterId: item.owner?.characterId,
                membershipType: ProfileManager_6.default.get()?.data.membershipType,
            },
        };
    })
        .endpoint();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/items/TransferItem", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_11, ProfileManager_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_11.default
        .at("/Destiny2/Actions/Items/TransferItem/")
        .request((item, character, destination = character) => {
        if (!item.reference.itemInstanceId)
            throw new Error("Item has no instance ID");
        return {
            method: "POST",
            body: {
                itemReferenceHash: item.definition.hash,
                stackSize: item.reference.quantity,
                transferToVault: destination === "vault",
                itemId: item.reference.itemInstanceId,
                characterId: destination === "vault" ? character : destination,
                membershipType: ProfileManager_7.default.get()?.data.membershipType,
            },
        };
    })
        .endpoint();
});
define("model/models/items/Item", ["require", "exports", "model/models/Characters", "model/models/DeepsightStats", "model/models/Manifest", "model/models/ProfileBatch", "model/models/items/BreakerType", "model/models/items/Bucket", "model/models/items/Catalyst", "model/models/items/Collectibles", "model/models/items/Deepsight", "model/models/items/Moment", "model/models/items/Perks", "model/models/items/Plugs", "model/models/items/PowerCap", "model/models/items/Source", "model/models/items/Stats", "model/models/items/Tier", "model/models/state/StateItemTransfer", "model/models/state/StateLock", "utility/Arrays", "utility/EventManager", "utility/ProfileManager", "utility/Store", "utility/endpoint/bungie/endpoint/destiny2/actions/items/EquipItem", "utility/endpoint/bungie/endpoint/destiny2/actions/items/PullFromPostmaster", "utility/endpoint/bungie/endpoint/destiny2/actions/items/SetLockState", "utility/endpoint/bungie/endpoint/destiny2/actions/items/TransferItem"], function (require, exports, Characters_1, DeepsightStats_1, Manifest_7, ProfileBatch_4, BreakerType_1, Bucket_2, Catalyst_1, Collectibles_1, Deepsight_1, Moment_1, Perks_1, Plugs_2, PowerCap_1, Source_1, Stats_1, Tier_1, StateItemTransfer_1, StateLock_1, Arrays_5, EventManager_10, ProfileManager_8, Store_8, EquipItem_1, PullFromPostmaster_1, SetLockState_1, TransferItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemFomoState = void 0;
    var ItemFomoState;
    (function (ItemFomoState) {
        ItemFomoState[ItemFomoState["NoMo"] = 0] = "NoMo";
        ItemFomoState[ItemFomoState["TemporaryAvailability"] = 1] = "TemporaryAvailability";
        ItemFomoState[ItemFomoState["TemporaryRepeatability"] = 2] = "TemporaryRepeatability";
        ItemFomoState[ItemFomoState["New"] = 3] = "New";
    })(ItemFomoState || (exports.ItemFomoState = ItemFomoState = {}));
    const WEAPON_BUCKET_HASHES = new Set([1498876634 /* InventoryBucketHashes.KineticWeapons */, 2465295065 /* InventoryBucketHashes.EnergyWeapons */, 953998645 /* InventoryBucketHashes.PowerWeapons */]);
    const ARMOUR_BUCKET_HASHES = new Set([3448274439 /* InventoryBucketHashes.Helmet */, 3551918588 /* InventoryBucketHashes.Gauntlets */, 14239492 /* InventoryBucketHashes.ChestArmor */, 20886954 /* InventoryBucketHashes.LegArmor */, 1585787867 /* InventoryBucketHashes.ClassArmor */]);
    var TransferType;
    (function (TransferType) {
        TransferType[TransferType["PullFromPostmaster"] = 0] = "PullFromPostmaster";
        TransferType[TransferType["TransferToVault"] = 1] = "TransferToVault";
        TransferType[TransferType["TransferToCharacterFromVault"] = 2] = "TransferToCharacterFromVault";
        TransferType[TransferType["Equip"] = 3] = "Equip";
        TransferType[TransferType["Unequip"] = 4] = "Unequip";
    })(TransferType || (TransferType = {}));
    const TRANSFERS = {
        [TransferType.PullFromPostmaster]: {
            applicable: item => item.bucket.is(215593132 /* InventoryBucketHashes.LostItems */)
                && !!item.bucket.characterId
                && !!item.definition.inventory?.bucketTypeHash,
            async transfer(item) {
                if (!this.applicable(item))
                    throw new Error("Not in postmaster bucket");
                const characterId = item.bucket.characterId;
                await PullFromPostmaster_1.default.query(item, characterId);
                return { bucket: Bucket_2.Bucket.id(item.definition.inventory.bucketTypeHash, characterId) };
            },
        },
        [TransferType.TransferToVault]: {
            applicable: (item, ifNotCharacter) => !!item.character && item.bucket.characterId !== ifNotCharacter && !!inventory?.getBucket(138197802 /* InventoryBucketHashes.General */),
            async transfer(item, ifNotCharacter) {
                if (!this.applicable(item, ifNotCharacter))
                    throw new Error("Not in character bucket");
                const characterId = item.character?.characterId;
                await TransferItem_1.default.query(item, characterId, "vault");
                return {
                    bucket: Bucket_2.Bucket.id(138197802 /* InventoryBucketHashes.General */),
                    undo: [TransferType.TransferToCharacterFromVault, characterId],
                };
            },
        },
        [TransferType.TransferToCharacterFromVault]: {
            applicable: (item, characterId, swapBucket) => item.bucket.isVault()
                && (inventory?.hasBucket(item.definition.inventory?.bucketTypeHash, characterId) ?? false),
            async transfer(item, characterId, swapBucket) {
                if (!this.applicable(item, characterId))
                    throw new Error("Not in vault bucket");
                const bucket = inventory?.getBucket(item.definition.inventory.bucketTypeHash, characterId);
                if (!bucket)
                    throw new Error("Not in a bucket");
                if (bucket.items.length >= (bucket.capacity ?? Infinity) && !await bucket.makeSpace(swapBucket))
                    throw new Error("Unable to make space");
                await TransferItem_1.default.query(item, characterId);
                return {
                    bucket: Bucket_2.Bucket.id(item.definition.inventory.bucketTypeHash, characterId),
                    undo: [TransferType.TransferToVault],
                };
            },
        },
        [TransferType.Equip]: {
            applicable: item => item.bucket.isCharacter() && !item.equipped,
            async transfer(item, characterId, equipItemId) {
                if (equipItemId) {
                    const equipItem = inventory?.getItem(equipItemId);
                    if (!equipItem)
                        throw new Error(`Could not find item ${equipItemId}`);
                    if (item === equipItem)
                        equipItemId = undefined;
                    item = equipItem;
                }
                if (!this.applicable(item, characterId))
                    throw new Error("Not in character bucket");
                if (item.isExotic()) {
                    const buckets = new Set(item.isWeapon() ? WEAPON_BUCKET_HASHES : item.isArmour() ? ARMOUR_BUCKET_HASHES : []);
                    buckets.delete(item.bucket.hash);
                    for (const bucketHash of buckets) {
                        const bucket = inventory?.getBucket(bucketHash, characterId);
                        if (!bucket)
                            continue;
                        if (bucket.equippedItem?.isExotic())
                            await bucket.equippedItem.unequip();
                    }
                }
                const currentlyEquippedItem = item.bucket.equippedItem;
                await EquipItem_1.default.query(item, characterId);
                return {
                    bucket: item.bucket.id,
                    equipped: equipItemId ? undefined : true,
                    undo: 
                    // there's another item that was equipped, re-equip it
                    currentlyEquippedItem ? [TransferType.Equip, characterId, currentlyEquippedItem.id]
                        // idk, unequip this item then i guess
                        : [TransferType.Unequip, equipItemId],
                    sideEffects: [
                        !currentlyEquippedItem ? undefined : {
                            item: currentlyEquippedItem,
                            result: {
                                bucket: item.bucket.id,
                            },
                        },
                        !equipItemId ? undefined : {
                            item,
                            result: {
                                bucket: item.bucket.id,
                                equipped: true,
                            },
                        },
                    ].filter(Arrays_5.default.filterNullish),
                };
            },
        },
        [TransferType.Unequip]: {
            applicable: item => item.bucket.isCharacter() && !!item.equipped,
            async transfer(item, unequipItemId) {
                if (unequipItemId) {
                    const unequipItem = inventory?.getItem(unequipItemId);
                    if (!unequipItem)
                        throw new Error(`Could not find item ${unequipItemId}`);
                    if (item === unequipItem)
                        unequipItemId = undefined;
                    item = unequipItem;
                }
                if (!this.applicable(item))
                    throw new Error("Not equipped in character bucket");
                const fallbackItem = item.fallbackItem;
                await item.unequip();
                return {
                    bucket: item.bucket.id,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                    undo: [TransferType.Equip, item.character?.characterId, unequipItemId],
                    sideEffects: [
                        !fallbackItem ? undefined : {
                            item: fallbackItem,
                            result: {
                                bucket: item.bucket.id,
                                equipped: true,
                            },
                        },
                        !unequipItemId ? undefined : {
                            item,
                            result: {
                                bucket: item.bucket.id,
                            },
                        },
                    ].filter(Arrays_5.default.filterNullish),
                };
            },
        },
    };
    class Item {
        static id(reference, occurrence) {
            return reference.itemInstanceId ?? `hash:${reference.itemHash}:${reference.bucketHash}:${occurrence}`;
        }
        static async resolve(manifest, profile, reference, bucket, occurrence, definition) {
            const { DestinyInventoryItemDefinition, DeepsightAdeptDefinition } = manifest;
            definition ??= await DestinyInventoryItemDefinition.get(reference.itemHash);
            if (!definition || !Object.keys(definition).length) {
                console.warn("No item definition for ", reference.itemHash);
                return undefined;
            }
            // if (definition.nonTransferrable && reference.bucketHash !== BucketHashes.LostItems && reference.bucketHash !== BucketHashes.Engrams) {
            // 	console.debug(`Skipping "${definition.displayProperties.name}", non-transferrable`);
            // 	return undefined;
            // }
            const init = {
                id: Item.id(reference, occurrence),
                reference,
                definition,
                bucket,
                instance: profile.itemComponents?.instances.data?.[reference.itemInstanceId],
                lastModified: profile.lastModified.getTime(),
            };
            await Promise.all([
                Promise.resolve(DeepsightAdeptDefinition.get(definition.hash))
                    .then(adept => DestinyInventoryItemDefinition.get(adept?.base))
                    .then(baseItem => Object.assign(init, { baseItem })),
                Moment_1.default.apply(manifest, init), // used for Into the Light plugs
                Tier_1.default.apply(manifest, init), // used for Into the Light deepsight
            ]);
            await Promise.all([
                Plugs_2.default.apply(manifest, profile, init),
                Stats_1.default.apply(manifest, profile, init),
                Deepsight_1.default.apply(manifest, profile, init),
                Collectibles_1.default.apply(manifest, profile, init),
                this.addCollections(manifest, profile, init),
                Perks_1.default.apply(manifest, profile, init),
                PowerCap_1.default.apply(manifest, init),
                Catalyst_1.default.apply(manifest, profile, init),
            ]);
            const item = new Item(init);
            if (item.isExotic())
                await item.getSocket("Masterwork/ExoticCatalyst")?.getPool();
            await BreakerType_1.default.apply(manifest, item);
            return item;
        }
        static async addCollections(manifest, profile, item) {
            item.collections = await Item.createFake(manifest, profile, item.definition);
        }
        static async createFake(manifest, profile, definition, source = true, instanceId) {
            const { DestinyInventoryItemDefinition, DeepsightAdeptDefinition } = manifest;
            const id = `hash:${definition.hash}:collections`;
            const existing = Bucket_2.Bucket.COLLECTIONS.getItemById(id);
            if (existing) {
                await Deepsight_1.default.apply(manifest, profile, existing);
                Collectibles_1.default.update(profile, existing);
                return existing;
            }
            const init = {
                id,
                reference: { itemHash: definition.hash, itemInstanceId: instanceId, quantity: 0, bindStatus: 0 /* ItemBindStatus.NotBound */, location: 0 /* ItemLocation.Unknown */, bucketHash: 138197802 /* InventoryBucketHashes.General */, transferStatus: 2 /* TransferStatuses.NotTransferrable */, lockable: false, state: 0 /* ItemState.None */, isWrapper: false, tooltipNotificationIndexes: [], metricObjective: { objectiveHash: -1, complete: false, visible: false, completionValue: 0 }, itemValueVisibility: [] },
                definition,
                bucket: Bucket_2.Bucket.COLLECTIONS,
                sockets: [],
                lastModified: Date.now(),
            };
            await Promise.all([
                Promise.resolve(DeepsightAdeptDefinition.get(definition.hash))
                    .then(adept => DestinyInventoryItemDefinition.get(adept?.base))
                    .then(baseItem => Object.assign(init, { baseItem })),
                Moment_1.default.apply(manifest, init), // used for Into the Light plugs
                Tier_1.default.apply(manifest, init), // used for Into the Light deepsight
            ]);
            await Deepsight_1.default.apply(manifest, profile, init); // pattern presence is used by plugs
            await Promise.all([
                Plugs_2.default.apply(manifest, profile, init),
                Stats_1.default.apply(manifest, profile, init),
                Collectibles_1.default.apply(manifest, profile, init),
                source && Source_1.default.apply(manifest, profile, init),
                PowerCap_1.default.apply(manifest, init),
                Catalyst_1.default.apply(manifest, profile, init),
            ]);
            const item = new Item(init);
            if (item.isExotic())
                await item.getSocket("Masterwork/ExoticCatalyst")?.getPool();
            await BreakerType_1.default.apply(manifest, item);
            return item;
        }
        get character() {
            return this.bucket.character;
        }
        /**
         * The character this item is in the inventory of, or the current character if the item is somewhere else
         */
        get owner() {
            return this.character ?? Characters_1.default.getCurrent();
        }
        get objectives() {
            return this.sockets.flatMap(socket => socket?.plugs?.flatMap(plug => plug.objectives) ?? []);
        }
        constructor(item) {
            this.event = new EventManager_10.EventManager(this);
            this.occurrence = 0;
            this.name = item.definition.displayProperties?.name;
            Object.assign(this, item);
            this.undoTransfers = [];
            this.collectibleState ??= 0 /* DestinyCollectibleState.None */;
            this.bucketIds = [];
        }
        isWeapon() {
            return this.definition.equippable
                && (this.definition.itemCategoryHashes?.includes(1 /* ItemCategoryHashes.Weapon */)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                    || WEAPON_BUCKET_HASHES.has(this.definition.inventory?.bucketTypeHash));
        }
        isArmour() {
            return this.definition.equippable
                && (this.definition.itemCategoryHashes?.includes(20 /* ItemCategoryHashes.Armor */)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                    || ARMOUR_BUCKET_HASHES.has(this.definition.inventory?.bucketTypeHash));
        }
        isExotic() {
            return this.tier?.hash === 2759499571 /* ItemTierTypeHashes.Exotic */;
        }
        isDummy() {
            return this.definition.itemCategoryHashes?.includes(3109687656 /* ItemCategoryHashes.Dummies */);
        }
        getDamageType() {
            return this.getSocketedPlug("=Subclass/Super")?.getCategorisationAs(4 /* DeepsightPlugCategory.Subclass */)?.damageType
                || (this.instance?.damageTypeHash ?? this.definition.defaultDamageTypeHash)
                || undefined;
        }
        hasRandomRolls() {
            return this.getSockets("Perk").some(socket => (socket.plugs?.length ?? 0) > 1);
        }
        isNotAcquired() {
            return this.bucket === Bucket_2.Bucket.COLLECTIONS
                && !!(this.collectibleState & 1 /* DestinyCollectibleState.NotAcquired */)
                && !this.deepsight?.pattern?.progress?.progress;
        }
        isMasterwork() {
            if (this.reference.state & 4 /* ItemState.Masterwork */)
                return true;
            if (this.instance && this.getSocketedPlug("Intrinsic/FrameEnhanced") && this.getSocketedPlugs("Perk/TraitEnhanced").length >= 2)
                return true;
            if (this.isExotic()) {
                const catalyst = this.getSocket("Masterwork/ExoticCatalyst");
                if (catalyst?.state && (!catalyst?.state?.isVisible || !catalyst?.getPool("!Masterwork/ExoticCatalystEmpty")?.length))
                    return true;
                if (this.isWeapon() && (!this.catalyst || this.catalyst?.complete) && this.bucket.isCollections() && !this.isNotAcquired())
                    return true;
            }
            if (this.definition.itemCategoryHashes?.includes(1378222069 /* ItemCategoryHashes.SeasonalArtifacts */))
                return true;
            return false;
        }
        isArtifice() {
            return !!this.getSocketedPlug("Intrinsic/ArmorArtifice");
        }
        isAdept() {
            return !!this.baseItem;
        }
        canEnhance() {
            return !!this.getSocket("Masterwork/Enhancement");
        }
        hasDeepsight() {
            const hasIncompletePattern = this.deepsight?.pattern?.record && !(this.deepsight.pattern.progress?.complete ?? false);
            return !this.deepsight?.resonance ? false : hasIncompletePattern;
        }
        hasPattern() {
            return this.bucket.isCollections()
                ? !!this.deepsight?.pattern?.record && !this.deepsight.pattern.progress?.complete
                : !!(this.deepsight?.resonance && this.deepsight?.pattern && !this.deepsight.pattern.progress?.complete);
        }
        canShape() {
            return this.deepsight?.pattern?.progress?.complete && !this.hasShapedCopy() || false;
        }
        hasShapedCopy() {
            return inventory?.isCrafted(this.definition.hash) ?? false;
        }
        getLoadouts() {
            return Object.values(Characters_1.default.all())
                .flatMap(character => character.loadouts
                .filter(loadout => loadout.items
                .some(item => item.itemInstanceId === this.id)));
        }
        canTransfer() {
            return ProfileManager_8.default.isAuthenticated()
                && (!this.bucket.is(215593132 /* InventoryBucketHashes.LostItems */) || !this.definition.doesPostmasterPullHaveSideEffects)
                && this.reference.bucketHash !== 375726501 /* InventoryBucketHashes.Engrams */;
        }
        isTierLessThan(tier, max) {
            return (this.tier?.tierType ?? 0) <= Math.min(tier ?? 0, max ?? 0);
        }
        isEngram() {
            return this.definition.inventory?.bucketTypeHash === 375726501 /* InventoryBucketHashes.Engrams */
                || this.definition.itemType === 8 /* DestinyItemType.Engram */;
        }
        getCollectionsRandomIntrinsics() {
            if (!this.bucket.isCollections())
                return undefined;
            const randomIntrinsics = {
                frames: this.getSocket("Intrinsic/Frame")?.plugs
                    ?.filter(plug => plug.isNot("Intrinsic/EmptyCraftingSocket"))
                    .distinct(plug => plug.definition?.displayProperties.name),
                exotics: this.getSocket("Intrinsic/Exotic")?.plugs,
            };
            if ((randomIntrinsics.exotics?.length ?? 0) < 2 && (randomIntrinsics.frames?.length ?? 0) < 2)
                return undefined;
            return randomIntrinsics;
        }
        getPower(onlyPower = false) {
            const statHash = this.instance?.primaryStat?.statHash;
            const isValidStat = statHash === 1935470627 /* StatHashes.Power */
                || statHash === 1480404414 /* StatHashes.Attack */
                || statHash === 3897883278 /* StatHashes.Defense */
                || (!onlyPower && statHash === 1501155019 /* StatHashes.Speed */);
            if (!isValidStat) {
                if (this.isWeapon() || this.isArmour())
                    return this.bucket.isCollections() ? DeepsightStats_1.default.get()?.powerFloor ?? 0 : 0;
                return undefined;
            }
            const primaryStatPower = isValidStat ? this.instance.primaryStat.value : 0;
            const itemLevelQualityPower = (this.instance?.itemLevel ?? 0) * 10 + (this.instance?.quality ?? 0);
            if (this.isEngram())
                return Math.max(primaryStatPower, itemLevelQualityPower);
            return primaryStatPower;
        }
        isSunset() {
            const powerpower = this.getPower(true);
            const powerCap = powerpower === undefined ? undefined : this.powerCap;
            return powerpower !== undefined && (powerCap?.powerCap ?? 0) < 900000;
        }
        isSame(item) {
            return this.id === item.id;
        }
        getSockets(...anyOfTypes) {
            return Plugs_2.Socket.filterType(this.sockets, ...anyOfTypes);
        }
        getSocket(...anyOfTypes) {
            return this.getSockets(...anyOfTypes)[0];
        }
        getSocketedPlugs(...anyOfTypes) {
            return Plugs_2.Socket.filterByPlugs(this.sockets, ...anyOfTypes)
                .filter(socket => socket.socketedPlug.is(...anyOfTypes))
                .map(socket => socket.socketedPlug);
        }
        getSocketedPlug(...anyOfTypes) {
            return this.getSocketedPlugs(...anyOfTypes)[0];
        }
        getOrnament() {
            if (this.bucket.isCollections() && this.isWeapon() && this.moment?.hash === 34 /* MomentHashes.IntoTheLight */) {
                const ornament = this.getSocket("Cosmetic/Ornament")
                    ?.getPlugs()
                    ?.find(ornament => ornament.definition?.displayProperties.name.includes("BRAVE"));
                if (ornament)
                    return ornament;
            }
            return this.getSocketedPlug("Cosmetic/OrnamentArmor", "Cosmetic/OrnamentWeapon", "Cosmetic/OrnamentMask");
        }
        /**
         * Some items are only very rarely available, such as adept raid weapons. Do you have the fomo? You should!
         */
        isFomo() {
            if (!this.bucket.isCollections())
                return ItemFomoState.NoMo;
            const hash = this.definition.hash;
            for (const source of this.sources ?? []) {
                if (source.dropTable.dropTable?.[hash] || source.dropTable.encounters?.some(encounter => encounter.dropTable?.[hash])) {
                    if (source.dropTable.availability === "new")
                        return ItemFomoState.New;
                    else if (source.dropTable.availability)
                        return ItemFomoState.TemporaryRepeatability;
                    // always available in specific encounters
                    continue;
                }
                if (source.isActiveMasterDrop || source.isActiveDrop)
                    return ItemFomoState.TemporaryAvailability;
            }
            return ItemFomoState.NoMo;
        }
        getBaseName() {
            return this.baseItem?.displayProperties.name ?? this.definition.displayProperties.name;
        }
        isLocked() {
            return !!(this.reference.state & 1 /* ItemState.Locked */);
        }
        isChangingLockState() {
            return !!this.settingLocked;
        }
        async setLocked(locked = true) {
            if (this.bucket === Bucket_2.Bucket.COLLECTIONS)
                return false;
            if (!ProfileManager_8.default.isAuthenticated())
                return false;
            await this.settingLocked;
            if (this.isLocked() !== locked) {
                this.settingLocked = (async () => {
                    let err;
                    await SetLockState_1.default.query(this, locked).catch((e) => err = e);
                    if (err)
                        return;
                    StateLock_1.default.add({
                        type: "item/lock",
                        time: Date.now(),
                        item: this.id,
                        locked,
                    });
                    const mutable = this.reference;
                    if (locked)
                        mutable.state |= 1 /* ItemState.Locked */;
                    else
                        mutable.state &= ~1 /* ItemState.Locked */;
                })();
                await this.refresh();
                await this.settingLocked;
                delete this.settingLocked;
                await this.refresh();
            }
            return locked;
        }
        async refresh(manifest, profile = ProfileBatch_4.default.latest, itemRef = this.reference, occurrence = this.occurrence) {
            manifest ??= await Manifest_7.default.await();
            this.lastModified = profile?.lastModified.getTime() ?? 0;
            this.reference = itemRef;
            this.occurrence = occurrence;
            this.instance = profile?.itemComponents?.instances.data?.[itemRef.itemInstanceId];
            await Plugs_2.default.refresh(manifest, profile, this);
            // moment should be ok
            await Deepsight_1.default.apply(manifest, profile ?? {}, this); // includes shaped
            await Stats_1.default.apply(manifest, profile, this);
            this.event.emit("update", { item: this });
        }
        get transferring() {
            return !!this._transferPromise;
        }
        async transferrable() {
            while (this._transferPromise)
                await this._transferPromise;
        }
        async transferToBucket(bucket) {
            // if (bucket.is(InventoryBucketHashes.Consumables) || bucket.is(InventoryBucketHashes.Modifications))
            // 	throw new Error("Inventory transfer not implemented yet");
            if (bucket.is(138197802 /* InventoryBucketHashes.General */))
                return this.transferToVault();
            if (!bucket.characterId) {
                console.warn("Transfer type not implemented", bucket);
                return;
            }
            return this.transferToCharacter(bucket.characterId);
        }
        async transferToCharacter(character) {
            if (this.bucket.isCharacter(character))
                return;
            return this.transfer(TransferType.PullFromPostmaster, [TransferType.Unequip], ...this.bucket.isCharacter() ? [Arrays_5.default.tuple(TransferType.TransferToVault)] : [], [TransferType.TransferToCharacterFromVault, character, this.bucket]);
        }
        transferToVault() {
            return this.transfer(TransferType.PullFromPostmaster, [TransferType.Unequip], [TransferType.TransferToVault]);
        }
        transferToggleVaulted(character) {
            if (this.bucket.is(138197802 /* InventoryBucketHashes.General */))
                return this.transferToCharacter(character);
            else
                return this.transferToVault();
        }
        async equip(character) {
            if (this.bucket.isCharacter(character) && this.equipped)
                return;
            return this.transfer(TransferType.PullFromPostmaster, [TransferType.Unequip], [TransferType.TransferToVault, character], [TransferType.TransferToCharacterFromVault, character, this.bucket], [TransferType.Equip, character]);
        }
        async unequip() {
            await this.transferrable();
            if (!this.character || !this.fallbackItem) {
                // TODO notify
            }
            else {
                this.event.emit("loadStart");
                this._transferPromise = this.fallbackItem.equip(this.character.characterId);
                await this._transferPromise;
                delete this._transferPromise;
                this.event.emit("loadEnd");
            }
        }
        pullFromPostmaster() {
            return this.transfer(TransferType.PullFromPostmaster);
        }
        async transfer(...transfers) {
            if (!ProfileManager_8.default.isAuthenticated())
                return;
            await this.transferrable();
            this.event.emit("loadStart");
            this._transferPromise = this.performTransfer(...transfers);
            await this._transferPromise;
            delete this._transferPromise;
            this.event.emit("loadEnd");
        }
        async performTransfer(...transfers) {
            this.undoTransfers.splice(0, Infinity);
            for (let transfer of transfers) {
                transfer = Array.isArray(transfer) ? transfer : [transfer];
                const [type, ...args] = transfer;
                const definition = TRANSFERS[type];
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
                if (!definition.applicable(this, ...args))
                    continue;
                try {
                    const result = await definition.transfer(this, ...args);
                    const sideEffects = [{ item: this, result }, ...result.sideEffects ?? []]; // includes main effect
                    const pendingEmits = [];
                    for (const { item, result } of sideEffects) {
                        const fromBucket = item.bucket;
                        const fromEquipped = !!item.equipped;
                        const toBucket = inventory?.getBucket(result.bucket);
                        if (!toBucket)
                            console.warn("Missing bucket", result.bucket, "for item after transfer", item);
                        pendingEmits.push({ item, oldBucket: fromBucket, equipped: result.equipped });
                        if (toBucket) {
                            console.log("Transferred", item.name, "from", fromBucket.name, fromEquipped ? "equipped" : "unequipped", "to", toBucket.name, result.equipped ? "equipped" : "unequipped");
                            StateItemTransfer_1.default.add({
                                type: "item/transfer",
                                time: Date.now(),
                                item: item.id,
                                fromBucket: fromBucket.id,
                                fromEquipped,
                                toBucket: toBucket.id,
                                toEquipped: !!result.equipped,
                            });
                        }
                    }
                    if (result.undo)
                        this.undoTransfers.push(result.undo);
                    else
                        this.undoTransfers.splice(0, Infinity);
                }
                catch (error) {
                    console.error(error);
                    if (!Store_8.default.items.settingsDisableReturnOnFailure)
                        await this.performTransfer(...this.undoTransfers.reverse());
                }
                await inventory.refreshing;
            }
        }
        hasWishlist() {
            const wishlists = Store_8.default.items[`item${this.baseItem?.hash ?? this.definition.hash}PerkWishlists`];
            return !!wishlists && wishlists.length > 0;
        }
        getWishlistChance() {
            const wishlists = Store_8.default.items[`item${this.baseItem?.hash ?? this.definition.hash}PerkWishlists`];
            if (!wishlists)
                return 1;
            if (!wishlists.length)
                return 0;
            let notWishlistedChance = 1;
            for (const wishlist of wishlists) {
                let wishlistChance = 1;
                for (const socket of this.collections?.sockets ?? this.sockets) {
                    const socketPoolSize = socket?.plugs?.filter(plug => !plug.is("Perk/TraitEnhanced")).length ?? 0;
                    const wishlistPoolSize = socket?.plugs?.filter(plug => wishlist.plugs.includes(plug.plugItemHash)).length ?? 0;
                    if (wishlistPoolSize)
                        wishlistChance *= wishlistPoolSize / socketPoolSize;
                }
                notWishlistedChance *= 1 - wishlistChance;
            }
            return 1 - notWishlistedChance;
        }
        /**
         * @returns undefined if there are no wishlists for this item, true if a wishlist matches, false otherwise
         */
        async isWishlisted() {
            const wishlists = Store_8.default.items[`item${this.baseItem?.hash ?? this.definition.hash}PerkWishlists`];
            if (wishlists?.length === 0)
                // the user doesn't want any roll of this item
                return false;
            if (!wishlists)
                // the user hasn't configured wishlists for this item
                return undefined;
            for (const wishlist of Store_8.default.items[`item${this.baseItem?.hash ?? this.definition.hash}PerkWishlists`] ?? [])
                if (await this.checkMatchesWishlist(wishlist))
                    // all sockets match this wishlist!
                    return true;
            // none of the wishlists matched
            return false;
        }
        /**
         * @returns `undefined` if there are no wishlists for this item, `false` if the user doesn't want this item at all,
         * and an array with matching wishlists otherwise
         */
        async getMatchingWishlists() {
            const wishlists = Store_8.default.items[`item${this.baseItem?.hash ?? this.definition.hash}PerkWishlists`];
            if (!wishlists)
                return undefined;
            if (!wishlists.length)
                return false;
            const matchingWishlists = [];
            for (const wishlist of wishlists)
                if (await this.checkMatchesWishlist(wishlist))
                    matchingWishlists.push(wishlist);
            return matchingWishlists;
        }
        async checkMatchesWishlist(wishlist) {
            for (const socket of this.sockets) {
                const pool = await socket?.getPool();
                if (pool?.some(plug => wishlist.plugs.includes(plug.plugItemHash))) {
                    // the full pool for this socket contains a wishlisted plug
                    if (!socket?.plugs?.some(plug => wishlist.plugs.includes(plug.plugItemHash))) {
                        // but the available plugs on this socket don't
                        return false;
                    }
                }
            }
            return true;
        }
        getStatTracker() {
            for (const socket of this.sockets) {
                if (!socket?.socketedPlug?.is("Cosmetic/Tracker"))
                    continue;
                for (const objective of socket.socketedPlug.objectives) {
                    if (!objective.progress.visible)
                        continue;
                    return objective;
                }
            }
        }
    }
    exports.default = Item;
    Object.assign(window, { Item });
});
define("model/models/items/Bucket", ["require", "exports", "model/models/Characters", "utility/Arrays"], function (require, exports, Characters_2, Arrays_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionsBucket = exports.Bucket = void 0;
    class Bucket {
        static id(bucketHash, characterId, inventoryBucketHash) {
            return `${bucketHash}/${characterId || ""}/${inventoryBucketHash || ""}`;
        }
        static rootId(id) {
            const [bucket, character] = Bucket.parseId(id);
            return Bucket.id(bucket, character);
        }
        static parseId(id) {
            const [bucketHashString, characterString, inventoryBucketHashString] = id.split(/\//g);
            return [
                bucketHashString === "collections" ? "collections" : +bucketHashString,
                characterString || undefined,
                +inventoryBucketHashString || undefined,
            ];
        }
        static create(definition) {
            if (!definition.definition)
                return undefined;
            return new Bucket(definition);
        }
        get character() {
            return Characters_2.default.get(this.characterId);
        }
        constructor({ definition, subBucketDefinition, character, items }) {
            this.name = definition.displayProperties?.name ?? "?";
            this.id = Bucket.id(definition.hash, character?.characterId, subBucketDefinition?.hash);
            this.capacity = definition.itemCount;
            this.items = [];
            this.map = {};
            if (items)
                this.addItems(...items);
            this.hash = definition.hash;
            this.inventoryHash = subBucketDefinition?.hash;
            this.characterId = character?.characterId;
            this.definition = definition;
            this.subBucketDefinition = subBucketDefinition;
            if (character)
                this.name += ` / ${character.class.displayProperties.name}`;
            if (this.inventoryHash)
                this.name += ` / ${subBucketDefinition?.displayProperties?.name ?? "?"}`;
        }
        isSubBucketOf(bucket) {
            if (bucket === this)
                return false;
            const [hash, character] = Bucket.parseId(bucket.id);
            if (this.hash === hash && this.characterId === character)
                return true;
            return false;
        }
        getItemById(id) {
            return this.items[this.map[id]];
        }
        addItems(...items) {
            for (const item of items) {
                if (this.map[item.id] !== undefined)
                    continue;
                this.map[item.id] = this.items.length;
                this.items.push(item);
            }
        }
        removeItems(...items) {
            const mutable = this.items;
            for (const item of items) {
                const removeIndex = this.map[item.id];
                if (removeIndex === undefined)
                    continue;
                delete this.map[item.id];
                const lastItem = mutable.pop();
                if (removeIndex !== mutable.length) {
                    mutable[removeIndex] = lastItem;
                    this.map[lastItem.id] = removeIndex;
                }
            }
        }
        get equippedItem() {
            return this.items.find(item => item.equipped);
        }
        is(hash) {
            return this.hash === hash;
        }
        isCollections() {
            return this.id.startsWith("collections");
        }
        isVault() {
            return this.is(138197802 /* InventoryBucketHashes.General */);
        }
        isCharacter(character) {
            return character === undefined ? !!this.characterId : this.characterId === character;
        }
        isPostmaster() {
            return this.is(215593132 /* InventoryBucketHashes.LostItems */);
        }
        isEngrams() {
            return this.is(375726501 /* InventoryBucketHashes.Engrams */);
        }
        async makeSpace(swapBucket) {
            if (!this.fallbackRemovalItem)
                return false;
            if (swapBucket)
                return this.fallbackRemovalItem.transferToBucket(swapBucket).then(() => true).catch(() => false);
            return this.fallbackRemovalItem.transferToVault().then(() => true).catch(() => false);
        }
        matches(item) {
            if (item.bucket === this)
                return true;
            if (this.inventoryHash)
                return item.bucket.hash === this.definition.hash && item.definition.inventory?.bucketTypeHash === this.inventoryHash;
            return false
                || item.bucket.hash === this.definition.hash
                || item.definition.inventory?.bucketTypeHash === this.definition.hash;
        }
    }
    exports.Bucket = Bucket;
    class CollectionsBucket extends Bucket {
        constructor() {
            super(...arguments);
            this.subBuckets = {};
        }
        getItemsInSubBucket(bucketHash) {
            return this.subBuckets[bucketHash]?.map(index => this.items[index]) ?? [];
        }
        addItems(...items) {
            super.addItems(...items);
            for (const item of items) {
                const subBucketHash = item.definition.inventory?.bucketTypeHash;
                if (subBucketHash === undefined)
                    continue;
                const subBucket = this.subBuckets[subBucketHash] ??= [];
                const index = this.map[item.id];
                if (!subBucket.includes(index))
                    subBucket.push(index);
            }
        }
        removeItems(...items) {
            for (const item of items) {
                const subBucketHash = item.definition.inventory?.bucketTypeHash;
                if (subBucketHash === undefined)
                    continue;
                const subBucket = this.subBuckets[subBucketHash];
                if (!subBucket)
                    continue;
                const index = this.map[item.id];
                Arrays_6.default.removeSwap(subBucket, index);
            }
            super.removeItems(...items);
            for (const item of items) {
                const subBucketHash = item.definition.inventory?.bucketTypeHash;
                if (subBucketHash === undefined)
                    continue;
                const subBucket = this.subBuckets[subBucketHash];
                if (!subBucket)
                    continue;
                const index = this.map[item.id];
                if (index === undefined)
                    continue;
                subBucket.push(index);
            }
        }
    }
    exports.CollectionsBucket = CollectionsBucket;
    Bucket.COLLECTIONS = new CollectionsBucket({
        definition: {
            hash: "collections",
            displayProperties: {
                name: "Collections",
            },
        },
    });
});
define("ui/utility/FocusManager", ["require", "exports", "ui/component/Component", "utility/EventManager", "utility/decorator/Bound"], function (require, exports, Component_4, EventManager_11, Bound_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FocusManagerImpl {
        get focused() {
            return this._focused;
        }
        get hovered() {
            return this._focused;
        }
        get active() {
            return this._focused || this._hovered;
        }
        constructor() {
            this.event = EventManager_11.EventManager.make();
            this._focused = false;
            this._hovered = false;
            this.onPageFocus();
            window.addEventListener("focus", this.onPageFocus);
            window.addEventListener("blur", this.onPageBlur);
            window.addEventListener("mouseover", this.onPageMouseEnter);
            window.addEventListener("mouseout", this.onPageMouseLeave);
        }
        onPageFocus() {
            if (this._focused)
                return;
            this._focused = true;
            document.documentElement.classList.add("focused");
            this.event.emit("focus");
            this.event.emit("changeFocusState", { focused: true });
            if (!this._hovered) {
                document.documentElement.classList.remove("inactive");
                document.documentElement.classList.add("active");
                this.event.emit("active");
                this.event.emit("changeActiveState", { active: true });
            }
        }
        onPageBlur() {
            if (!this._focused)
                return;
            this._focused = false;
            document.documentElement.classList.remove("focused");
            this.event.emit("blur");
            this.event.emit("changeFocusState", { focused: false });
            if (!this._hovered) {
                document.documentElement.classList.remove("active");
                document.documentElement.classList.add("inactive");
                this.event.emit("inactive");
                this.event.emit("changeActiveState", { active: false });
            }
        }
        onPageMouseEnter() {
            if (this._hovered)
                return;
            this._hovered = true;
            document.documentElement.classList.add("hovered");
            this.event.emit("mouseenter");
            this.event.emit("changeHoverState", { hovered: true });
            if (!this._focused) {
                document.documentElement.classList.remove("inactive");
                document.documentElement.classList.add("active");
                this.event.emit("active");
                this.event.emit("changeActiveState", { active: true });
            }
        }
        onPageMouseLeave(event) {
            if (!this._hovered)
                return;
            const outside = event.clientX < 0 || event.clientX > Component_4.default.window.width
                || event.clientY < 0 || event.clientY > Component_4.default.window.height;
            if (!outside)
                return;
            this._hovered = false;
            document.documentElement.classList.remove("hovered");
            this.event.emit("mouseleave");
            this.event.emit("changeHoverState", { hovered: false });
            if (!this._focused) {
                document.documentElement.classList.remove("active");
                document.documentElement.classList.add("inactive");
                this.event.emit("inactive");
                this.event.emit("changeActiveState", { active: false });
            }
        }
    }
    __decorate([
        Bound_4.default
    ], FocusManagerImpl.prototype, "onPageFocus", null);
    __decorate([
        Bound_4.default
    ], FocusManagerImpl.prototype, "onPageBlur", null);
    __decorate([
        Bound_4.default
    ], FocusManagerImpl.prototype, "onPageMouseEnter", null);
    __decorate([
        Bound_4.default
    ], FocusManagerImpl.prototype, "onPageMouseLeave", null);
    const FocusManager = new FocusManagerImpl();
    exports.default = FocusManager;
});
define("model/models/Inventory", ["require", "exports", "model/Model", "model/models/Characters", "model/models/Manifest", "model/models/ProfileBatch", "model/models/items/Bucket", "model/models/items/Item", "model/models/state/IStateModification", "ui/utility/FocusManager", "utility/Async", "utility/EventManager", "utility/Time", "utility/decorator/Bound"], function (require, exports, Model_10, Characters_3, Manifest_8, ProfileBatch_5, Bucket_3, Item_1, IStateModification_4, FocusManager_1, Async_2, EventManager_12, Time_6, Bound_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Inventory {
        static createModel() {
            return Model_10.default.createTemporary(async (api) => {
                const profilePromise = Inventory.INSTANCE.queueProfileRefresh(api, 1 / 2);
                if (!ProfileBatch_5.default.latest)
                    await profilePromise;
                if (!Inventory.INSTANCE.hadInitialLoad)
                    await Inventory.INSTANCE.await(api, 1 / 2, 1 / 2);
                return Inventory.INSTANCE;
            });
        }
        static await(api, amount, from) {
            return Inventory.createModel().await(api, amount, from);
        }
        constructor() {
            this.event = new EventManager_12.EventManager(this);
            this.items = {};
            this.buckets = {};
            this.craftedItems = new Set();
            this.hadInitialLoad = false;
            this.refreshWatchers = [];
            this.refreshQueued = false;
            ProfileBatch_5.default.event.subscribe("loaded", this.onProfileUpdate);
            IStateModification_4.default.event.subscribe("apply", this.onProfileUpdate);
            Characters_3.default.event.subscribe("loaded", this.onCharactersLoaded);
            if (FocusManager_1.default.focused)
                this.onPageFocusChange(FocusManager_1.default);
            FocusManager_1.default.event.subscribe("changeFocusState", this.onPageFocusChange);
        }
        getItem(item) {
            return this.items[item];
        }
        getItems(filter) {
            const items = Object.values(this.items)
                .filter((item) => !!item && !item.bucket.isCollections());
            return filter ? items.filter(filter) : items;
        }
        isCrafted(item) {
            return this.craftedItems.has(item);
        }
        hasBucket(bucket, character, subBucket) {
            if (typeof bucket === "number")
                bucket = Bucket_3.Bucket.id(bucket, character, subBucket);
            return !!this.buckets[bucket];
        }
        getBucket(bucket, character, subBucket) {
            if (typeof bucket === "number")
                bucket = Bucket_3.Bucket.id(bucket, character, subBucket);
            return this.buckets[bucket];
        }
        getBuckets() {
            return Object.values(this.buckets)
                .filter((bucket) => !!bucket);
        }
        getBucketsOfType(bucketHash) {
            return Object.values(this.buckets)
                .filter((bucket) => bucket?.hash === bucketHash);
        }
        getCharacterBuckets(characterId) {
            return Object.values(this.buckets)
                .filter((bucket) => bucket?.characterId === characterId);
        }
        async queueProfileRefresh(api, amount = 1, from = 0) {
            await ProfileBatch_5.default.await(api, amount, from);
        }
        async await(api, amount = 1, from = 0) {
            if (!this.refreshPromise || this.hadInitialLoad)
                return;
            if (api)
                this.refreshWatchers.push({ api, amount, from });
            await this.refreshPromise;
        }
        get refreshing() {
            return this.refreshPromise;
        }
        async refresh(api, amount = 1, from = 0) {
            if (api)
                this.refreshWatchers.push({ api, amount, from });
            const manifest = await Manifest_8.default.await(api, amount * (1 / 4), from + amount * (0 / 4));
            const { DeepsightCollectionsDefinition, DeepsightMomentDefinition, DestinyInventoryItemDefinition, DeepsightSocketExtendedDefinition, DeepsightDropTableDefinition, DestinyActivityDefinition, DestinyInventoryBucketDefinition } = manifest;
            for (const { api, from, amount } of this.refreshWatchers)
                api.emitProgress(from + amount * (1 / 4) + amount * (1 / 4) * (0 / 5), "Loading drop tables");
            await DeepsightDropTableDefinition.all();
            for (const { api, from, amount } of this.refreshWatchers)
                api.emitProgress(from + amount * (1 / 4) + amount * (1 / 4) * (1 / 5), "Loading extended socket data");
            await DeepsightSocketExtendedDefinition.all();
            for (const { api, from, amount } of this.refreshWatchers)
                api.emitProgress(from + amount * (1 / 4) + amount * (1 / 4) * (2 / 5), "Loading activities");
            await DestinyActivityDefinition.all();
            for (const { api, from, amount } of this.refreshWatchers)
                api.emitProgress(from + amount * (1 / 4) + amount * (1 / 4) * (3 / 5), "Loading moments");
            const moments = await DeepsightMomentDefinition.all();
            for (const { api, from, amount } of this.refreshWatchers)
                api.emitProgress(from + amount * (1 / 4) + amount * (1 / 4) * (4 / 5), "Loading collections");
            const collections = await DeepsightCollectionsDefinition.all();
            let lastForcedTimeoutForStyle = Date.now();
            const profile = ProfileBatch_5.default.latest;
            let refreshedItems = 0;
            const totalItems = 0
                + (profile.profileInventory?.data?.items.length ?? 0)
                + (Object.values(profile.characterInventories?.data ?? {}).flatMap(character => character.items).length);
            const classTypes = Characters_3.default.getSortedClasses()
                .concat(0 /* DestinyClass.Titan */, 1 /* DestinyClass.Hunter */, 2 /* DestinyClass.Warlock */)
                .distinct();
            this.craftedItems.clear();
            const encountered = new Set();
            const refreshItem = async (itemRef, characterId, equipped) => {
                refreshedItems++;
                for (const { api, from, amount } of this.refreshWatchers) {
                    const fromItems = from + amount * (2 / 4);
                    const amountItems = amount * (1 / 4);
                    api.emitProgress(fromItems + amountItems * (refreshedItems / totalItems), `Loading items ${refreshedItems} / ${totalItems}`);
                }
                if (Date.now() - lastForcedTimeoutForStyle > 40) {
                    await Async_2.default.sleep(0);
                    lastForcedTimeoutForStyle = Date.now();
                }
                const genericBucketId = Bucket_3.Bucket.id(itemRef.bucketHash);
                const genericBucket = this.buckets[genericBucketId] ??= Bucket_3.Bucket.create({
                    definition: await DestinyInventoryBucketDefinition.get(itemRef.bucketHash),
                });
                if (!genericBucket) {
                    unknownBuckets.push(itemRef);
                    return;
                }
                occurrences[itemRef.itemHash] ??= 0;
                const occurrence = occurrences[itemRef.itemHash]++;
                const itemId = Item_1.default.id(itemRef, occurrence);
                encountered.add(itemId);
                let item = this.items[itemId];
                if (!item) {
                    const definition = await DestinyInventoryItemDefinition.get(itemRef.itemHash);
                    if (!definition)
                        return;
                    item = await Item_1.default.resolve(manifest, profile, itemRef, genericBucket, occurrence, definition);
                    if (!item)
                        return;
                }
                this.items[itemId] = item;
                item.equipped = equipped;
                const bucketIds = [genericBucketId];
                const characterBucketId = characterId ? Bucket_3.Bucket.id(itemRef.bucketHash, characterId) : undefined;
                if (characterBucketId)
                    bucketIds.push(characterBucketId);
                const subBucketHash = item.definition.inventory?.bucketTypeHash;
                if (subBucketHash !== itemRef.bucketHash) {
                    const subBucketId = item.definition.inventory?.bucketTypeHash ? Bucket_3.Bucket.id(itemRef.bucketHash, characterId, subBucketHash) : undefined;
                    if (subBucketId)
                        bucketIds.push(subBucketId);
                }
                if (!characterId) {
                    for (const classType of classTypes) {
                        if (item.definition.classType === undefined || item.definition.classType === 3 /* DestinyClass.Unknown */)
                            continue;
                        const itemClassType = item.definition.classType;
                        if (itemClassType !== undefined && itemClassType !== 3 /* DestinyClass.Unknown */ && itemClassType !== classType)
                            // don't add this item to a bucket of this class type, its restricted to another class type
                            continue;
                        const characters = Characters_3.default.byClassType(classType);
                        for (const character of characters) {
                            const characterId = character.characterId;
                            bucketIds.push(Bucket_3.Bucket.id(itemRef.bucketHash, characterId));
                            const subBucketHash = item.definition.inventory?.bucketTypeHash;
                            if (subBucketHash !== itemRef.bucketHash) {
                                const subBucketId = item.definition.inventory?.bucketTypeHash ? Bucket_3.Bucket.id(itemRef.bucketHash, characterId, subBucketHash) : undefined;
                                if (subBucketId)
                                    bucketIds.push(subBucketId);
                            }
                        }
                    }
                }
                const oldBucketIds = item.bucketIds;
                item.bucketIds = [];
                for (const bucketId of bucketIds) {
                    const [, characterId, subBucketType] = Bucket_3.Bucket.parseId(bucketId);
                    const character = Characters_3.default.get(characterId);
                    if (characterId && !character) {
                        console.warn("Unknown character", characterId);
                        continue;
                    }
                    const bucket = this.buckets[bucketId] ??= Bucket_3.Bucket.create({
                        definition: await DestinyInventoryBucketDefinition.get(itemRef.bucketHash),
                        character,
                        subBucketDefinition: await DestinyInventoryBucketDefinition.get(subBucketType),
                    });
                    if (!bucket)
                        continue;
                    item.bucketIds.push(bucketId);
                }
                for (const bucketId of oldBucketIds)
                    if (!item.bucketIds.includes(bucketId))
                        this.buckets[bucketId]?.removeItems(item);
                item.bucket = this.buckets[characterBucketId] ?? this.buckets[genericBucketId];
                if (!item.bucket) {
                    console.warn("Item was not bucketed", item);
                    delete this.items[item.id];
                    return;
                }
                for (const bucketId of item.bucketIds)
                    if (!oldBucketIds.includes(bucketId))
                        this.buckets[bucketId]?.addItems(item);
                await item.refresh(manifest, profile, itemRef, occurrence);
                if (item.shaped && item.deepsight?.pattern?.recipe && !item.isAdept())
                    this.craftedItems.add(item.definition.hash);
                return item;
            };
            const unknownBuckets = [];
            const occurrences = {};
            for (const itemRef of profile.profileInventory?.data?.items ?? [])
                await refreshItem(itemRef);
            for (const [characterId, characterData] of Object.entries(profile.characterInventories?.data ?? {}))
                for (const itemRef of characterData.items)
                    await refreshItem(itemRef, characterId);
            for (const [characterId, characterData] of Object.entries(profile.characterEquipment?.data ?? {}))
                for (const itemRef of characterData.items)
                    await refreshItem(itemRef, characterId, true);
            ////////////////////////////////////
            // Add collections bucket
            this.buckets["collections//"] = Bucket_3.Bucket.COLLECTIONS;
            for (const { api, from, amount } of this.refreshWatchers)
                api.emitProgress(from + amount * (3 / 4), "Loading collections");
            const collectionsBucketHashes = this.hadInitialLoad ? undefined : new Set();
            const totalItemsToInit = this.hadInitialLoad ? 0 : collections.flatMap(moment => Object.values(moment.buckets)).flat().length;
            let initItems = 0;
            for (const moment of collections) {
                for (const [bucketId, itemHashes] of Object.entries(moment.buckets)) {
                    collectionsBucketHashes?.add(+bucketId);
                    const momentName = this.hadInitialLoad ? undefined : moments.find(m => m.hash === moment.hash)?.displayProperties.name;
                    for (const hash of itemHashes) {
                        if (Date.now() - lastForcedTimeoutForStyle > 40) {
                            await Async_2.default.sleep(0);
                            lastForcedTimeoutForStyle = Date.now();
                        }
                        if (!this.hadInitialLoad) {
                            initItems++;
                            for (const { api, from, amount } of this.refreshWatchers)
                                api.emitProgress(from + amount * (3 / 4) + (1 / 4) * (initItems / totalItemsToInit), [
                                    `Loading collections ${initItems} / ${totalItemsToInit}`,
                                    ...momentName ? [momentName] : [],
                                ]);
                        }
                        const id = `hash:${hash}:collections`;
                        let item = this.items[id];
                        if (!item) {
                            const definition = await DestinyInventoryItemDefinition.get(hash);
                            if (!definition)
                                continue;
                            item = await Item_1.default.createFake(manifest, profile, definition);
                            Bucket_3.Bucket.COLLECTIONS.addItems(item);
                            this.items[id] = item;
                            encountered.add(id);
                        }
                        await item.refresh(manifest, profile);
                    }
                }
            }
            if (collectionsBucketHashes)
                for (const subBucketHash of collectionsBucketHashes)
                    this.buckets[`collections//${subBucketHash}`] ??= new Bucket_3.Bucket({
                        definition: Bucket_3.Bucket.COLLECTIONS.definition,
                        subBucketDefinition: await manifest.DestinyInventoryBucketDefinition.get(subBucketHash),
                        items: Bucket_3.Bucket.COLLECTIONS.getItemsInSubBucket(subBucketHash),
                    });
            for (const [itemId, item] of Object.entries(this.items))
                if (item && !encountered.has(itemId)) {
                    for (const bucketId of item.bucketIds)
                        this.buckets[bucketId]?.removeItems(item);
                    delete this.items[itemId];
                }
            this.event.emit("update");
            delete this.refreshPromise;
            this.hadInitialLoad = true;
        }
        async onProfileUpdate() {
            if (this.refreshQueued)
                return;
            this.refreshQueued = true;
            while (this.refreshPromise)
                await this.refreshPromise;
            this.refreshQueued = false;
            this.refreshPromise = this.refresh();
        }
        onCharactersLoaded({ characters, sorted }) {
            for (const character of sorted)
                for (const loadout of character.loadouts)
                    loadout.setInventory(this);
        }
        onPageFocusChange({ focused }) {
            if (focused)
                void this.queueProfileRefresh();
            clearInterval(this.interval);
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            this.interval = window.setInterval(this.queueProfileRefresh, focused ? Time_6.default.seconds(1) : Time_6.default.minutes(2));
        }
    }
    exports.default = Inventory;
    __decorate([
        Bound_5.default
    ], Inventory.prototype, "refresh", null);
    __decorate([
        Bound_5.default
    ], Inventory.prototype, "onProfileUpdate", null);
    __decorate([
        Bound_5.default
    ], Inventory.prototype, "onCharactersLoaded", null);
    __decorate([
        Bound_5.default
    ], Inventory.prototype, "onPageFocusChange", null);
    Inventory.INSTANCE = new Inventory();
    Object.assign(window, { inventory: Inventory.INSTANCE });
});
define("model/models/Loadouts", ["require", "exports", "model/models/Manifest", "utility/decorator/Bound"], function (require, exports, Manifest_9, Bound_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Loadout = void 0;
    class Loadout {
        static async init(loadout, index) {
            const result = new Loadout(loadout, index);
            const { DestinyLoadoutColorDefinition, DestinyLoadoutIconDefinition, DestinyLoadoutNameDefinition } = await Manifest_9.default.await();
            result.name = await DestinyLoadoutNameDefinition.get(loadout.nameHash);
            result.icon = await DestinyLoadoutIconDefinition.get(loadout.iconHash);
            result.colour = await DestinyLoadoutColorDefinition.get(loadout.colorHash);
            return result;
        }
        get inventory() {
            return this.inventoryRef?.deref();
        }
        constructor(loadout, index) {
            this.index = index;
            this.items = [];
            Object.assign(this, loadout);
        }
        isEmpty() {
            return this.items.every(item => item.itemInstanceId === "0" && item.plugItemHashes.every(hash => hash === 2166136261 /* InventoryItemHashes.Invalid */));
        }
        setInventory(inventory) {
            this.inventoryRef?.deref()?.event.unsubscribe("update", this.onInventoryUpdate);
            this.inventoryRef = new WeakRef(inventory);
            inventory.event.subscribe("update", this.onInventoryUpdate);
            this.onInventoryUpdate();
        }
        onInventoryUpdate() {
            for (const component of this.items) {
                component.item = this.inventory?.getItem(component.itemInstanceId);
            }
            // console.log("Updated loadout", this);
        }
    }
    exports.Loadout = Loadout;
    __decorate([
        Bound_6.default
    ], Loadout.prototype, "onInventoryUpdate", null);
    var Loadouts;
    (function (Loadouts) {
        async function apply(character, profile) {
            character.loadouts = await (profile.characterLoadouts?.data?.[character.characterId]?.loadouts ?? [])
                .map(async (loadout, index) => await Loadout.init(loadout, index))
                .collect(loadouts => Promise.all(loadouts));
        }
        Loadouts.apply = apply;
    })(Loadouts || (Loadouts = {}));
    exports.default = Loadouts;
});
define("model/models/Characters", ["require", "exports", "model/models/Loadouts", "model/models/Manifest", "model/models/ProfileBatch", "utility/EventManager", "utility/Objects"], function (require, exports, Loadouts_1, Manifest_10, ProfileBatch_6, EventManager_13, Objects_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Character = void 0;
    class Character {
        static async get(characterComponent, manifest, profile) {
            const character = new Character();
            Object.assign(character, characterComponent);
            const { DestinyClassDefinition, DestinyInventoryItemDefinition } = manifest;
            character.class = await DestinyClassDefinition.get(character.classHash);
            character.emblem = await DestinyInventoryItemDefinition.get(character.emblemHash);
            character.power = (character.light ?? 0) - (profile.profileProgression?.data?.seasonalArtifact.powerBonus ?? 0);
            await Loadouts_1.default.apply(character, profile);
            // character.stat = await DestinyStatDefinition.get(CLASSES[character.classType]);
            return character;
        }
    }
    exports.Character = Character;
    let charactersReadyPromise;
    let characters = {};
    let charactersSorted = [];
    ProfileBatch_6.default.event.subscribe("loaded", ({ value: profile }) => {
        charactersReadyPromise = (async () => {
            const manifest = await Manifest_10.default.await();
            characters = await Objects_4.default.mapAsync(profile.characters?.data ?? {}, async ([key, character]) => [key, await Character.get(character, manifest, profile)]);
            charactersSorted = Object.values(characters)
                .sort(({ dateLastPlayed: dateLastPlayedA }, { dateLastPlayed: dateLastPlayedB }) => new Date(dateLastPlayedB).getTime() - new Date(dateLastPlayedA).getTime());
            Characters.event.emit("loaded", { characters, sorted: charactersSorted });
        })();
    });
    var Characters;
    (function (Characters) {
        Characters.event = new EventManager_13.EventManager({});
        async function awaitReady() {
            return await charactersReadyPromise;
        }
        Characters.awaitReady = awaitReady;
        /**
         * @returns Whether deepsight.gg has any characters available
         */
        function hasAny() {
            return !!charactersSorted.length;
        }
        Characters.hasAny = hasAny;
        /**
         * @returns A record of character IDs to Character class
         */
        function all() {
            return characters;
        }
        Characters.all = all;
        /**
         * @returns The Character of a given character ID, if available
         */
        function get(id) {
            return characters[id];
        }
        Characters.get = get;
        /**
         * @returns Characters sorted most recently active first
         */
        function getSorted() {
            return charactersSorted;
        }
        Characters.getSorted = getSorted;
        /**
         * @returns Characters of the given DestinyClass, sorted most recently active first
         */
        function byClassType(classType) {
            return charactersSorted
                .filter(character => character.classType === classType);
        }
        Characters.byClassType = byClassType;
        /**
         * @returns Distinct character class types sorted most recently active first
         */
        function getSortedClasses() {
            return getSorted()
                .map(character => character.classType)
                .distinct();
        }
        Characters.getSortedClasses = getSortedClasses;
        /**
         * @returns The most recently active character
         */
        function getCurrent() {
            return charactersSorted[0];
        }
        Characters.getCurrent = getCurrent;
        /**
         * @returns The Character class of a given character ID, if available. Otherwise, the most recently active character
         */
        function getOrCurrent(id) {
            return characters?.[id] ?? charactersSorted[0];
        }
        Characters.getOrCurrent = getOrCurrent;
    })(Characters || (Characters = {}));
    exports.default = Characters;
});
define("ui/component/Button", ["require", "exports", "ui/component/Component"], function (require, exports, Component_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonClasses = void 0;
    var ButtonClasses;
    (function (ButtonClasses) {
        ButtonClasses["Main"] = "button";
        ButtonClasses["Icon"] = "button-icon";
        ButtonClasses["InnerIcon"] = "button-icon-inner";
        ButtonClasses["InnerIcon1"] = "button-icon-inner1";
        ButtonClasses["InnerIcon2"] = "button-icon-inner2";
        ButtonClasses["Attention"] = "button-attention";
        ButtonClasses["LaserFocus"] = "button-laser-focus";
        ButtonClasses["Selected"] = "button-selected";
        ButtonClasses["Primary"] = "button-primary";
        ButtonClasses["HasWipeAnimation"] = "button-has-wipe-animation";
        ButtonClasses["HasWipeAnimationOut"] = "button-has-wipe-animation-out";
        ButtonClasses["WipeAnimation"] = "button-wipe-animation";
        ButtonClasses["WipeAnimationOut"] = "button-wipe-animation-out";
    })(ButtonClasses || (exports.ButtonClasses = ButtonClasses = {}));
    class Button extends Component_5.default {
        static async animateWipeMultiple(buttons, initialiser) {
            let readyCount = 0;
            let setInitialised;
            const initialised = new Promise(resolve => setInitialised = resolve);
            const ready = () => {
                readyCount++;
                if (readyCount === buttons.length)
                    void Promise.resolve(initialiser()).then(setInitialised);
                return initialised;
            };
            return Promise.all(buttons.map(button => button.animateWipe(ready)));
        }
        static basic() {
            return Button.create([]);
        }
        onMake(...args) {
            this.classes.add(ButtonClasses.Main);
        }
        addIcon(tweaker) {
            this.innerIcon?.remove();
            return this.prepend(this.innerIcon = Component_5.default.create("span")
                .classes.add(ButtonClasses.InnerIcon)
                .append(Component_5.default.create("span").classes.add(ButtonClasses.InnerIcon1))
                .append(Component_5.default.create("span").classes.add(ButtonClasses.InnerIcon2))
                .tweak(tweaker));
        }
        setPrimary() {
            return this.classes.add(ButtonClasses.Primary);
        }
        setLaserFocus() {
            this.laserFocus ??= Component_5.default.create()
                .classes.add(ButtonClasses.LaserFocus)
                .appendTo(this);
            return this;
        }
        setAttention() {
            this.attention ??= Component_5.default.create()
                .classes.add(ButtonClasses.Attention)
                .appendTo(this);
            return this;
        }
        async animateWipe(initialiser) {
            while (this.wipeAnimation)
                await this.wipeAnimation;
            this.wipeAnimation = (async () => {
                const wipe = Component_5.default.create()
                    .classes.add(ButtonClasses.WipeAnimation)
                    .appendTo(this);
                this.classes.add(ButtonClasses.HasWipeAnimation);
                await new Promise(resolve => wipe.event.subscribe("animationend", resolve));
                await initialiser();
                this.classes.add(ButtonClasses.HasWipeAnimationOut);
                wipe.classes.add(ButtonClasses.WipeAnimationOut);
                await new Promise(resolve => wipe.event.subscribe("animationend", resolve));
                wipe.remove();
                this.classes.remove(ButtonClasses.HasWipeAnimation, ButtonClasses.HasWipeAnimationOut);
            })();
            await this.wipeAnimation;
            delete this.wipeAnimation;
        }
        click() {
            this.element.click();
            return this;
        }
        setDisabled(disabled = true) {
            this.attributes.toggle(disabled, "disabled");
            return this;
        }
    }
    Button.defaultType = "button";
    exports.default = Button;
});
define("ui/component/Hints", ["require", "exports", "ui/component/Button", "ui/component/Component"], function (require, exports, Button_1, Component_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hint = exports.IInput = void 0;
    var InputMouse;
    (function (InputMouse) {
        InputMouse[InputMouse["MouseLeft"] = 0] = "MouseLeft";
        InputMouse[InputMouse["MouseRight"] = 1] = "MouseRight";
        InputMouse[InputMouse["MouseMiddle"] = 2] = "MouseMiddle";
    })(InputMouse || (InputMouse = {}));
    var InputModifier;
    (function (InputModifier) {
        InputModifier[InputModifier["Ctrl"] = 0] = "Ctrl";
        InputModifier[InputModifier["Shift"] = 1] = "Shift";
        InputModifier[InputModifier["Alt"] = 2] = "Alt";
    })(InputModifier || (InputModifier = {}));
    var IInput;
    (function (IInput) {
        function get(catalyst, ...modifiers) {
            return {
                catalyst,
                modifiers: new Set(modifiers),
            };
        }
        IInput.get = get;
    })(IInput || (exports.IInput = IInput = {}));
    var HintClasses;
    (function (HintClasses) {
        HintClasses["Hint"] = "hint";
        HintClasses["HintLabel"] = "hint-label";
        HintClasses["HintInput"] = "hint-input";
        HintClasses["HintInputMouse"] = "hint-input-mouse";
        HintClasses["HintInputMouseElements"] = "hint-input-mouse-elements";
        HintClasses["HintInputModifier"] = "hint-input-modifier";
        HintClasses["HintInputKey"] = "hint-input-key";
        HintClasses["HintInputKeyName"] = "hint-input-key-name";
        HintClasses["HintButton"] = "hint-button";
    })(HintClasses || (HintClasses = {}));
    class Hint extends Component_6.default {
        onMake(input) {
            this.classes.add(HintClasses.Hint);
            HintInput.create([input])
                .appendTo(this);
            this.label = Component_6.default.create("span")
                .classes.add(HintClasses.HintLabel)
                .appendTo(this);
        }
    }
    exports.Hint = Hint;
    (function (Hint) {
        class Button extends Hint {
            onMake(input) {
                super.onMake(input);
                Button_1.default.prototype["onMake"].call(this);
                this.classes.add(HintClasses.HintButton);
            }
        }
        Button.defaultType = "button";
        Hint.Button = Button;
    })(Hint || (exports.Hint = Hint = {}));
    class HintInput extends Component_6.default {
        onMake(input) {
            this.classes.add(HintClasses.HintInput);
            this.set(input);
        }
        set(input) {
            this.removeContents();
            if (!input)
                return;
            for (const modifier of ["Ctrl", "Shift", "Alt"]) {
                if (input.modifiers.has(modifier)) {
                    Component_6.default.create("i")
                        .classes.add(HintClasses.HintInputModifier, `${HintClasses.HintInputModifier}-${modifier.toLowerCase()}`)
                        .appendTo(this);
                }
            }
            if (input.catalyst.startsWith("Mouse")) {
                this.classes.add(HintClasses.HintInputMouse, `${HintClasses.HintInput}-${input.catalyst.toLowerCase()}`);
                Component_6.default.create("i")
                    .classes.add(HintClasses.HintInputMouseElements)
                    .appendTo(this);
            }
            else if (input.catalyst.startsWith("Key")) {
                Component_6.default.create("kbd")
                    .classes.add(HintClasses.HintInputKey)
                    .append(Component_6.default.create("span")
                    .classes.add(HintClasses.HintInputKeyName)
                    .text.set(input.catalyst.slice(3)))
                    .appendTo(this);
            }
        }
    }
});
define("ui/component/Dialog", ["require", "exports", "ui/component/Component", "ui/component/Hints", "utility/Async", "utility/decorator/Bound"], function (require, exports, Component_7, Hints_1, Async_3, Bound_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DialogClasses = void 0;
    var DialogClasses;
    (function (DialogClasses) {
        DialogClasses["Main"] = "dialog";
        DialogClasses["_Closed"] = "dialog--closed";
        DialogClasses["Title"] = "dialog-title";
        DialogClasses["Content"] = "dialog-content";
        DialogClasses["Body"] = "dialog-body";
        DialogClasses["Hints"] = "dialog-hints";
    })(DialogClasses || (exports.DialogClasses = DialogClasses = {}));
    class Dialog extends Component_7.default {
        constructor() {
            super(...arguments);
            this.closing = false;
        }
        onMake() {
            this.classes.add(DialogClasses.Main);
            this.content = Component_7.default.create()
                .classes.add(DialogClasses.Content)
                .appendTo(this);
            this.title = Component_7.default.create("h2")
                .classes.add(DialogClasses.Title)
                .appendTo(this.content);
            this.body = Component_7.default.create()
                .classes.add(DialogClasses.Body)
                .appendTo(this.content);
            this.hints = Component_7.default.create("footer")
                .classes.add(DialogClasses.Hints)
                .appendTo(this);
            this.hintDismiss = Hints_1.Hint.Button.create([Hints_1.IInput.get("KeyEsc")])
                .tweak(hint => hint.label.text.set("Dismiss"))
                .event.subscribe("click", this.close)
                .appendTo(this.hints);
            this.event.subscribe("mousedown", this.onMouseDown);
            this.event.subscribe("keydown", this.onKeyDown);
        }
        get isOpen() {
            return this.element.open;
        }
        open() {
            if (this.closing)
                return;
            this.classes.remove(DialogClasses._Closed);
            this.element.showModal();
        }
        async close() {
            if (this.closing)
                return;
            this.closing = true;
            this.style.set("--height-pre-close", `${this.element.clientHeight}px`);
            this.classes.add(DialogClasses._Closed);
            await Async_3.default.sleep(500);
            this.element.close();
            this.closing = false;
        }
        onMouseDown(event) {
            if (!this.getRect().containsPoint(event.clientX, event.clientY)) {
                void this.close();
            }
        }
        onKeyDown(event) {
            if (event.code === "Escape") {
                event.preventDefault();
                void this.close();
            }
        }
    }
    Dialog.defaultType = "dialog";
    exports.default = Dialog;
    __decorate([
        Bound_7.default
    ], Dialog.prototype, "close", null);
    __decorate([
        Bound_7.default
    ], Dialog.prototype, "onMouseDown", null);
    __decorate([
        Bound_7.default
    ], Dialog.prototype, "onKeyDown", null);
});
define("ui/component/Drawer", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/utility/Classes"], function (require, exports, Button_2, Component_8, Classes_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrawerClasses = void 0;
    var DrawerClasses;
    (function (DrawerClasses) {
        DrawerClasses["Main"] = "drawer";
        DrawerClasses["Panel"] = "drawer-panel";
        DrawerClasses["PanelHasBack"] = "drawer-panel-has-back";
        DrawerClasses["Close"] = "drawer-close";
        DrawerClasses["Back"] = "drawer-back";
        DrawerClasses["Disabled"] = "drawer-disabled";
    })(DrawerClasses || (exports.DrawerClasses = DrawerClasses = {}));
    class Drawer extends Component_8.default {
        onMake() {
            this.focusOnClick = true;
            this.panels = new Set();
            this.openReasons = new Set();
            this.classes.add(DrawerClasses.Main, Classes_2.Classes.Hidden)
                .attributes.add("inert")
                .attributes.set("tabindex", "0")
                .event.subscribe("mousedown", event => {
                if (!event.target.closest("button, input") && this.focusOnClick) {
                    window.getSelection()?.removeAllRanges();
                    // focus the drawer 
                    this.element.focus();
                    this.open("click");
                    this.event.emit("focus", new FocusEvent("focus"));
                }
            });
            this.closeButton = Button_2.default.create()
                .classes.add(DrawerClasses.Close)
                .event.subscribe(["mousedown", "click"], () => this.close(true))
                .appendTo(this);
            this.backButton = Button_2.default.create()
                .classes.add(DrawerClasses.Back, Classes_2.Classes.Hidden)
                .appendTo(this);
        }
        isOpen(visually) {
            return !this.classes.has(Classes_2.Classes.Hidden)
                && (visually || !this.classes.has(Classes_2.Classes.Disabled));
        }
        isDisabled() {
            return this.classes.has(Classes_2.Classes.Disabled);
        }
        disable() {
            this.classes.add(Classes_2.Classes.Disabled, DrawerClasses.Disabled);
            if (this.isOpen()) {
                this.classes.add(Classes_2.Classes.Hidden);
                this.attributes.add("inert");
            }
            return this;
        }
        enable() {
            this.classes.remove(Classes_2.Classes.Disabled, DrawerClasses.Disabled);
            if (this.openReasons.size) {
                this.classes.remove(Classes_2.Classes.Hidden);
                this.attributes.remove("inert");
            }
            return this;
        }
        createPanel() {
            const panel = Component_8.default.create()
                .classes.add(DrawerClasses.Panel)
                .appendTo(this);
            this.panels.add(panel);
            if (this.panels.size > 1)
                panel.classes.add(Classes_2.Classes.Hidden)
                    .attributes.add("inert");
            return panel;
        }
        showPanel(panel, showBackButton = false) {
            let lastPanel;
            for (const panel of this.panels) {
                if (!panel.classes.has(Classes_2.Classes.Hidden)) {
                    lastPanel = panel;
                    lastPanel.attributes.add("inert")
                        .classes.add(Classes_2.Classes.Hidden);
                }
            }
            panel.attributes.remove("inert")
                .classes.remove(Classes_2.Classes.Hidden);
            this.event.emit("showPanel", { panel });
            if (showBackButton && lastPanel) {
                if (!this.backButton.classes.has(Classes_2.Classes.Hidden))
                    throw new Error("Drawer panels don't support multi-level back arrows yet");
                panel.classes.add(DrawerClasses.PanelHasBack);
                this.backButton.classes.remove(Classes_2.Classes.Hidden)
                    .event.until(this.event.waitFor(["closeDrawer", "showPanel"]), event => event
                    .subscribeOnce(["click", "mousedown"], () => {
                    this.showPanel(lastPanel);
                    this.backButton.classes.add(Classes_2.Classes.Hidden);
                }));
            }
            return this;
        }
        toggle(reason = "generic") {
            const added = !this.openReasons.has(reason);
            if (added)
                this.openReasons.add(reason);
            else
                this.openReasons.delete(reason);
            if (this.openReasons.size === 0)
                this.close(reason);
            else if (this.openReasons.size === 1 && added)
                this.open(reason);
            return this.isOpen();
        }
        open(reason = "generic") {
            this.openReasons.add(reason);
            if (this.isDisabled())
                return;
            if (!this.classes.has(Classes_2.Classes.Hidden))
                return;
            this.classes.remove(Classes_2.Classes.Hidden);
            this.attributes.remove("inert");
            this.event.emit("openDrawer", { reason });
        }
        close(reason = "generic") {
            if (reason === true)
                this.openReasons.clear();
            else
                this.openReasons.delete(reason);
            if (!this.openReasons.size) {
                this.classes.add(Classes_2.Classes.Hidden);
                this.attributes.add("inert");
                this.event.emit("closeDrawer");
                this.backButton.classes.add(Classes_2.Classes.Hidden);
            }
        }
        removeContents() {
            while (this.element.lastChild && this.element.lastChild !== this.closeButton.element)
                this.element.lastChild?.remove();
            this.panels.clear();
            return this;
        }
        removePanels() {
            for (const panel of this.panels)
                panel.remove();
            this.panels.clear();
            return this;
        }
        removePanel(panel) {
            if (panel) {
                this.panels.delete(panel);
                panel.remove();
            }
            return this;
        }
    }
    exports.default = Drawer;
});
define("ui/component/InfoBlock", ["require", "exports", "ui/component/Component"], function (require, exports, Component_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InfoBlockClasses = void 0;
    var InfoBlockClasses;
    (function (InfoBlockClasses) {
        InfoBlockClasses["Main"] = "info-block";
        InfoBlockClasses["Borders2"] = "info-block-borders2";
    })(InfoBlockClasses || (exports.InfoBlockClasses = InfoBlockClasses = {}));
    class InfoBlock extends Component_9.default {
        onMake() {
            this.classes.add(InfoBlockClasses.Main);
            Component_9.default.create()
                .classes.add(InfoBlockClasses.Borders2)
                .appendTo(this);
        }
    }
    exports.default = InfoBlock;
});
define("ui/component/Loadable", ["require", "exports", "model/Model", "ui/component/Component", "ui/utility/Classes", "utility/Async", "utility/decorator/Bound"], function (require, exports, Model_11, Component_10, Classes_3, Async_4, Bound_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Loadable;
    (function (Loadable) {
        let Classes;
        (function (Classes) {
            Classes["Main"] = "loadable";
            Classes["Loading"] = "loadable-loading";
            Classes["LoadingSpinny"] = "loadable-loading-spinny";
            Classes["LoadingSpinny1"] = "loadable-loading-spinny1";
            Classes["LoadingSpinny2"] = "loadable-loading-spinny2";
            Classes["LoadingInfo"] = "loadable-loading-info";
            Classes["LoadingBar"] = "loadable-loading-bar";
            Classes["LoadingMessage"] = "loadable-loading-message";
            Classes["LoadingHidden"] = "loadable-loading-hidden";
            Classes["Content"] = "loadable-content";
        })(Classes = Loadable.Classes || (Loadable.Classes = {}));
        class Component extends Component_10.default {
            constructor() {
                super(...arguments);
                this.persistent = false;
            }
            onMake(models, initialiser) {
                this.models = models;
                this.initialiser = initialiser;
                this.classes.add(Classes.Main);
                this.loading = Component_10.default.create("span")
                    .classes.add(Classes.Loading)
                    .append(Component_10.default.create("span")
                    .classes.add(Classes.LoadingSpinny)
                    .append(Component_10.default.create("span").classes.add(Classes.LoadingSpinny1))
                    .append(Component_10.default.create("span").classes.add(Classes.LoadingSpinny2)))
                    .append(Component_10.default.create("span")
                    .classes.add(Classes.LoadingInfo)
                    .append(this.loadingBar = Component_10.default.create("span")
                    .classes.add(Classes.LoadingBar))
                    .append(this.loadingMessage = Component_10.default.create("span")
                    .classes.add(Classes.LoadingMessage)))
                    .appendTo(this);
                for (const model of models) {
                    model.event.subscribe("loading", this.onLoading);
                    model.get();
                    if (model["value"] instanceof Promise)
                        this.onLoading();
                }
                if (models.every(model => !model.loading))
                    this.onLoaded();
            }
            setSimple() {
                this.loadingBar.classes.add(Classes_3.Classes.Hidden);
                this.loadingMessage.classes.add(Classes_3.Classes.Hidden);
                return this;
            }
            setLoading(loading) {
                this.loading.classes.toggle(!loading, Classes_3.Classes.Hidden, Classes.LoadingHidden);
                return this;
            }
            onLoading() {
                for (const model of this.models) {
                    model.event.subscribe("loaded", this.onLoaded);
                    model.event.subscribe("loadUpdate", this.updateLoadingInfo);
                }
                if (this.loading.classes.some(Classes_3.Classes.Hidden, Classes.LoadingHidden)) {
                    // start loading
                    this.updateLoadingInfo();
                    this.loading.classes.remove(Classes_3.Classes.Hidden, Classes.LoadingHidden);
                    while (this.element.children.length > 1)
                        this.element.lastElementChild.remove();
                }
            }
            setPersistent() {
                this.persistent = true;
                return this;
            }
            onLoaded() {
                this.updateLoadingInfo();
                for (const model of this.models)
                    if (model.loading)
                        return; // not loaded yet
                for (const model of this.models) {
                    if (!this.persistent)
                        model.event.unsubscribe("loading", this.onLoading);
                    model.event.unsubscribe("loaded", this.onLoaded);
                    model.event.unsubscribe("loadUpdate", this.updateLoadingInfo);
                }
                if (this.loading.classes.has(Classes.LoadingHidden))
                    return; // already loaded
                this.loading.classes.add(Classes.LoadingHidden);
                void Async_4.default.sleep(400).then(() => {
                    for (const model of this.models)
                        if (model.loading)
                            return; // not loaded yet
                    this.loading.classes.add(Classes_3.Classes.Hidden);
                });
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-return
                this.initialiser(...this.models.map(model => model["value"] ?? undefined))
                    .appendTo(this);
            }
            updateLoadingInfo() {
                let progress = 0;
                let message;
                for (const model of this.models) {
                    if (!model.loading) {
                        progress++;
                        continue;
                    }
                    progress += model.loadingInfo?.progress ?? 0;
                    message ??= model.loadingInfo?.messages[0];
                }
                progress /= this.models.length;
                this.loadingBar.style.set("--progress", `${Math.min(1, progress)}`);
                if (message)
                    this.loadingMessage.text.set(`${message}...`);
                else
                    this.loadingMessage.text.remove();
            }
        }
        __decorate([
            Bound_8.default
        ], Component.prototype, "onLoading", null);
        __decorate([
            Bound_8.default
        ], Component.prototype, "onLoaded", null);
        __decorate([
            Bound_8.default
        ], Component.prototype, "updateLoadingInfo", null);
        Loadable.Component = Component;
        function create(...models) {
            return {
                onReady(initialiser) {
                    return Component.create([
                        models.map(model => model instanceof Promise ? Model_11.default.createTemporary(() => model) : model),
                        initialiser,
                    ]);
                },
            };
        }
        Loadable.create = create;
    })(Loadable || (Loadable = {}));
    exports.default = Loadable;
});
define("ui/component/Paginator", ["require", "exports", "ui/component/Button", "ui/component/Component", "utility/maths/Maths"], function (require, exports, Button_3, Component_11, Maths_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PaginatorPage = exports.PaginatorSizeHelper = exports.PaginatorClasses = void 0;
    var PaginatorClasses;
    (function (PaginatorClasses) {
        PaginatorClasses["Main"] = "paginator";
        PaginatorClasses["PageWrapper"] = "paginator-page-wrapper";
        PaginatorClasses["Page"] = "paginator-page";
        PaginatorClasses["PageHasNext"] = "paginator-page-has-next";
        PaginatorClasses["PageHasPrev"] = "paginator-page-has-prev";
        PaginatorClasses["Button"] = "paginator-button";
        PaginatorClasses["ButtonNext"] = "paginator-button-next";
        PaginatorClasses["ButtonPrev"] = "paginator-button-prev";
        PaginatorClasses["ButtonArrow"] = "paginator-button-arrow";
        PaginatorClasses["ButtonArrowNext"] = "paginator-button-arrow-next";
        PaginatorClasses["ButtonArrowPrev"] = "paginator-button-arrow-prev";
        PaginatorClasses["Preview"] = "paginator-preview";
        PaginatorClasses["PreviewPage"] = "paginator-preview-page";
        PaginatorClasses["PreviewPageCurrent"] = "paginator-preview-page-current";
        PaginatorClasses["_DisplayMode"] = "paginator--display-mode-";
        PaginatorClasses["_DisplayModeSides"] = "paginator--display-mode-sides";
        PaginatorClasses["_DisplayModeTop"] = "paginator--display-mode-top";
    })(PaginatorClasses || (exports.PaginatorClasses = PaginatorClasses = {}));
    var PaginatorSizeHelper;
    (function (PaginatorSizeHelper) {
        function make(helper) {
            return helper;
        }
        PaginatorSizeHelper.make = make;
        function getPerPage(helper) {
            if (typeof helper === "number")
                return helper;
            if (Component_11.default.window.width > 1200)
                return helper.desktop ?? helper.vertical ?? helper.tablet ?? helper.mobile ?? 1;
            if (Component_11.default.window.width >= 1080)
                return helper.vertical ?? helper.tablet ?? helper.mobile ?? helper.desktop ?? 1;
            if (Component_11.default.window.width > 800)
                return helper.tablet ?? helper.mobile ?? helper.vertical ?? helper.desktop ?? 1;
            return helper.mobile ?? helper.tablet ?? helper.vertical ?? helper.desktop ?? 1;
        }
        PaginatorSizeHelper.getPerPage = getPerPage;
    })(PaginatorSizeHelper || (exports.PaginatorSizeHelper = PaginatorSizeHelper = {}));
    class Paginator extends Component_11.default {
        constructor() {
            super(...arguments);
            this.scrolling = false;
        }
        onMake() {
            this.classes.add(PaginatorClasses.Main);
            this.pages = [];
            this.previewPages = [];
            this.pageIndex = 0;
            this.buttonPrev = Button_3.default.create()
                .classes.add(PaginatorClasses.Button, PaginatorClasses.ButtonPrev)
                .setPrimary()
                .append(Component_11.default.create()
                .classes.add(PaginatorClasses.ButtonArrow, PaginatorClasses.ButtonArrowPrev))
                .event.subscribe("click", () => this.showPage(this.pageIndex - 1))
                .appendTo(this);
            this.pageWrapper = Component_11.default.create()
                .classes.add(PaginatorClasses.PageWrapper)
                .appendTo(this);
            this.buttonNext = Button_3.default.create()
                .classes.add(PaginatorClasses.Button, PaginatorClasses.ButtonNext)
                .setPrimary()
                .append(Component_11.default.create()
                .classes.add(PaginatorClasses.ButtonArrow, PaginatorClasses.ButtonArrowNext))
                .event.subscribe("click", () => this.showPage(this.pageIndex + 1))
                .appendTo(this);
            this.preview = Component_11.default.create()
                .classes.add(PaginatorClasses.Preview)
                .appendTo(this);
            this.event.subscribe("wheel", event => event.shiftKey
                && this.showPage(this.pageIndex + Math.sign(event.deltaY))
                && event.preventDefault());
            this.event.subscribe("mousedown", event => {
                if (event.button === 1) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
            });
        }
        setDisplayMode(mode) {
            this.classes.remove(PaginatorClasses._DisplayModeSides, PaginatorClasses._DisplayModeTop);
            this.classes.add(`${PaginatorClasses._DisplayMode}${mode}`);
            return this;
        }
        filler(perPage, pageInitialiser) {
            if (this.pages.length)
                // store old pages in a way that will get yeeted by GC
                Component_11.default.create()
                    .append(...this.pages);
            for (const previewPage of this.previewPages)
                previewPage.remove();
            this.pages.length = 0;
            this.previewPages.length = 0;
            this.pageIndex = 0;
            this.pageWrapper.element.scrollLeft = 0;
            this.scrolling = false;
            let page;
            let filled = Infinity;
            const result = {
                perPage,
                increment: incrementPageInitialiser => {
                    return result.add(1, incrementPageInitialiser);
                },
                add: (value, incrementPageInitialiser) => {
                    const perPage = PaginatorSizeHelper.getPerPage(result.perPage);
                    if (filled + value > perPage && !(value >= perPage && !filled))
                        filled = 0, page = this.page()
                            .tweak(pageInitialiser)
                            .tweak(incrementPageInitialiser)
                            .style.set("--paginator-page-size", `${perPage}`);
                    filled += value;
                    return page;
                },
                fillRemainder(appender) {
                    const perPage = PaginatorSizeHelper.getPerPage(result.perPage);
                    while (filled < perPage && filled !== 0) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        const count = appender(result.increment());
                        if (typeof count === "number")
                            filled += count - 1;
                    }
                },
            };
            return result;
        }
        page(initialiser) {
            const index = this.pages.length;
            const page = PaginatorPage.create([index])
                .classes.add(PaginatorClasses.Page)
                .tweak(initialiser)
                .appendTo(this.pageWrapper);
            this.pages.push(page);
            const preview = Component_11.default.create()
                .classes.add(PaginatorClasses.PreviewPage)
                .classes.toggle(!index, PaginatorClasses.PreviewPageCurrent)
                .appendTo(this.preview);
            this.previewPages.push(preview);
            this.updateButtons();
            return initialiser ? this : page;
        }
        showPage(pageIndex) {
            const page = this.pages[pageIndex];
            if (!page)
                return false;
            this.pageIndex = pageIndex;
            this.scroll();
            for (const page of this.previewPages)
                page.classes.remove(PaginatorClasses.PreviewPageCurrent);
            this.previewPages[pageIndex]?.classes.add(PaginatorClasses.PreviewPageCurrent);
            this.updateButtons();
            return true;
        }
        updateButtons() {
            this.buttonPrev.setDisabled(this.pageIndex === 0);
            this.buttonNext.setDisabled(this.pageIndex === this.pages.length - 1);
        }
        scroll() {
            if (this.scrolling)
                return;
            this.scrolling = true;
            let lastStep = Date.now();
            const tickRate = 1000 / 30;
            const scrollSpeed = 1 / 3;
            const step = () => {
                if (!this.scrolling)
                    return;
                const now = Date.now();
                const delta = (now - lastStep) / tickRate;
                lastStep = now;
                const paddingleft = 0;
                const pageElement = this.pages[this.pageIndex].element;
                const wrapperElement = this.pageWrapper.element;
                const offsetLeft = pageElement.offsetLeft - wrapperElement.offsetLeft + paddingleft;
                const scrollLeft = wrapperElement.scrollLeft;
                const targetScrollLeft = offsetLeft - paddingleft;
                const diff = targetScrollLeft - scrollLeft;
                if (Math.abs(diff) > 2) {
                    const newScrollLeft = Maths_4.default.lerp(targetScrollLeft, scrollLeft, 0.5 ** (delta * scrollSpeed));
                    const scrollDiff = newScrollLeft - scrollLeft;
                    this.pageWrapper.element.scrollLeft = scrollDiff > 0 ? Math.ceil(newScrollLeft) : Math.floor(newScrollLeft);
                    requestAnimationFrame(step);
                    return;
                }
                this.pageWrapper.element.scrollLeft = targetScrollLeft;
                this.scrolling = false;
            };
            requestAnimationFrame(step);
        }
    }
    exports.default = Paginator;
    class PaginatorPage extends Component_11.default {
        onMake(page) {
            this.classes.add(PaginatorClasses.Page);
            this.page = page;
        }
    }
    exports.PaginatorPage = PaginatorPage;
});
define("ui/component/form/TextInput", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/utility/Classes"], function (require, exports, Button_4, Component_12, Classes_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextInputClasses = void 0;
    var TextInputClasses;
    (function (TextInputClasses) {
        TextInputClasses["Main"] = "text-input";
        TextInputClasses["Input"] = "text-input-input";
        TextInputClasses["Clear"] = "text-input-clear";
        TextInputClasses["Clear1"] = "text-input-clear1";
        TextInputClasses["_HasInput"] = "text-input--has-input";
    })(TextInputClasses || (exports.TextInputClasses = TextInputClasses = {}));
    class TextInput extends Component_12.default {
        get inputText() {
            return this.input.element.value ?? "";
        }
        set inputText(value) {
            this.input.element.value = value;
            this.clear.classes.toggle(this.inputText === "", Classes_4.Classes.Hidden)
                .attributes.toggle(this.inputText === "", "inert");
        }
        onMake() {
            this.classes.add(TextInputClasses.Main);
            this.input = Component_12.default.create("input")
                .classes.add(TextInputClasses.Input)
                .attributes.set("type", "text")
                .event.subscribe("input", () => {
                this.event.emit("input");
                this.classes.toggle(this.inputText !== "", TextInputClasses._HasInput);
                this.clear.classes.toggle(this.inputText === "", Classes_4.Classes.Hidden)
                    .attributes.toggle(this.inputText === "", "inert");
            })
                .event.subscribe("change", () => this.event.emit("change"))
                .appendTo(this);
            this.clear = Button_4.default.create()
                .classes.add(TextInputClasses.Clear, Classes_4.Classes.Hidden)
                .attributes.add("inert")
                .append(Component_12.default.create("span")
                .classes.add(TextInputClasses.Clear1))
                .event.subscribe("click", () => {
                this.input.element.value = "";
                this.event.emit("input");
                this.event.emit("change");
            })
                .appendTo(this);
        }
        setPlaceholder(placeholder) {
            this.input.attributes.set("placeholder", placeholder);
            return this;
        }
    }
    exports.default = TextInput;
});
define("ui/destiny/component/ProfileButton", ["require", "exports", "model/models/Manifest", "ui/component/Button", "ui/component/Component", "utility/ProfileManager"], function (require, exports, Manifest_11, Button_5, Component_13, ProfileManager_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfileButtonClasses = void 0;
    var ProfileButtonClasses;
    (function (ProfileButtonClasses) {
        ProfileButtonClasses["Main"] = "profile-button";
        ProfileButtonClasses["Emblem"] = "profile-button-emblem";
        ProfileButtonClasses["BungieId"] = "profile-button-bungie-id";
        ProfileButtonClasses["BungieIdName"] = "profile-button-bungie-id-name";
        ProfileButtonClasses["BungieIdCode"] = "profile-button-bungie-id-code";
        ProfileButtonClasses["Callsign"] = "profile-button-callsign";
        ProfileButtonClasses["Placeholder"] = "profile-button-placeholder";
        ProfileButtonClasses["_Authenticated"] = "profile-button--authenticated";
        ProfileButtonClasses["_Disabled"] = "profile-button--disabled";
    })(ProfileButtonClasses || (exports.ProfileButtonClasses = ProfileButtonClasses = {}));
    const placeholderEmblem = 4133455811;
    const classEmblems = {
        [1 /* DestinyClass.Hunter */]: 1907674138 /* InventoryItemHashes.HuntersWitEmblem */,
        [0 /* DestinyClass.Titan */]: 1907674139 /* InventoryItemHashes.TitansPrideEmblem */,
        [2 /* DestinyClass.Warlock */]: 1907674137 /* InventoryItemHashes.WarlocksFlightEmblem */,
    };
    class ProfileButton extends Button_5.default {
        async onMake(bungieId, profile) {
            super.onMake(bungieId, profile);
            this.classes.add(ProfileButtonClasses.Main);
            this.classes.toggle(!!profile?.accessToken, ProfileButtonClasses._Authenticated);
            if (profile && !profile.membershipType && !profile.membershipId && bungieId.code !== -1) {
                profile = await ProfileManager_9.default.reinit(bungieId);
                if (!profile)
                    this.classes.add(ProfileButtonClasses._Disabled);
            }
            Component_13.default.create("span")
                .classes.add(ProfileButtonClasses.BungieId)
                .append(Component_13.default.create("span")
                .classes.add(ProfileButtonClasses.BungieIdName)
                .text.set(bungieId.name))
                .append(bungieId.code === -1 ? undefined : Component_13.default.create("span")
                .classes.add(ProfileButtonClasses.BungieIdCode)
                .text.set(`#${(bungieId.code).toString().padStart(4, "0")}`))
                .appendTo(this);
            if (profile?.callsign)
                Component_13.default.create("span")
                    .classes.add(ProfileButtonClasses.Callsign)
                    .text.set(`[${profile.callsign}]`)
                    .appendTo(this);
            const emblemHash = profile?.emblemHash
                // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                ?? classEmblems[profile?.class]
                ?? placeholderEmblem;
            const { DeepsightEmblemDefinition } = await Manifest_11.default.await();
            const def = await DeepsightEmblemDefinition.get(emblemHash);
            if (!def)
                return;
            this.style.set("--colour", `rgb(${def.backgroundColor.red}, ${def.backgroundColor.green}, ${def.backgroundColor.blue})`);
            Component_13.default.create()
                .classes.add(ProfileButtonClasses.Emblem)
                .style.set("--icon", `url("https://www.bungie.net${def.displayProperties.icon}")`)
                .prependTo(this);
        }
    }
    (function (ProfileButton) {
        class Placeholder extends Component_13.default {
            onMake() {
                this.classes.add(ProfileButtonClasses.Placeholder);
            }
        }
        ProfileButton.Placeholder = Placeholder;
    })(ProfileButton || (ProfileButton = {}));
    exports.default = ProfileButton;
});
define("ui/destiny/SwitchProfile", ["require", "exports", "model/models/Memberships", "ui/component/Button", "ui/component/Component", "ui/component/Dialog", "ui/component/Loadable", "ui/component/Paginator", "ui/component/form/TextInput", "ui/destiny/component/ProfileButton", "utility/BungieID", "utility/ProfileManager", "utility/Store", "utility/URL", "utility/decorator/Bound", "utility/endpoint/bungie/Bungie", "utility/endpoint/bungie/endpoint/destiny2/GetProfile", "utility/endpoint/bungie/endpoint/destiny2/SearchDestinyPlayerByBungieName", "utility/endpoint/bungie/endpoint/groupv2/GetUserClan"], function (require, exports, Memberships_2, Button_6, Component_14, Dialog_1, Loadable_1, Paginator_1, TextInput_1, ProfileButton_1, BungieID_5, ProfileManager_10, Store_9, URL_3, Bound_9, Bungie_5, GetProfile_3, SearchDestinyPlayerByBungieName_2, GetUserClan_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SwitchProfileClasses = void 0;
    var SwitchProfileClasses;
    (function (SwitchProfileClasses) {
        SwitchProfileClasses["Main"] = "switch-profile";
        SwitchProfileClasses["Paginator"] = "switch-profile-list-paginator";
        SwitchProfileClasses["ListWrapper"] = "switch-profile-list-wrapper";
        SwitchProfileClasses["List"] = "switch-profile-list";
        SwitchProfileClasses["AuthButton"] = "switch-profile-auth-button";
        SwitchProfileClasses["SearchRow"] = "switch-profile-search-row";
        SwitchProfileClasses["SearchBox"] = "switch-profile-search-box";
        SwitchProfileClasses["SearchBox_Invalid"] = "switch-profile-search-box--invalid";
        SwitchProfileClasses["SearchResult"] = "switch-profile-search-result";
        SwitchProfileClasses["SearchResultInvalid"] = "switch-profile-search-result-invalid";
        SwitchProfileClasses["SearchResultProfile"] = "switch-profile-search-result-profile";
    })(SwitchProfileClasses || (exports.SwitchProfileClasses = SwitchProfileClasses = {}));
    class SwitchProfile extends Dialog_1.default {
        constructor() {
            super(...arguments);
            this.refreshing = false;
            this.queuedRefresh = false;
            this.queued = false;
        }
        onMake() {
            super.onMake();
            this.classes.add(SwitchProfileClasses.Main);
            this.title.text.set("Switch Profile");
            const searchRow = Component_14.default.create()
                .classes.add(SwitchProfileClasses.SearchRow)
                .appendTo(this.body);
            Button_6.default.create()
                .classes.add(SwitchProfileClasses.AuthButton)
                .text.set("Authenticate")
                .event.subscribe("click", () => void Bungie_5.default.authenticate("start").catch(err => console.error(err)))
                .appendTo(searchRow);
            this.searchBox = TextInput_1.default.create()
                .classes.add(SwitchProfileClasses.SearchBox)
                .setPlaceholder("Search by Bungie ID...")
                .event.subscribe("input", this.queueLookupProfile)
                .appendTo(searchRow);
            this.searchResultLoading = Loadable_1.default.create()
                .onReady(() => this.searchResult = Component_14.default.create()
                .classes.add(SwitchProfileClasses.SearchResult))
                .setSimple()
                .appendTo(searchRow);
            this.refresh();
            Store_9.default.event.subscribe(["setProfiles", "deleteProfiles"], this.refresh);
        }
        refresh() {
            if (this.refreshing) {
                this.queuedRefresh = true;
                return;
            }
            this.refreshing = true;
            do {
                this.queuedRefresh = false;
                this.recentPaginator?.remove();
                this.recentPaginator = Paginator_1.default.create()
                    .classes.add(SwitchProfileClasses.Paginator)
                    .tweak(paginator => paginator.pageWrapper.classes.add(SwitchProfileClasses.ListWrapper))
                    .appendTo(this.body);
                const filler = this.recentPaginator.filler(18, page => page.classes.add(SwitchProfileClasses.List));
                const profiles = Object.entries(Store_9.default.items.profiles ?? {})
                    .sort(([, a], [, b]) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
                for (const [bungieId, profile] of profiles) {
                    const id = BungieID_5.default.parse(bungieId);
                    if (!id)
                        continue;
                    const button = ProfileButton_1.default.create([id, profile])
                        .event.subscribe("click", () => this.switchProfile(id, profile))
                        .event.subscribe("contextmenu", event => {
                        event.preventDefault();
                        ProfileManager_10.default.remove(id);
                        button.remove();
                        if (Store_9.default.items.selectedProfile === BungieID_5.default.stringify(id)) {
                            const newProfile = ProfileManager_10.default.get();
                            const url = URL_3.default.path;
                            if (!newProfile)
                                delete Store_9.default.items.selectedProfile;
                            else
                                Store_9.default.items.selectedProfile = BungieID_5.default.stringify(newProfile.id);
                            URL_3.default.path = url;
                            location.reload();
                        }
                    })
                        .appendTo(filler.increment());
                }
                filler.fillRemainder(page => page.append(ProfileButton_1.default.Placeholder.create()));
            } while (this.queuedRefresh);
            this.refreshing = false;
        }
        switchProfile(bungieId, profile) {
            const path = URL_3.default.path;
            Store_9.default.items.selectedProfile = BungieID_5.default.stringify(bungieId);
            URL_3.default.path = path;
            location.reload();
        }
        async queueLookupProfile() {
            if (this.currentLookupPromise) {
                this.queued = true;
                return;
            }
            this.queued = true;
            while (this.queued) {
                this.queued = false;
                this.currentLookupPromise = this.lookupProfile();
                await this.currentLookupPromise;
            }
            this.queued = false;
            delete this.currentLookupPromise;
        }
        async lookupProfile() {
            this.searchResult.removeContents();
            let searchString = this.searchBox.inputText;
            if (!searchString.length) {
                this.searchBox.classes.remove(SwitchProfileClasses.SearchBox_Invalid);
                return;
            }
            const searchCode = searchString[searchString.length - 5] !== "#" ? NaN : +searchString.slice(-4);
            searchString = searchString.slice(0, -5);
            const bungieId = BungieID_5.default.stringify({ name: searchString, code: searchCode });
            const id = BungieID_5.default.parse(bungieId);
            if (isNaN(searchCode) || !id) {
                this.searchBox.classes.add(SwitchProfileClasses.SearchBox_Invalid);
                Component_14.default.create()
                    .classes.add(SwitchProfileClasses.SearchResultInvalid)
                    .text.set("Please enter a valid Bungie ID.")
                    .appendTo(this.searchResult);
                return;
            }
            const existingProfile = Store_9.default.items.profiles?.[bungieId];
            if (existingProfile) {
                ProfileButton_1.default.create([id, existingProfile])
                    .classes.add(SwitchProfileClasses.SearchResultProfile)
                    .event.subscribe("click", () => this.switchProfile(id, existingProfile))
                    .appendTo(this.searchResult);
                return;
            }
            this.searchResultLoading.setLoading(true);
            const destinyMembership = await SearchDestinyPlayerByBungieName_2.default.query(searchString, searchCode)
                .then(memberships => Memberships_2.default.getPrimaryDestinyMembership(memberships));
            if (!destinyMembership) {
                this.searchBox.classes.add(SwitchProfileClasses.SearchBox_Invalid);
                Component_14.default.create()
                    .classes.add(SwitchProfileClasses.SearchResultInvalid)
                    .text.set("Unable to find a user by this Bungie ID.")
                    .appendTo(this.searchResult);
                this.searchResultLoading.setLoading(false);
                return;
            }
            const profile = await GetProfile_3.default
                .setOptionalAuth(true)
                .query(destinyMembership.membershipType, destinyMembership.membershipId, [100 /* DestinyComponentType.Profiles */, 200 /* DestinyComponentType.Characters */]);
            const currentCharacter = Object.values(profile.characters.data ?? {})
                ?.sort(({ dateLastPlayed: dateLastPlayedA }, { dateLastPlayed: dateLastPlayedB }) => new Date(dateLastPlayedB).getTime() - new Date(dateLastPlayedA).getTime())?.[0];
            const clan = await GetUserClan_3.default.query(destinyMembership.membershipType, destinyMembership.membershipId);
            const storeProfile = ProfileManager_10.default.update(id, {
                membershipType: destinyMembership.membershipType,
                membershipId: destinyMembership.membershipId,
                emblemHash: currentCharacter?.emblemHash,
                class: currentCharacter?.classType,
                callsign: clan?.results?.[0]?.group?.clanInfo?.clanCallsign ?? "",
                callsignLastModified: new Date().toISOString(),
            });
            ProfileButton_1.default.create([id, storeProfile])
                .classes.add(SwitchProfileClasses.SearchResultProfile)
                .event.subscribe("click", () => this.switchProfile(id, storeProfile))
                .appendTo(this.searchResult);
            this.searchResultLoading.setLoading(false);
            this.searchBox.inputText = "";
            this.queued = false;
        }
    }
    exports.default = SwitchProfile;
    __decorate([
        Bound_9.default
    ], SwitchProfile.prototype, "refresh", null);
    __decorate([
        Bound_9.default
    ], SwitchProfile.prototype, "queueLookupProfile", null);
});
define("ui/destiny/component/ClassPicker", ["require", "exports", "ui/component/Button", "ui/component/Component"], function (require, exports, Button_7, Component_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassPickerButton = exports.ClassPickerClasses = void 0;
    var ClassPickerClasses;
    (function (ClassPickerClasses) {
        ClassPickerClasses["Main"] = "class-picker";
        ClassPickerClasses["Button"] = "class-picker-button";
        ClassPickerClasses["ButtonPreview"] = "class-picker-button-preview";
        ClassPickerClasses["ButtonCurrent"] = "class-picker-button-current";
        ClassPickerClasses["OptionsWrapper"] = "class-picker-button-wrapper";
        ClassPickerClasses["OptionsWrapper2"] = "class-picker-button-wrapper-2";
        ClassPickerClasses["OptionsWrapper3"] = "class-picker-button-wrapper-3";
        ClassPickerClasses["OptionsWrapper4"] = "class-picker-button-wrapper-4";
        ClassPickerClasses["OptionsWrapper9"] = "class-picker-button-wrapper-9";
        ClassPickerClasses["OptionsWrapperBorders1"] = "class-picker-button-wrapper-borders1";
        ClassPickerClasses["OptionsWrapperBorders2"] = "class-picker-button-wrapper-borders2";
        ClassPickerClasses["Disabled"] = "class-picker--disabled";
    })(ClassPickerClasses || (exports.ClassPickerClasses = ClassPickerClasses = {}));
    class ClassPicker extends Component_15.default {
        onMake(switchHandler) {
            this.classes.add(ClassPickerClasses.Main);
            this.switchHandler = switchHandler;
            this.options = [];
            this.currentButton = ClassPickerButton.create()
                .classes.add(ClassPickerClasses.ButtonCurrent)
                .appendTo(this);
            this.optionsWrapper = Component_15.default.create()
                .classes.add(ClassPickerClasses.OptionsWrapper)
                .appendTo(this);
            this.optionsWrapperBorders1 = Component_15.default.create()
                .classes.add(ClassPickerClasses.OptionsWrapperBorders1)
                .appendTo(this.optionsWrapper);
            this.optionsWrapperBorders2 = Component_15.default.create()
                .classes.add(ClassPickerClasses.OptionsWrapperBorders2)
                .appendTo(this.optionsWrapper);
        }
        get isDisabled() {
            return this.classes.has(ClassPickerClasses.Disabled);
        }
        setDisabled(disabled) {
            this.classes.toggle(disabled, ClassPickerClasses.Disabled);
            return this;
        }
        addOption(option) {
            const existingOption = this.options.find(existing => existing.id === option.id);
            if (existingOption) {
                // already has this option
                existingOption.background = option.background;
                existingOption.icon = option.icon;
                existingOption.button?.setDefinition(option);
                existingOption.item = option.item;
                if (this.currentOption === option.id)
                    this.currentButton.setDefinition(option);
                return this;
            }
            this.options.push(option);
            const button = option.button = ClassPickerButton.create()
                .setDefinition(option)
                .event.subscribe("click", async () => {
                const option = this.options.find(option => option.button === button);
                if (!option) {
                    console.error("Button not assigned to valid option:", button);
                    return;
                }
                await this.switchHandler?.(option.id);
                await this.setCurrent(option.id);
            })
                .appendTo(this.optionsWrapper);
            this.updateOptionsWrapper();
            return this;
        }
        removeOption(id) {
            const index = this.options.findIndex(existing => existing.id === id);
            if (index === -1)
                return;
            const option = this.options[index];
            option.button?.remove();
            this.options.splice(index, 1);
            this.updateOptionsWrapper();
            return this;
        }
        getCurrentOptionDefinition() {
            return this.options.find(option => option.id === this.currentOption);
        }
        updateOptionsWrapper() {
            this.optionsWrapper.classes.remove(ClassPickerClasses.OptionsWrapper2, ClassPickerClasses.OptionsWrapper3, ClassPickerClasses.OptionsWrapper4, ClassPickerClasses.OptionsWrapper9);
            const count = this.optionsWrapper.element.childElementCount - 2;
            if (count > 1)
                this.optionsWrapper.classes.add(ClassPickerClasses[`OptionsWrapper${count > 4 ? 9 : count}`]);
            this.optionsWrapperBorders1.appendTo(this.optionsWrapper);
            this.optionsWrapperBorders2.appendTo(this.optionsWrapper);
        }
        async setCurrent(id, initial = false) {
            if (this.isDisabled && !initial)
                return;
            while (this.settingCurrent)
                await this.settingCurrent;
            if (id === this.currentOption)
                return;
            const chosenOption = this.options.find(option => option.id === id);
            if (!chosenOption?.button) {
                console.error(`Tried to change to option '${id}' that doesn't exist`);
                return;
            }
            const currentOption = this.getCurrentOptionDefinition();
            if (!currentOption || initial) {
                this.currentOption = id;
                this.currentButton.setDefinition(chosenOption);
                if (!currentOption) {
                    chosenOption.button.remove();
                    delete chosenOption.button;
                    this.updateOptionsWrapper();
                }
                else {
                    chosenOption.button.setDefinition(currentOption);
                    currentOption.button = chosenOption.button;
                    delete chosenOption.button;
                }
            }
            else {
                await (this.settingCurrent = Button_7.default.animateWipeMultiple([this.currentButton, chosenOption.button], async () => {
                    this.currentOption = id;
                    const button = chosenOption.button;
                    this.currentButton.setDefinition(chosenOption);
                    chosenOption.button.setDefinition(currentOption);
                    currentOption.button = chosenOption.button;
                    delete chosenOption.button;
                    let promise;
                    // eslint-disable-next-line @typescript-eslint/no-misused-promises
                    this.event.emit("selectClass", { option: id, button: button, item: chosenOption.item, setPromise: set => promise = set });
                    await promise;
                }));
            }
            delete this.settingCurrent;
        }
    }
    exports.default = ClassPicker;
    class ClassPickerButton extends Button_7.default {
        onMake() {
            super.onMake();
            this.classes.add(ClassPickerClasses.Button);
            Component_15.default.create()
                .classes.add(ClassPickerClasses.ButtonPreview)
                .appendTo(this);
        }
        setDefinition(definition) {
            if (!definition) {
                this.style.remove("--background");
                this.innerIcon?.remove();
            }
            else {
                if (definition.background)
                    this.style.set("--background", `url("${definition.background}")`);
                else
                    this.style.remove("--background");
                if (definition.icon)
                    this.addIcon(icon => icon.style.set("--icon", `url("${definition.icon}")`));
                else
                    this.innerIcon?.remove();
            }
            definition?.initialise?.(this);
            this.definition = definition;
            return this;
        }
    }
    exports.ClassPickerButton = ClassPickerButton;
});
define("ui/component/LoadedIcon", ["require", "exports", "ui/component/Component"], function (require, exports, Component_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoadedIconClasses = void 0;
    var LoadedIconClasses;
    (function (LoadedIconClasses) {
        LoadedIconClasses["Main"] = "loaded-icon";
        LoadedIconClasses["Loading"] = "loaded-icon-loading";
    })(LoadedIconClasses || (exports.LoadedIconClasses = LoadedIconClasses = {}));
    class LoadedIcon extends Component_16.default {
        onMake(path) {
            this.classes.add(LoadedIconClasses.Main);
            this.setPath(path);
            this.event.subscribe("load", () => this.classes.remove(LoadedIconClasses.Loading));
        }
        setPath(path) {
            if (this.attributes.get("src") !== path) {
                this.classes.add(LoadedIconClasses.Loading);
                this.attributes.set("src", path);
            }
            return this;
        }
    }
    LoadedIcon.defaultType = "img";
    exports.default = LoadedIcon;
});
define("ui/destiny/component/IItemComponent", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemClasses = void 0;
    var ItemClasses;
    (function (ItemClasses) {
        ItemClasses["Main"] = "item";
        ItemClasses["_HasThickBorder"] = "item--has-thick-border";
        ItemClasses["Icon"] = "item-icon";
        ItemClasses["Borderless"] = "item-borderless";
        ItemClasses["UniversalArmourOrnament"] = "item-universal-armour-ornament";
        ItemClasses["MomentWatermark"] = "item-moment-watermark";
        // MomentWatermarkCustom = "item-moment-watermark-custom",
        ItemClasses["MomentWatermark_Featured"] = "item-moment-watermark--featured";
        ItemClasses["IsMasterwork"] = "item-is-masterwork";
        ItemClasses["Masterwork"] = "item-masterwork";
        ItemClasses["MasterworkSpinny"] = "item-masterwork-spinny";
        ItemClasses["MasterworkShiftedDueToJunkBorder"] = "item-masterwork-shifted-due-to-junk-border";
        ItemClasses["Artifact"] = "item-artifact";
        ItemClasses["Shaped"] = "item-shaped";
        ItemClasses["CanEnhance"] = "item-can-enhance";
        ItemClasses["Adept"] = "item-adept";
        ItemClasses["Enhanced"] = "item-enhanced";
        ItemClasses["Deepsight"] = "item-deepsight";
        ItemClasses["DeepsightHasPattern"] = "item-deepsight-has-pattern";
        ItemClasses["DeepsightPattern"] = "item-deepsight-pattern";
        ItemClasses["DeepsightPatternUnlocked"] = "item-deepsight-pattern-unlocked";
        ItemClasses["Wishlist"] = "item-wishlist";
        ItemClasses["WishlistNoMatch"] = "item-wishlist-no-match";
        ItemClasses["WishlistIcon"] = "item-wishlist-icon";
        ItemClasses["WishlistNoMatchIcon"] = "item-wishlist-no-match-icon";
        ItemClasses["Extra"] = "item-extra";
        ItemClasses["ExtraInfo"] = "item-extra-info";
        ItemClasses["Extra_Empty"] = "item-extra--empty";
        ItemClasses["Extra_NonEmpty"] = "item-extra--non-empty";
        ItemClasses["ExtraNoneAfterQuantityOrPower"] = "item-extra-none-after-quantity-or-power";
        ItemClasses["Loading"] = "item-loading";
        ItemClasses["NotAcquired"] = "item-not-acquired";
        ItemClasses["Locked"] = "item-locked";
        ItemClasses["Unlocked"] = "item-unlocked";
        ItemClasses["Fomo"] = "item-fomo";
        ItemClasses["FomoIcon"] = "item-fomo-icon";
        ItemClasses["_Container"] = "item--container";
        ItemClasses["Artifice"] = "item-artifice";
        ItemClasses["_Loadouted"] = "item--loadouted";
        ItemClasses["LoadoutedBookmark"] = "item-loadouted-bookmark";
        ItemClasses["LoadoutedBookmark1"] = "item-loadouted-bookmark1";
        ItemClasses["Classified"] = "item-classified";
        ItemClasses["_Classified"] = "item--classified";
        ItemClasses["_FilteredOut"] = "item--filtered-out";
        ItemClasses["_Featured"] = "item--featured";
    })(ItemClasses || (exports.ItemClasses = ItemClasses = {}));
});
define("ui/destiny/component/Slot", ["require", "exports", "ui/component/Component"], function (require, exports, Component_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlotClasses = void 0;
    var SlotClasses;
    (function (SlotClasses) {
        SlotClasses["Main"] = "slot";
        SlotClasses["Empty"] = "slot-empty";
        SlotClasses["EmptyBorders2"] = "slot-empty-borders2";
        SlotClasses["Simple"] = "slot-empty-simple";
        SlotClasses["Wide"] = "slot--wide";
    })(SlotClasses || (exports.SlotClasses = SlotClasses = {}));
    class Slot extends Component_17.default {
        static setEmpty(component, empty = true) {
            return component?.classes.toggle(empty, SlotClasses.Empty);
        }
        static setSimple(component, simple = true) {
            return component?.classes.toggle(simple, SlotClasses.Simple);
        }
        static setWide(component, wide = true) {
            return component?.classes.toggle(wide, SlotClasses.Wide);
        }
        onMake() {
            this.classes.add(SlotClasses.Main);
            Component_17.default.create("span")
                .classes.add(SlotClasses.EmptyBorders2)
                .appendTo(this);
        }
        /**
         * @returns Whether this slot is set as empty. **Warning:** Does not actually check if there's content inside it.
         */
        isEmpty() {
            return this.classes.has(SlotClasses.Empty);
        }
        setEmpty(empty = true) {
            this.classes.toggle(empty, SlotClasses.Empty);
            return this;
        }
        setSimple(simple = true) {
            this.classes.toggle(simple, SlotClasses.Simple);
            return this;
        }
        setWide(wide = true) {
            this.classes.toggle(wide, SlotClasses.Wide);
            return this;
        }
    }
    Slot.defaultType = "span";
    exports.default = Slot;
});
define("model/models/Emblems", ["require", "exports", "model/Model", "model/models/Manifest"], function (require, exports, Model_12, Manifest_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Model_12.default.createDynamic("Weekly", async (api) => {
        api.emitProgress(0 / 2, "Loading manifest");
        const manifest = await api.subscribeProgressAndWait(Manifest_12.default, 1 / 2);
        const { DeepsightEmblemDefinition, DestinyInventoryItemDefinition } = manifest;
        api.emitProgress(1 / 2, "Loading emblems");
        const colours = await DeepsightEmblemDefinition.all();
        const deepsight = colours.map(colour => [colour.hash, colour]).toObject();
        const emblems = (await DestinyInventoryItemDefinition.all())
            .filter(emblem => deepsight[emblem.hash]);
        return emblems.map(definition => ({
            deepsight: deepsight[definition.hash],
            definition,
        }));
    });
});
define("ui/component/utility/Draggable", ["require", "exports", "utility/EventManager", "utility/decorator/Bound", "utility/maths/Vector2"], function (require, exports, EventManager_14, Bound_10, Vector2_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DragStage;
    (function (DragStage) {
        DragStage[DragStage["None"] = 0] = "None";
        DragStage[DragStage["Starting"] = 1] = "Starting";
        DragStage[DragStage["Dragging"] = 2] = "Dragging";
    })(DragStage || (DragStage = {}));
    class Draggable {
        constructor(host) {
            this.host = host;
            this.dragStage = DragStage.None;
            this.stickyDistance = 20;
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            host.addEventListener("mousedown", this.dragStart);
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            host.addEventListener("touchstart", this.dragStart);
        }
        setStickyDistance(stickyDistance) {
            this.stickyDistance = stickyDistance;
            return this;
        }
        setInputFilter(filter) {
            this.filter = filter;
            return this;
        }
        dragStart(event) {
            const position = this.getMousePosition(event);
            if (!position)
                return;
            this.mouseStartPosition = { x: position.clientX, y: position.clientY };
            this.dragStage = DragStage.Starting;
            if (event.type === "mousedown") {
                window.addEventListener("mousemove", this.drag, { passive: true });
                window.addEventListener("mouseup", this.dragEnd);
            }
            else {
                window.addEventListener("touchmove", this.drag, { passive: true });
                window.addEventListener("touchend", this.dragEnd);
            }
        }
        drag(event) {
            const position = this.getMousePosition(event);
            if (!position)
                return undefined;
            const offset = {
                x: position.clientX - this.mouseStartPosition.x,
                y: position.clientY - this.mouseStartPosition.y,
            };
            if (this.dragStage === DragStage.Starting && !Vector2_1.IVector2.distanceWithin(Vector2_1.IVector2.ZERO(), offset, this.stickyDistance)) {
                const event = EventManager_14.EventManager.emit(this.host, "moveStart", { offset: this.mouseStartPosition });
                if (event.defaultPrevented) {
                    // cancelled
                    this.dragEnd(event);
                    return undefined;
                }
                this.dragStage = DragStage.Dragging;
            }
            if (this.dragStage !== DragStage.Dragging)
                return undefined;
            const eventResult = { offset, mouse: { x: position.clientX, y: position.clientY } };
            EventManager_14.EventManager.emit(this.host, "move", eventResult);
            return eventResult;
        }
        dragEnd(event) {
            window.removeEventListener("mousemove", this.drag);
            window.removeEventListener("mouseup", this.dragEnd);
            window.removeEventListener("touchmove", this.drag);
            window.removeEventListener("touchend", this.dragEnd);
            if (this.dragStage === DragStage.Dragging) {
                const position = this.getMousePosition(event);
                let eventResult;
                if (position)
                    eventResult = this.drag(event);
                EventManager_14.EventManager.emit(this.host, "moveEnd", eventResult ?? { offset: { x: 0, y: 0 }, mouse: { x: event.clientX, y: event.clientY } });
            }
            this.dragStage = DragStage.None;
            this.mouseStartPosition = undefined;
        }
        getMousePosition(event) {
            const touch = event.touches?.[0];
            if (event.button !== 0 && !touch)
                return undefined;
            if (this.filter && !this.filter(event))
                return undefined;
            return touch ?? event;
        }
    }
    exports.default = Draggable;
    __decorate([
        Bound_10.default
    ], Draggable.prototype, "dragStart", null);
    __decorate([
        Bound_10.default
    ], Draggable.prototype, "drag", null);
    __decorate([
        Bound_10.default
    ], Draggable.prototype, "dragEnd", null);
});
define("ui/utility/UiEventBus", ["require", "exports", "utility/EventManager"], function (require, exports, EventManager_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const UiEventBus = EventManager_15.EventManager.make();
    let lastUsed = 0;
    const state = {};
    const mouseKeyMap = {
        [0]: "MouseLeft",
        [1]: "MouseMiddle",
        [2]: "MouseRight",
        [3]: "Mouse3",
        [4]: "Mouse4",
        [5]: "Mouse5",
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        [`${undefined}`]: "Mouse?",
    };
    function emitKeyEvent(e) {
        const input = e.target.closest("input[type=text], textarea, [contenteditable]");
        let usedByInput = !!input;
        const eventKey = e.key ?? mouseKeyMap[e.button];
        const eventType = e.type === "mousedown" ? "keydown" : e.type === "mouseup" ? "keyup" : e.type;
        if (eventType === "keydown")
            state[eventKey] = Date.now();
        let cancelInput = false;
        const event = {
            key: eventKey,
            ctrl: e.ctrlKey,
            shift: e.shiftKey,
            alt: e.altKey,
            used: usedByInput,
            input,
            use: (key, ...modifiers) => {
                if (event.used)
                    return false;
                const matches = event.matches(key, ...modifiers);
                if (matches)
                    event.used = true;
                return matches;
            },
            useOverInput: (key, ...modifiers) => {
                if (event.used && !usedByInput)
                    return false;
                const matches = event.matches(key, ...modifiers);
                if (matches) {
                    event.used = true;
                    usedByInput = false;
                }
                return matches;
            },
            matches: (key, ...modifiers) => {
                if (eventKey !== key)
                    return false;
                if (!modifiers.every(modifier => event[modifier]))
                    return false;
                return true;
            },
            cancelInput: () => cancelInput = true,
            hovering: (selector) => {
                const hovered = [...document.querySelectorAll(":hover")];
                return selector ? hovered[hovered.length - 1]?.closest(selector) ?? undefined : hovered[hovered.length - 1];
            },
        };
        if (eventType === "keyup") {
            event.usedAnotherKeyDuring = lastUsed > (state[eventKey] ?? 0);
            delete state[eventKey];
        }
        UiEventBus.emit(eventType, event);
        if (eventType === "keydown" && viewManager.view?.definition.subView && event.use("Escape")) {
            viewManager.hide();
        }
        if ((event.used && !usedByInput) || (usedByInput && cancelInput)) {
            e.preventDefault();
            lastUsed = Date.now();
        }
    }
    document.addEventListener("keydown", emitKeyEvent);
    document.addEventListener("keyup", emitKeyEvent);
    document.addEventListener("mousedown", emitKeyEvent);
    document.addEventListener("mouseup", emitKeyEvent);
    document.addEventListener("click", emitKeyEvent);
    Object.defineProperty(MouseEvent.prototype, "used", {
        get() {
            return this._used ?? false;
        },
    });
    Object.defineProperty(MouseEvent.prototype, "use", {
        value: function (key, ...modifiers) {
            if (this._used)
                return false;
            const matches = this.matches(key, ...modifiers);
            if (matches) {
                this._used = true;
                // allow click & contextmenu handlers to be considered "used" for IKeyUpEvents
                lastUsed = Date.now();
            }
            return matches;
        },
    });
    Object.defineProperty(MouseEvent.prototype, "matches", {
        value: function (key, ...modifiers) {
            if (mouseKeyMap[this.button] !== key)
                return false;
            if (!modifiers.every(modifier => this[`${modifier}Key`]))
                return false;
            return true;
        },
    });
    exports.default = UiEventBus;
});
define("ui/component/utility/Sortable", ["require", "exports", "ui/component/utility/Draggable", "ui/utility/UiEventBus", "utility/decorator/Bound", "utility/EventManager", "utility/maths/Vector2"], function (require, exports, Draggable_1, UiEventBus_1, Bound_11, EventManager_16, Vector2_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SortableClasses = void 0;
    var SortableClasses;
    (function (SortableClasses) {
        SortableClasses["Item"] = "sortable-item";
        SortableClasses["Slot"] = "sortable-slot";
        SortableClasses["Moving"] = "sortable-moving";
        SortableClasses["Child"] = "sortable-item-child";
    })(SortableClasses || (exports.SortableClasses = SortableClasses = {}));
    class Sortable {
        constructor(host) {
            this.host = host;
            this.event = EventManager_16.EventManager.make();
            this.draggables = new WeakMap();
            this.sortStickyDistance = 0;
            for (const item of host.children) {
                item.classList.add(SortableClasses.Item);
                item.setAttribute("tabindex", "0");
                this.draggables.set(item, new Draggable_1.default(item)
                    .setStickyDistance(this.sortStickyDistance)
                    .setInputFilter(this.sortInputFilter));
                item.addEventListener("moveStart", this.onItemMoveStart);
                item.addEventListener("move", this.onItemMove);
                item.addEventListener("moveEnd", this.onItemMoveEnd);
            }
            UiEventBus_1.default.subscribe("keydown", this.onKeydown);
        }
        dispose() {
            for (const child of this.host.children) {
                child.removeEventListener("moveStart", this.onItemMoveStart);
                child.removeEventListener("move", this.onItemMove);
                child.removeEventListener("moveEnd", this.onItemMoveEnd);
            }
            UiEventBus_1.default.unsubscribe("keydown", this.onKeydown);
        }
        setSortStickyDistance(stickyDistance) {
            this.sortStickyDistance = stickyDistance;
            for (const item of this.host.children)
                this.draggables.get(item)?.setStickyDistance(stickyDistance);
            return this;
        }
        setInputFilter(filter) {
            this.sortInputFilter = filter;
            for (const item of this.host.children)
                this.draggables.get(item)?.setInputFilter(filter);
            return this;
        }
        sortUp(item) {
            if (item === this.host.children[0])
                return false;
            this.host.insertBefore(item, item.previousElementSibling);
            this.commit();
            return true;
        }
        sortDown(item) {
            if (item === this.host.children[this.host.children.length - 1])
                return false;
            this.host.insertBefore(item, item.nextElementSibling?.nextElementSibling ?? null);
            this.commit();
            return true;
        }
        commit() {
            this.event.emit("commit");
        }
        onItemMoveStart(e) {
            const event = e;
            const item = event.target;
            const itemBox = item.getBoundingClientRect();
            const hostBox = this.host.getBoundingClientRect();
            this.savedPosition = { x: itemBox.left - hostBox.left, y: itemBox.top - hostBox.top };
            item.classList.add(SortableClasses.Moving);
            this.slot ??= document.createElement("div");
            this.slot.classList.add(SortableClasses.Slot);
            this.host.insertBefore(this.slot, item);
            this.onItemMove({ target: item, mouse: event.mouse, offset: Vector2_2.IVector2.ZERO() });
        }
        onItemMove(e) {
            const event = e;
            const item = event.target;
            const change = event.offset;
            const position = { x: (this.savedPosition?.x ?? 0) + change.x, y: (this.savedPosition?.y ?? 0) + change.y };
            item.style.left = `${position.x}px`;
            item.style.top = `${position.y}px`;
            const before = this.findItemBefore(item, position, [...this.host.children]);
            this.host.insertBefore(this.slot, !before ? this.host.firstElementChild : before.nextElementSibling);
        }
        findItemBefore(item, position, children) {
            const box = this.host.getBoundingClientRect();
            const thisTop = box.top;
            const thisLeft = box.left;
            let lastTop;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child === item) {
                    continue;
                }
                let { left, top, width, height } = child.getBoundingClientRect();
                // adjust child position by the position of the host in the document
                left -= thisLeft;
                top -= thisTop;
                // if this is the first item
                if (i === (children[0] === item ? 1 : 0)) {
                    if (position.y < top) {
                        // if we're higher than the first item, sort to the start
                        return undefined;
                    }
                    if (position.x < left && position.y < top + height) {
                        // if we're left of the first item, and we're not below the first item, sort to the start
                        return undefined;
                    }
                }
                // if we're on a different row
                if (lastTop !== undefined && lastTop !== top) {
                    // if the new row's top is past the hovered position's y, sort to the end of the previous row
                    if (position.y < top) {
                        return children[i - 1];
                    }
                    // if the position is within this row vertically, but before any item, sort at the start of this row
                    if (position.y >= top && position.y < top + height && position.x < left) {
                        return children[i - 1];
                    }
                }
                lastTop = top;
                // if we're hovering inside an item's box
                if (position.x >= left && position.x < left + width && position.y >= top && position.y < top + height) {
                    return child;
                }
            }
            // we weren't inside anything, and we didn't get put at the start, so we must be after everything instead
            return children[children.length - 1];
        }
        onItemMoveEnd(e) {
            const event = e;
            event.target.classList.remove(SortableClasses.Moving);
            event.target.style.removeProperty("left");
            event.target.style.removeProperty("top");
            this.host.insertBefore(event.target, this.slot?.nextElementSibling ?? null);
            this.slot?.remove();
            this.commit();
        }
        onKeydown(event) {
            if (!document.contains(this.host)) {
                this.dispose();
                return;
            }
            const item = document.activeElement;
            if (item.parentElement !== this.host)
                return;
            switch (event.key) {
                case "ArrowUp":
                case "ArrowLeft":
                    if (!this.sortUp(item))
                        return;
                    break;
                case "ArrowDown":
                case "ArrowRight":
                    if (!this.sortDown(item))
                        return;
                    break;
                default:
                    return;
            }
            event.use(event.key);
            item.focus();
        }
    }
    exports.default = Sortable;
    __decorate([
        Bound_11.default
    ], Sortable.prototype, "onItemMoveStart", null);
    __decorate([
        Bound_11.default
    ], Sortable.prototype, "onItemMove", null);
    __decorate([
        Bound_11.default
    ], Sortable.prototype, "onItemMoveEnd", null);
    __decorate([
        Bound_11.default
    ], Sortable.prototype, "onKeydown", null);
});
define("ui/destiny/sort/sorts/SortAcquired", ["require", "exports", "model/models/ProfileBatch", "model/models/items/Collectibles", "model/models/items/Item", "ui/destiny/sort/Sort"], function (require, exports, ProfileBatch_7, Collectibles_2, Item_2, Sort_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_1.ISort.create({
        id: Sort_1.default.Acquired,
        name: "Acquired",
        sort: (a, b) => Number(!!isAcquired(b)) - Number(!!isAcquired(a)),
        renderSortable: sortable => sortable.icon,
    });
    function isAcquired(item) {
        return Collectibles_2.default.isAcquired(ProfileBatch_7.default.latest, item.definition.collectibleHash)
            || (item instanceof Item_2.default && !item.isNotAcquired());
    }
});
define("ui/destiny/sort/sorts/SortAmmoType", ["require", "exports", "model/models/enum/AmmoTypes", "ui/destiny/component/EnumIcon", "ui/destiny/sort/Sort"], function (require, exports, AmmoTypes_2, EnumIcon_2, Sort_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_2.ISort.create({
        id: Sort_2.default.AmmoType,
        name: "Ammo Type",
        shortName: "Ammo",
        sort: (a, b) => (a.definition.equippingBlock?.ammoType ?? 0 /* DestinyAmmunitionType.None */) - (b.definition.equippingBlock?.ammoType ?? 0 /* DestinyAmmunitionType.None */),
        renderSortable: sortable => sortable.icon,
        render: item => !item.definition.equippingBlock?.ammoType ? undefined
            : EnumIcon_2.default.create([AmmoTypes_2.default, item.definition.equippingBlock?.ammoType])
                .classes.add("item-sort-ammo-type"),
    });
});
define("ui/destiny/sort/sorts/SortBreakerType", ["require", "exports", "model/models/enum/BreakerTypes", "ui/component/Component", "ui/destiny/component/EnumIcon", "ui/destiny/sort/Sort"], function (require, exports, BreakerTypes_3, Component_18, EnumIcon_3, Sort_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_3.ISort.create({
        id: Sort_3.default.BreakerType,
        name: "Stun",
        shortName: "Stun",
        sort: (a, b) => (a.breakerTypes?.sort(type => type.enumValue)[0]?.enumValue ?? 0) - (b.breakerTypes?.sort(type => type.enumValue)[0]?.enumValue ?? 0),
        renderSortable: sortable => {
            const baseIcon = sortable.icon;
            EnumIcon_3.default.create([BreakerTypes_3.default, 1 /* DestinyBreakerType.ShieldPiercing */])
                .classes.add(...baseIcon.classes.all())
                .prependTo(sortable.title);
            baseIcon.remove();
        },
        render: (item, breakerTypes = item.breakerTypes) => !breakerTypes?.length ? undefined
            : Component_18.default.create("span")
                .classes.add("item-sort-breaker-type-wrapper")
                .append(...breakerTypes
                .sort(type => -type.enumValue)
                .map(type => EnumIcon_3.default.create([BreakerTypes_3.default, type.enumValue])
                .classes.add("item-sort-breaker-type"))),
    });
});
define("ui/destiny/sort/sorts/SortCanShape", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_4.ISort.create({
        id: Sort_4.default.CanShape,
        name: "Can Shape",
        renderSortable: sortable => sortable.icon,
        sort: (a, b) => +b.canShape() - +a.canShape(),
    });
});
define("ui/destiny/sort/sorts/SortDamageType", ["require", "exports", "model/models/enum/DamageTypes", "ui/destiny/component/EnumIcon", "ui/destiny/sort/Sort"], function (require, exports, DamageTypes_2, EnumIcon_4, Sort_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_5.ISort.create({
        id: Sort_5.default.DamageType,
        name: "Damage Type",
        shortName: "Damage",
        sort: (a, b) => (b.getDamageType() ?? 0 /* DamageType.None */) - (a.getDamageType() ?? 0 /* DamageType.None */),
        renderSortable: sortable => sortable.icon
            .tweak(EnumIcon_4.default.applyIconVar, DamageTypes_2.default, 1 /* DamageType.Kinetic */),
        render: (item, damageType = item.getDamageType()) => !damageType ? undefined
            : EnumIcon_4.default.create([DamageTypes_2.default, damageType])
                .classes.add("item-sort-damage-type"),
    });
});
define("ui/destiny/sort/sorts/SortEnergy", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort"], function (require, exports, Component_19, Sort_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_6.ISort.create({
        id: Sort_6.default.Energy,
        name: "Energy",
        sort: (a, b) => (b.instance?.energy?.energyCapacity ?? 0) - (a.instance?.energy?.energyCapacity ?? 0),
        renderSortable: sortable => sortable.icon,
        render: item => {
            if (!item.instance?.energy?.energyCapacity)
                return undefined;
            return Component_19.default.create("span")
                .classes.add("item-energy")
                .append(Component_19.default.create("span")
                .classes.add("item-energy-icon"))
                .text.set(`${item.instance?.energy?.energyCapacity ?? 0}`);
        },
    });
});
define("ui/destiny/sort/sorts/SortExotic", ["require", "exports", "ui/destiny/sort/Sort", "ui/utility/DisplayProperties"], function (require, exports, Sort_7, DisplayProperties_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_7.ISort.create({
        id: Sort_7.default.Exotic,
        name: "Exotic",
        renderSortable: sortable => sortable.icon,
        sort: (a, b) => a.isExotic() && b.isExotic() ? DisplayProperties_1.default.name(a.definition, "").localeCompare(DisplayProperties_1.default.name(b.definition, ""))
            : Math.max(b.definition.inventory?.tierType ?? 0 /* TierType.Unknown */, 5 /* TierType.Superior */) - Math.max(a.definition.inventory?.tierType ?? 0 /* TierType.Unknown */, 5 /* TierType.Superior */),
    });
});
define("ui/destiny/sort/sorts/SortFeatured", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_8.ISort.create({
        id: Sort_8.default.Featured,
        name: "Featured",
        sort: (a, b) => Number(!!b.definition.isFeaturedItem) - Number(!!a.definition.isFeaturedItem),
        renderSortable: sortable => sortable.icon,
    });
});
define("ui/destiny/sort/sorts/SortHarmonizable", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort"], function (require, exports, Component_20, Sort_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_9.ISort.create({
        id: Sort_9.default.Harmonizable,
        name: "Deepsight Harmonizer",
        shortName: "Harmonizer",
        renderSortable: sortable => sortable.icon,
        render: item => {
            if (!item.deepsight?.activation)
                return undefined;
            return Component_20.default.create("span")
                .classes.add("item-sort-harmonizable")
                .append(Component_20.default.create("span")
                .classes.add("item-sort-harmonizable-icon"))
                .append(Component_20.default.create("span")
                .classes.add("item-sort-harmonizable-numerator")
                .text.set(`${item.deepsight?.pattern?.progress?.progress ?? 0}`))
                .append(Component_20.default.create("span")
                .classes.add("item-sort-harmonizable-separator")
                .text.set("/"))
                .append(Component_20.default.create("span")
                .classes.add("item-sort-harmonizable-denominator")
                .text.set(`${item.deepsight?.pattern?.progress?.completionValue}`));
        },
        sort: (a, b) => getSortIndex(b) - getSortIndex(a),
    });
    function getSortIndex(item) {
        return Number(!!item.deepsight?.activation && (item.deepsight?.pattern?.progress?.progress ?? 0) + 1);
    }
});
define("ui/destiny/sort/sorts/SortLocked", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_10.ISort.create({
        id: Sort_10.default.Locked,
        name: "Locked",
        sort: (a, b) => Number(!!b.isLocked()) - Number(!!a.isLocked()),
        renderSortable: sortable => sortable.icon,
    });
});
define("ui/destiny/sort/sorts/SortMasterwork", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_11.ISort.create({
        id: Sort_11.default.Masterwork,
        name: "Masterwork",
        renderSortable: sortable => sortable.icon,
        sort: (a, b) => Number(!!b.isMasterwork()) - Number(!!a.isMasterwork()),
    });
});
define("ui/destiny/sort/sorts/SortMoment", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_12.ISort.create({
        id: Sort_12.default.Moment,
        name: "Moment",
        renderSortable: sortable => sortable.icon,
        sort: (a, b) => (b.moment?.hash ?? -1) - (a.moment?.hash ?? -1),
    });
});
define("ui/destiny/sort/sorts/SortName", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort"], function (require, exports, Component_21, Sort_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_13.ISort.create({
        id: Sort_13.default.Name,
        name: "Name",
        sort: (a, b) => a.definition?.displayProperties.name.localeCompare(b.definition?.displayProperties.name ?? "") ?? 0,
        renderSortable: sortable => sortable.icon,
        render: (item) => item.bucket?.isPostmaster() ? undefined : Component_21.default.create()
            .classes.add("item-name")
            .append(Component_21.default.create("span")
            .classes.add("item-name-text")
            .text.set(`${item.definition?.displayProperties.name}`)),
    });
});
define("ui/destiny/sort/sorts/SortPattern", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort"], function (require, exports, Component_22, Sort_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_14.ISort.create({
        id: Sort_14.default.Pattern,
        name: "Pattern",
        sort: (a, b) => 0
            || Number(b.hasPattern()) - Number(a.hasPattern())
            || (!b.hasPattern() ? 0 : b.deepsight?.pattern?.progress?.progress ?? 0) - (!a.hasPattern() ? 0 : a.deepsight?.pattern?.progress?.progress ?? 0),
        renderSortable: sortable => sortable.icon,
        render: item => {
            if (!item.bucket.isCollections() || !item.hasPattern())
                return undefined;
            return Component_22.default.create("span")
                .classes.add("item-sort-harmonizable")
                .append(Component_22.default.create("span")
                .classes.add("item-sort-harmonizable-icon"))
                .append(Component_22.default.create("span")
                .classes.add("item-sort-harmonizable-numerator")
                .text.set(`${item.deepsight?.pattern?.progress?.progress ?? 0}`))
                .append(Component_22.default.create("span")
                .classes.add("item-sort-harmonizable-separator")
                .text.set("/"))
                .append(Component_22.default.create("span")
                .classes.add("item-sort-harmonizable-denominator")
                .text.set(`${item.deepsight?.pattern?.progress?.completionValue}`));
        },
    });
});
define("ui/destiny/component/ItemPowerLevel", ["require", "exports", "ui/component/Component"], function (require, exports, Component_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemPowerLevelClasses = void 0;
    var ItemPowerLevelClasses;
    (function (ItemPowerLevelClasses) {
        ItemPowerLevelClasses["Main"] = "item-power-level";
        ItemPowerLevelClasses["Icon"] = "item-power-level-icon";
        ItemPowerLevelClasses["Eighths"] = "item-power-level-eighths";
        ItemPowerLevelClasses["Difference"] = "item-power-level-difference";
        ItemPowerLevelClasses["DifferenceBetter"] = "item-power-level-difference-better";
        ItemPowerLevelClasses["DifferenceWorse"] = "item-power-level-difference-worse";
    })(ItemPowerLevelClasses || (exports.ItemPowerLevelClasses = ItemPowerLevelClasses = {}));
    class ItemPowerLevel extends Component_23.default {
        onMake(power, difference) {
            this.classes.add(ItemPowerLevelClasses.Main);
            if (power !== undefined)
                this.setPower(power, difference);
        }
        setPower(power, difference) {
            this.removeContents();
            this.append(Component_23.default.create().classes.add(ItemPowerLevelClasses.Icon))
                .text.add(`${Math.floor(power)}`);
            if (!Number.isInteger(power))
                Component_23.default.create()
                    .classes.add(ItemPowerLevelClasses.Eighths)
                    .text.set(`${Math.round(power % 1 * 8)}`)
                    .appendTo(this);
            if (difference)
                Component_23.default.create()
                    .classes.add(ItemPowerLevelClasses.Difference, difference > 0 ? ItemPowerLevelClasses.DifferenceBetter : ItemPowerLevelClasses.DifferenceWorse)
                    .text.set(difference > 0 ? `+${difference}` : `${difference}`)
                    .appendTo(this);
        }
    }
    exports.default = ItemPowerLevel;
});
define("ui/destiny/sort/sorts/SortPower", ["require", "exports", "ui/destiny/component/ItemPowerLevel", "ui/destiny/sort/Sort"], function (require, exports, ItemPowerLevel_1, Sort_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_15.ISort.create({
        id: Sort_15.default.Power,
        name: "Power",
        sort: (a, b) => (b.getPower() ?? 0) - (a.getPower() ?? 0),
        renderSortable: sortable => sortable.icon.classes.add(ItemPowerLevel_1.ItemPowerLevelClasses.Icon),
        render: item => {
            const power = item.getPower();
            if (power === undefined)
                return undefined;
            return ItemPowerLevel_1.default.create([power]);
        },
    });
});
define("ui/destiny/sort/sorts/SortQuantity", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort"], function (require, exports, Component_24, Sort_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_16.ISort.create({
        id: Sort_16.default.Quantity,
        name: "Quantity",
        sort: (a, b) => b.reference.quantity - a.reference.quantity,
        renderSortable: sortable => sortable.icon,
        render: item => !(item.reference.quantity > 1) ? undefined : Component_24.default.create("span")
            .classes.add("item-quantity")
            .classes.toggle(item.reference.quantity >= (item.definition.inventory?.maxStackSize ?? Infinity), "item-quantity-max")
            .text.set(`x${item.reference.quantity.toLocaleString()}`),
    });
});
define("ui/destiny/sort/sorts/SortRarity", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_17.ISort.create({
        id: Sort_17.default.Rarity,
        name: "Rarity",
        renderSortable: sortable => sortable.icon,
        sort: (a, b) => (b.definition.inventory?.tierType ?? 0 /* TierType.Unknown */) - (a.definition.inventory?.tierType ?? 0 /* TierType.Unknown */),
    });
});
define("ui/destiny/sort/sorts/SortShaped", ["require", "exports", "ui/destiny/sort/Sort"], function (require, exports, Sort_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_18.ISort.create({
        id: Sort_18.default.Shaped,
        name: "Shaped",
        renderSortable: sortable => sortable.icon,
        sort: (a, b) => getSortIndex(b) - getSortIndex(a),
    });
    function getSortIndex(item) {
        if (item.bucket.isCollections())
            return item.hasShapedCopy() ? 1 : 0;
        return Number(!!item.shaped) * 10000000
            + (item.shaped?.level?.progress.progress ?? 0) * 10000
            + (item.shaped?.progress?.progress.progress ?? 0);
    }
});
define("ui/component/Details", ["require", "exports", "ui/component/Button", "ui/component/Component"], function (require, exports, Button_8, Component_25) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DetailsClasses = void 0;
    var DetailsClasses;
    (function (DetailsClasses) {
        DetailsClasses["Main"] = "details";
        DetailsClasses["Summary"] = "details-summary";
        DetailsClasses["Open"] = "details-open";
        DetailsClasses["Closed"] = "details-closed";
    })(DetailsClasses || (exports.DetailsClasses = DetailsClasses = {}));
    class Details extends Component_25.default {
        onMake(...args) {
            super.onMake(...args);
            this.classes.add(DetailsClasses.Main, DetailsClasses.Closed);
            this.summary = Button_8.default.create("summary")
                .classes.add(DetailsClasses.Summary)
                .event.subscribe("click", () => this.toggle())
                .appendTo(this);
        }
        isOpen() {
            return !this.classes.has(DetailsClasses.Closed);
        }
        open() {
            this.classes.remove(DetailsClasses.Closed);
            for (const child of this.element.children)
                child.removeAttribute("inert");
            this.event.emit("toggle");
            return this;
        }
        close() {
            this.classes.add(DetailsClasses.Closed);
            for (const child of this.element.children)
                if (child !== this.summary.element)
                    child.setAttribute("inert", "");
            this.event.emit("toggle");
            return this;
        }
        toggle(open) {
            const isOpen = !this.classes.has(DetailsClasses.Closed);
            if (open !== undefined && isOpen === open)
                return this;
            open = open === undefined ? !isOpen : open;
            return open ? this.open() : this.close();
        }
        removeContents() {
            while (this.element.lastChild && this.element.lastChild !== this.summary.element)
                this.element.lastChild?.remove();
            return this;
        }
    }
    exports.default = Details;
});
define("ui/component/form/Checkbox", ["require", "exports", "ui/component/Component"], function (require, exports, Component_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CheckboxClasses = void 0;
    var CheckboxClasses;
    (function (CheckboxClasses) {
        CheckboxClasses["Main"] = "checkbox";
        CheckboxClasses["Checkbox"] = "checkbox-checkbox";
        CheckboxClasses["Label"] = "checkbox-label";
        CheckboxClasses["Description"] = "checkbox-description";
    })(CheckboxClasses || (exports.CheckboxClasses = CheckboxClasses = {}));
    class Checkbox extends Component_26.default {
        get checked() {
            return this.checkbox.element.checked;
        }
        set checked(checked) {
            this.checkbox.element.checked = checked;
            this.event.emit("update", { checked });
        }
        get description() {
            const description = Component_26.default.create("p")
                .classes.add(CheckboxClasses.Description)
                .appendTo(this);
            Object.defineProperty(this, "description", { value: description });
            return description;
        }
        onMake(checked) {
            this.classes.add(CheckboxClasses.Main);
            this.label = Component_26.default.create("span")
                .classes.add(CheckboxClasses.Label)
                .appendTo(this);
            this.checkbox = Component_26.default.create("input")
                .classes.add(CheckboxClasses.Checkbox)
                .attributes.set("type", "checkbox")
                .event.subscribe("change", () => this.event.emit("update", { checked: this.checkbox.element.checked }))
                .appendTo(this);
            this.checkbox.element.checked = !!checked;
        }
    }
    Checkbox.defaultType = "label";
    exports.default = Checkbox;
});
define("ui/component/form/RangeInput", ["require", "exports", "ui/component/Component", "utility/decorator/Bound"], function (require, exports, Component_27, Bound_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangeInputClasses = void 0;
    var RangeInputClasses;
    (function (RangeInputClasses) {
        RangeInputClasses["Main"] = "range-input";
    })(RangeInputClasses || (exports.RangeInputClasses = RangeInputClasses = {}));
    class RangeInput extends Component_27.default {
        get value() {
            return this.element.valueAsNumber;
        }
        set value(value) {
            this.element.valueAsNumber = value;
            this.update();
        }
        onMake(config) {
            this.classes.add(RangeInputClasses.Main)
                .attributes.set("type", "range");
            config ??= { min: 0, max: 1, step: 0.01, default: 0 };
            this.attributes.set("min", `${config.min ?? 0}`)
                .attributes.set("max", `${config.max}`)
                .attributes.set("step", `${config.step ?? 1}`)
                .attributes.set("value", `${config.default ?? 0}`);
            this.event.subscribe("input", this.update);
        }
        update() {
            this.style.set("--value", `${(this.element.valueAsNumber - +this.element.min) / (+this.element.max - +this.element.min)}`);
        }
    }
    RangeInput.defaultType = "input";
    exports.default = RangeInput;
    __decorate([
        Bound_12.default
    ], RangeInput.prototype, "update", null);
});
define("ui/destiny/sort/sorts/SortStatDistribution", ["require", "exports", "model/models/Characters", "model/models/Inventory", "model/models/Manifest", "ui/component/Component", "ui/component/Details", "ui/component/Loadable", "ui/component/form/Checkbox", "ui/component/form/RangeInput", "ui/destiny/sort/Sort", "ui/destiny/utility/Stat", "utility/EventManager", "utility/decorator/Bound"], function (require, exports, Characters_4, Inventory_1, Manifest_13, Component_28, Details_1, Loadable_2, Checkbox_1, RangeInput_1, Sort_19, Stat_2, EventManager_17, Bound_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatDistributionClasses = void 0;
    var StatDistributionClasses;
    (function (StatDistributionClasses) {
        StatDistributionClasses["ClassConfiguration"] = "stat-distribution-class-configuration";
        StatDistributionClasses["ClassButton"] = "stat-distribution-class-configuration-button";
        StatDistributionClasses["StatRows"] = "stat-distribution-stat-rows";
        StatDistributionClasses["Group"] = "stat-distribution-stat-group";
        StatDistributionClasses["Row"] = "stat-distribution-stat";
        StatDistributionClasses["Label"] = "stat-distribution-stat-label";
        StatDistributionClasses["Range"] = "stat-distribution-stat-range";
        StatDistributionClasses["Value"] = "stat-distribution-stat-value";
        StatDistributionClasses["Enabled"] = "stat-distribution-stat-enabled";
    })(StatDistributionClasses || (exports.StatDistributionClasses = StatDistributionClasses = {}));
    const displayEvents = EventManager_17.EventManager.make();
    var StatDistributionDisplayClasses;
    (function (StatDistributionDisplayClasses) {
        StatDistributionDisplayClasses["Main"] = "item-stat-distribution";
        StatDistributionDisplayClasses["Value"] = "item-stat-distribution-value";
    })(StatDistributionDisplayClasses || (StatDistributionDisplayClasses = {}));
    class StatDistributionDisplay extends Component_28.default {
        constructor() {
            super(...arguments);
            this.contained = false;
        }
        onMake(item) {
            this.item = item;
            this.classes.add(StatDistributionDisplayClasses.Main);
            this.value = Component_28.default.create("span")
                .classes.add(StatDistributionDisplayClasses.Value)
                .appendTo(this);
            displayEvents.subscribe("update", this.update);
            this.update();
        }
        update() {
            if (!document.contains(this.element) && this.contained) {
                displayEvents.unsubscribe("update", this.update);
                return;
            }
            this.contained = true;
            const distribution = Stat_2.IStatDistribution.get(this.item);
            this.style.set("--value", `${distribution.overall}`);
            this.value.text.set(`${Math.floor(distribution.overall * 100)}%`);
        }
    }
    __decorate([
        Bound_13.default
    ], StatDistributionDisplay.prototype, "update", null);
    exports.default = Sort_19.ISort.create({
        id: Sort_19.default.StatDistribution,
        name: "Stat Distribution",
        shortName: "Stats",
        sort: (a, b) => Stat_2.IStatDistribution.get(b).overall - Stat_2.IStatDistribution.get(a).overall,
        render: item => Stat_2.IStatDistribution.get(item).overall <= 0 ? undefined : StatDistributionDisplay.create([item]),
        renderSortable: sortable => sortable.icon.text.set("%"),
        renderSortableOptions: (wrapper, update) => Loadable_2.default.create(Inventory_1.default.await())
            .onReady(inventory => {
            const container = Component_28.default.create();
            const classes = Characters_4.default.getSortedClasses();
            for (let i = 0; i < classes.length; i++) {
                const classType = classes[i];
                const characterDetails = Details_1.default.create()
                    .classes.add(StatDistributionClasses.ClassConfiguration)
                    .tweak(details => details.summary
                    .text.set(classType === 0 /* DestinyClass.Titan */ ? "Titan" : classType === 1 /* DestinyClass.Hunter */ ? "Hunter" : "Warlock")
                    .classes.add(StatDistributionClasses.ClassButton)
                    .event.subscribe("click", () => {
                    for (const details of container.children())
                        if (details !== characterDetails)
                            details.close();
                }))
                    .toggle(i === 0)
                    .appendTo(container);
                const configuration = Component_28.default.create()
                    .classes.add(StatDistributionClasses.StatRows)
                    .appendTo(characterDetails);
                for (const group of Stat_2.ARMOUR_STAT_GROUPS)
                    StatGroupDisplay.create([group, classType])
                        .event.subscribe("update", update)
                        .appendTo(configuration);
            }
            return container;
        })
            .appendTo(wrapper),
    });
    class StatRow extends Component_28.default {
        get value() {
            return this.input.value;
        }
        set value(value) {
            this.input.value = value;
            this.update();
        }
        async onMake(stat, classType) {
            this.stat = stat;
            this.classType = classType;
            this.classes.add(StatDistributionClasses.Row);
            const enabled = Stat_2.IStatDistribution.isEnabled(stat, classType);
            this.classes.toggle(enabled, StatDistributionClasses.Enabled);
            this.checkbox = Checkbox_1.default.create([enabled])
                .classes.add(StatDistributionClasses.Label)
                .event.subscribe("update", ({ checked }) => {
                Stat_2.IStatDistribution.setIsEnabled(stat, classType, checked);
                this.update(false, true);
                this.event.emit("done");
                this.input.attributes.set("tabindex", checked ? undefined : "-1");
                this.classes.toggle(checked, StatDistributionClasses.Enabled);
            })
                .appendTo(this);
            this.input = RangeInput_1.default.create([{ min: Stat_2.ARMOUR_STAT_MIN, max: Stat_2.ARMOUR_STAT_MAX }])
                .classes.add(StatDistributionClasses.Range)
                .style.set("--visual-min", `${Stat_2.ARMOUR_STAT_MIN / Stat_2.ARMOUR_STAT_MAX}`)
                .attributes.set("tabindex", enabled ? undefined : "-1")
                .event.subscribe("input", this.update)
                .event.subscribe("change", () => this.event.emit("done"))
                .appendTo(this);
            this.valueText = Component_28.default.create()
                .classes.add(StatDistributionClasses.Value)
                .appendTo(this);
            this.value = Stat_2.IStatDistribution.getPreferredValue(stat, classType);
            this.update();
            const { DestinyStatDefinition } = await Manifest_13.default.await();
            const definition = await DestinyStatDefinition.get(stat);
            this.checkbox.label.text.set(definition?.displayProperties.name ?? "Unknown");
        }
        update(event, force = false) {
            if (this.oldValue === this.input.value && !force)
                return this;
            this.valueText.text.set(`${this.input.value}`);
            const oldValue = this.oldValue;
            this.oldValue = this.input.value;
            Stat_2.IStatDistribution.setPreferredValue(this.stat, this.classType, this.input.value);
            // if (event)
            // 	this.checkbox.checked = true;
            if (event)
                this.event.emit("update", { value: this.input.value, oldValue });
            return this;
        }
    }
    __decorate([
        Bound_13.default
    ], StatRow.prototype, "update", null);
    class StatGroupDisplay extends Component_28.default {
        onMake(group, classType) {
            this.classes.add(StatDistributionClasses.Group);
            const statRows = {};
            for (const stat of group) {
                statRows[stat] = StatRow.create([stat, classType])
                    .event.subscribe("update", event => {
                    let difference = event.value - event.oldValue;
                    const modificationOrder = group.map(stat => statRows[stat]).sort((a, b) => b.value - a.value);
                    let i = 0;
                    for (const otherRow of modificationOrder) {
                        if (otherRow.stat === stat)
                            continue;
                        const oldValue = otherRow.value;
                        otherRow.value -= i++ === 0 ? Math.ceil(difference / 2) : difference;
                        difference += otherRow.value - oldValue;
                    }
                    // ensure stats are the right amount
                    const total = modificationOrder.reduce((previous, current) => previous + current.value, 0);
                    if (total !== Stat_2.ARMOUR_GROUP_STATS_MAX) {
                        let difference = Stat_2.ARMOUR_GROUP_STATS_MAX - total;
                        for (const otherRow of modificationOrder) {
                            if (otherRow.stat === stat)
                                continue;
                            const oldValue = otherRow.value;
                            otherRow.value += i++ === 0 ? Math.ceil(difference / 2) : difference;
                            difference -= otherRow.value - oldValue;
                        }
                    }
                    displayEvents.emit("update");
                })
                    .event.subscribe("done", () => this.event.emit("update"))
                    .appendTo(this);
            }
            for (const stat of group)
                statRows[stat].update(false, true);
        }
    }
});
define("ui/destiny/sort/sorts/SortStatDistributionUniqueness", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort", "ui/destiny/utility/Stat", "utility/maths/Maths"], function (require, exports, Component_29, Sort_20, Stat_3, Maths_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ARMOUR_STATS = Stat_3.ARMOUR_STAT_GROUPS.flat();
    const ARCHETYPES = [
        [Stat_3.Stat.Mobility, Stat_3.Stat.Discipline], // Gunner
        [Stat_3.Stat.Strength, Stat_3.Stat.Resilience], // Brawler
        [Stat_3.Stat.Recovery, Stat_3.Stat.Mobility], // Specialist
        [Stat_3.Stat.Intellect, Stat_3.Stat.Strength], // Paragon
        [Stat_3.Stat.Discipline, Stat_3.Stat.Intellect], // Grenadier
        [Stat_3.Stat.Resilience, Stat_3.Stat.Recovery], // Bulwark
    ]
        .flatMap(([primary, secondary]) => ARMOUR_STATS
        .filter(stat => stat !== primary && stat !== secondary)
        .map(tertiary => [primary, secondary, tertiary]))
        .map(([primary, secondary, tertiary]) => ({
        [Stat_3.Stat.Mobility]: 0,
        [Stat_3.Stat.Resilience]: 0,
        [Stat_3.Stat.Recovery]: 0,
        [Stat_3.Stat.Discipline]: 0,
        [Stat_3.Stat.Intellect]: 0,
        [Stat_3.Stat.Strength]: 0,
        [primary]: 30,
        [secondary]: 23,
        [tertiary]: 15,
    }));
    function getUniqueness(item) {
        if (!item.stats || !Stat_3.ARMOUR_STAT_GROUPS.flat().some(stat => item.stats?.values[stat]?.roll))
            return 0;
        const roll = ARMOUR_STATS.toObject(stat => [stat, item.stats?.values[stat]?.roll ?? 0]);
        const totalStats = ARMOUR_STATS.reduce((sum, stat) => sum + roll[stat], 0);
        const difference = 68 - totalStats;
        // 1. Find the Euclidean distance to every possible archetype.
        const allDistances = ARCHETYPES.map((archetypeRoll) => calculateEuclideanDistance(roll, archetypeRoll));
        // 2. The roll's "raw score" is its distance to the CLOSEST archetype.
        const minDistance = Math.min(...allDistances);
        // 3. Normalize against the score of a perfectly flat roll.
        const flatValue = 68 / 6;
        const flatRoll = {
            [Stat_3.Stat.Mobility]: flatValue,
            [Stat_3.Stat.Resilience]: flatValue,
            [Stat_3.Stat.Recovery]: flatValue,
            [Stat_3.Stat.Discipline]: flatValue,
            [Stat_3.Stat.Intellect]: flatValue,
            [Stat_3.Stat.Strength]: flatValue,
        };
        const flatRollDistances = ARCHETYPES.map((archetypeRoll) => calculateEuclideanDistance(flatRoll, archetypeRoll));
        const maxPossibleMinDistance = Math.min(...flatRollDistances);
        if (maxPossibleMinDistance === 0)
            return 0;
        const uniqueness = Maths_5.default.unlerp(0, 0.8, minDistance / maxPossibleMinDistance); // cap out uniqueness
        const uselessValueDifference = 15;
        return (1
            * Math.min(1, Math.max(0, uniqueness))
            * (1 - Math.min(difference, uselessValueDifference) / uselessValueDifference) // Apply a penalty for deviation from 68 total
        );
    }
    // function dotProduct (rollA: StatRoll, rollB: StatRoll): number {
    // 	let product = 0;
    // 	for (const stat of ARMOUR_STATS)
    // 		product += rollA[stat] * rollB[stat];
    // 	return product;
    // }
    // function magnitude (roll: StatRoll): number {
    // 	let sumOfSquares = 0;
    // 	for (const stat of ARMOUR_STATS)
    // 		sumOfSquares += roll[stat] ** 2;
    // 	return Math.sqrt(sumOfSquares);
    // }
    function calculateEuclideanDistance(rollA, rollB) {
        let sumOfSquares = 0;
        for (const stat of ARMOUR_STATS)
            sumOfSquares += (rollA[stat] - rollB[stat]) ** 2;
        return Math.sqrt(sumOfSquares);
    }
    exports.default = Sort_20.ISort.create({
        id: Sort_20.default.StatLegacyDistribution,
        name: "Legacy Distribution",
        shortName: "Legacy",
        sort: (a, b) => getUniqueness(b) - getUniqueness(a),
        render: (item, uniqueness = getUniqueness(item)) => uniqueness <= 0 ? undefined
            : (Component_29.default.create()
                .classes.add("item-stat-distribution")
                .append(Component_29.default.create("span")
                .classes.add("item-stat-distribution-value")
                .style.set("--value", `${uniqueness}`)
                .text.set(`${Math.round(uniqueness * 100)}%`))),
        renderSortable: sortable => sortable.icon.text.set("%"),
    });
});
define("ui/destiny/sort/sorts/SortStatTotal", ["require", "exports", "ui/component/Component", "ui/destiny/sort/Sort", "ui/destiny/utility/Stat"], function (require, exports, Component_30, Sort_21, Stat_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_21.ISort.create({
        id: Sort_21.default.StatTotal,
        name: "Stat Total",
        sort: (a, b) => getStatTotal(b) - getStatTotal(a),
        renderSortable: sortable => sortable.icon,
        render: item => {
            const total = getStatTotal(item);
            if (!total)
                return undefined;
            return Component_30.default.create("span")
                .classes.add("item-sort-stat-total")
                .append(Component_30.default.create("span")
                .classes.add("item-sort-stat-total-icon"))
                .text.set(`${getStatTotal(item)}`);
        },
    });
    function getStatTotal(item) {
        return Stat_4.ARMOUR_STAT_GROUPS.flat().map(stat => item.stats?.values[stat]?.intrinsic ?? 0)
            .reduce((a, b) => a + b, 0);
    }
});
define("model/models/enum/StatTypes", ["require", "exports", "model/models/enum/EnumModel", "model/models/Manifest"], function (require, exports, EnumModel_5, Manifest_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * For display properties of stats that have iconography
     */
    const StatTypes = EnumModel_5.default.create("StatTypes", {
        async generate() {
            const { DestinyStatDefinition } = await Manifest_14.default.await();
            const types = await DestinyStatDefinition.all();
            const health = types.find(type => type.hash === 392767087 /* StatHashes.Health */);
            const melee = types.find(type => type.hash === 4244567218 /* StatHashes.Melee4244567218 */);
            const grenade = types.find(type => type.hash === 1735777505 /* StatHashes.Grenade */);
            const superStat = types.find(type => type.hash === 144602215 /* StatHashes.Super */);
            const classStat = types.find(type => type.hash === 1943323491 /* StatHashes.Class1943323491 */);
            const weapons = types.find(type => type.hash === 2996146975 /* StatHashes.Weapons */);
            const array = [health, melee, grenade, superStat, classStat, weapons];
            for (const def of array) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                def.displayProperties.icon = `https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/${def.displayProperties.name.toLowerCase()}.svg`;
            }
            return {
                array,
                health,
                melee,
                grenade,
                super: superStat,
                class: classStat,
                weapons,
            };
        },
    });
    exports.default = StatTypes;
});
define("ui/destiny/sort/sorts/SortStats", ["require", "exports", "model/models/enum/StatTypes", "ui/component/Component", "ui/destiny/component/EnumIcon", "ui/destiny/sort/Sort", "ui/destiny/utility/Stat"], function (require, exports, StatTypes_1, Component_31, EnumIcon_5, Sort_22, Stat_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = GenerateStatsSorts;
    async function GenerateStatsSorts() {
        const stats = await StatTypes_1.default.all;
        return stats.array.map(stat => Sort_22.ISort.create({
            id: `stat-${stat.displayProperties.name.replace(/\W+/g, "")}`,
            name: stat.displayProperties.name,
            renderSortable: sortable => sortable.maskIcon
                .classes.add("item-sort-drawer-sort-stat-icon")
                .tweak(EnumIcon_5.default.applyIconVar, StatTypes_1.default, stat.hash),
            sort: (a, b) => (b.stats?.values[stat.hash]?.roll ?? 0) - (a.stats?.values[stat.hash]?.roll ?? 0),
            render: (item, value = item.stats?.values[stat.hash]) => !value?.roll ? undefined : Component_31.default.create()
                .classes.add("item-extra-stat-wrapper")
                .tweak(EnumIcon_5.default.applyIconVar, StatTypes_1.default, stat.hash)
                .text.add(`${value.roll}`)
                .style.set("--value", `${value.roll / (Stat_5.ARMOUR_STAT_GROUPS.some(group => group.includes(stat.hash)) ? Stat_5.ARMOUR_STAT_MAX : value.max ?? 100)}`),
        }));
    }
});
define("model/models/enum/WeaponTypes", ["require", "exports", "model/models/enum/EnumModel"], function (require, exports, EnumModel_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const WeaponTypes = EnumModel_6.default.create('WeaponTypes', {
        // eslint-disable-next-line @typescript-eslint/require-await
        async generate() {
            const emptyDisplayProperties = {
                name: '',
                description: '',
                iconHash: 0,
                icon: '',
                iconSequences: [],
                highResIcon: '',
                hasIcon: false,
            };
            const types = [
                {
                    enumValue: 5 /* ItemCategoryHashes.AutoRifle */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Auto Rifle', icon: 'image/svg/weapon/auto_rifle.svg' },
                },
                {
                    enumValue: 11 /* ItemCategoryHashes.Shotgun */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Shotgun', icon: 'image/svg/weapon/shotgun.svg' },
                },
                {
                    enumValue: 12 /* ItemCategoryHashes.MachineGun */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Machine Gun', icon: 'image/svg/weapon/machine_gun.svg' },
                },
                {
                    enumValue: 6 /* ItemCategoryHashes.HandCannon */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Hand Cannon', icon: 'image/svg/weapon/hand_cannon.svg' },
                },
                {
                    enumValue: 13 /* ItemCategoryHashes.RocketLauncher */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Rocket Launcher', icon: 'image/svg/weapon/rocket_launcher.svg' },
                },
                {
                    enumValue: 9 /* ItemCategoryHashes.FusionRifle */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Fusion Rifle', icon: 'image/svg/weapon/fusion_rifle.svg' },
                },
                {
                    enumValue: 10 /* ItemCategoryHashes.SniperRifle */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Sniper Rifle', icon: 'image/svg/weapon/sniper_rifle.svg' },
                },
                {
                    enumValue: 7 /* ItemCategoryHashes.PulseRifle */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Pulse Rifle', icon: 'image/svg/weapon/pulse_rifle.svg' },
                },
                {
                    enumValue: 8 /* ItemCategoryHashes.ScoutRifle */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Scout Rifle', icon: 'image/svg/weapon/scout_rifle.svg' },
                },
                {
                    enumValue: 14 /* ItemCategoryHashes.Sidearm */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Sidearm', icon: 'image/svg/weapon/sidearm.svg' },
                },
                {
                    enumValue: 54 /* ItemCategoryHashes.Sword */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Sword', icon: 'image/svg/weapon/sword.svg' },
                },
                {
                    enumValue: 1504945536 /* ItemCategoryHashes.LinearFusionRifles */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Linear Fusion Rifle', icon: 'image/svg/weapon/linear_fusion_rifle.svg' },
                },
                {
                    enumValue: [153950757 /* ItemCategoryHashes.GrenadeLaunchers */, 4 /* ItemCategoryHashes.PowerWeapon */],
                    displayProperties: { ...emptyDisplayProperties, name: 'Heavy Grenade Launcher', icon: 'image/svg/weapon/grenade_launcher_heavy.svg' },
                },
                {
                    enumValue: 153950757 /* ItemCategoryHashes.GrenadeLaunchers */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Grenade Launcher', icon: 'image/svg/weapon/grenade_launcher.svg' },
                },
                {
                    enumValue: 3954685534 /* ItemCategoryHashes.SubmachineGuns */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Submachine Gun', icon: 'image/svg/weapon/submachine_gun.svg' },
                },
                {
                    enumValue: 2489664120 /* ItemCategoryHashes.TraceRifles */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Trace Rifle', icon: 'image/svg/weapon/trace_rifle.svg' },
                },
                {
                    enumValue: 3317538576 /* ItemCategoryHashes.Bows */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Combat Bow', icon: 'image/svg/weapon/combat_bow.svg' },
                },
                {
                    enumValue: 3871742104 /* ItemCategoryHashes.Glaives */,
                    displayProperties: { ...emptyDisplayProperties, name: 'Glaive', icon: 'image/svg/weapon/glaive.svg' },
                },
            ];
            for (const type of types)
                type.displayProperties.nameLowerCase = type.displayProperties.name.toLowerCase();
            return {
                array: types,
                autoRifle: types.find(type => type.enumValue === 5 /* ItemCategoryHashes.AutoRifle */),
                shotgun: types.find(type => type.enumValue === 11 /* ItemCategoryHashes.Shotgun */),
                machineGun: types.find(type => type.enumValue === 12 /* ItemCategoryHashes.MachineGun */),
                handCannon: types.find(type => type.enumValue === 6 /* ItemCategoryHashes.HandCannon */),
                rocketLauncher: types.find(type => type.enumValue === 13 /* ItemCategoryHashes.RocketLauncher */),
                fusionRifle: types.find(type => type.enumValue === 9 /* ItemCategoryHashes.FusionRifle */),
                sniperRifle: types.find(type => type.enumValue === 10 /* ItemCategoryHashes.SniperRifle */),
                pulseRifle: types.find(type => type.enumValue === 7 /* ItemCategoryHashes.PulseRifle */),
                scoutRifle: types.find(type => type.enumValue === 8 /* ItemCategoryHashes.ScoutRifle */),
                sidearm: types.find(type => type.enumValue === 14 /* ItemCategoryHashes.Sidearm */),
                sword: types.find(type => type.enumValue === 54 /* ItemCategoryHashes.Sword */),
                linearFusionRifle: types.find(type => type.enumValue === 1504945536 /* ItemCategoryHashes.LinearFusionRifles */),
                grenadeLauncher: types.find(type => type.enumValue === 153950757 /* ItemCategoryHashes.GrenadeLaunchers */),
                heavyGrenadeLauncher: types.find(type => Array.isArray(type.enumValue) && type.enumValue.includes(153950757 /* ItemCategoryHashes.GrenadeLaunchers */) && type.enumValue.includes(4 /* ItemCategoryHashes.PowerWeapon */)),
                submachineGun: types.find(type => type.enumValue === 3954685534 /* ItemCategoryHashes.SubmachineGuns */),
                traceRifle: types.find(type => type.enumValue === 2489664120 /* ItemCategoryHashes.TraceRifles */),
                bow: types.find(type => type.enumValue === 3317538576 /* ItemCategoryHashes.Bows */),
                glaive: types.find(type => type.enumValue === 3871742104 /* ItemCategoryHashes.Glaives */),
            };
        },
    });
    exports.default = WeaponTypes;
});
define("ui/destiny/sort/sorts/SortWeaponType", ["require", "exports", "model/models/enum/WeaponTypes", "ui/component/Component", "ui/destiny/component/EnumIcon", "ui/destiny/sort/Sort"], function (require, exports, WeaponTypes_1, Component_32, EnumIcon_6, Sort_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Sort_23.ISort.create({
        id: Sort_23.default.WeaponType,
        name: "Weapon Type",
        shortName: "Type",
        sort: (a, b) => (a.definition.itemTypeDisplayName ?? "").localeCompare(b.definition.itemTypeDisplayName ?? ""),
        renderSortable: sortable => sortable.maskIcon
            .tweak(EnumIcon_6.default.applyIconVar, WeaponTypes_1.default, 6 /* ItemCategoryHashes.HandCannon */),
        render: item => !item.isWeapon() ? undefined
            : Component_32.default.create("span")
                .classes.add("item-weapon-type-icon")
                .tweak(component => EnumIcon_6.default.applyIcon(WeaponTypes_1.default, item.definition.itemCategoryHashes, iconPath => component.style.set("--icon", `url("${iconPath}")`))),
    });
});
define("ui/destiny/sort/SortManager", ["require", "exports", "ui/destiny/sort/Sort", "ui/destiny/sort/sorts/SortAcquired", "ui/destiny/sort/sorts/SortAmmoType", "ui/destiny/sort/sorts/SortBreakerType", "ui/destiny/sort/sorts/SortCanShape", "ui/destiny/sort/sorts/SortDamageType", "ui/destiny/sort/sorts/SortEnergy", "ui/destiny/sort/sorts/SortExotic", "ui/destiny/sort/sorts/SortFeatured", "ui/destiny/sort/sorts/SortHarmonizable", "ui/destiny/sort/sorts/SortLocked", "ui/destiny/sort/sorts/SortMasterwork", "ui/destiny/sort/sorts/SortMoment", "ui/destiny/sort/sorts/SortName", "ui/destiny/sort/sorts/SortPattern", "ui/destiny/sort/sorts/SortPower", "ui/destiny/sort/sorts/SortQuantity", "ui/destiny/sort/sorts/SortRarity", "ui/destiny/sort/sorts/SortShaped", "ui/destiny/sort/sorts/SortStatDistribution", "ui/destiny/sort/sorts/SortStatDistributionUniqueness", "ui/destiny/sort/sorts/SortStatTotal", "ui/destiny/sort/sorts/SortStats", "ui/destiny/sort/sorts/SortWeaponType", "utility/EventManager", "utility/Store", "utility/decorator/Bound"], function (require, exports, Sort_24, SortAcquired_1, SortAmmoType_1, SortBreakerType_1, SortCanShape_1, SortDamageType_1, SortEnergy_1, SortExotic_1, SortFeatured_1, SortHarmonizable_1, SortLocked_1, SortMasterwork_1, SortMoment_1, SortName_1, SortPattern_1, SortPower_1, SortQuantity_1, SortRarity_1, SortShaped_1, SortStatDistribution_1, SortStatDistributionUniqueness_1, SortStatTotal_1, SortStats_1, SortWeaponType_1, EventManager_18, Store_10, Bound_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const BASE_SORT_MAP = {
        [Sort_24.default.Name]: SortName_1.default,
        [Sort_24.default.Power]: SortPower_1.default,
        [Sort_24.default.Energy]: SortEnergy_1.default,
        [Sort_24.default.Pattern]: SortPattern_1.default,
        [Sort_24.default.Masterwork]: SortMasterwork_1.default,
        [Sort_24.default.Rarity]: SortRarity_1.default,
        [Sort_24.default.StatTotal]: SortStatTotal_1.default,
        [Sort_24.default.StatDistribution]: SortStatDistribution_1.default,
        [Sort_24.default.Moment]: SortMoment_1.default,
        [Sort_24.default.Shaped]: SortShaped_1.default,
        [Sort_24.default.AmmoType]: SortAmmoType_1.default,
        [Sort_24.default.DamageType]: SortDamageType_1.default,
        [Sort_24.default.WeaponType]: SortWeaponType_1.default,
        [Sort_24.default.Quantity]: SortQuantity_1.default,
        [Sort_24.default.Locked]: SortLocked_1.default,
        [Sort_24.default.Harmonizable]: SortHarmonizable_1.default,
        [Sort_24.default.Exotic]: SortExotic_1.default,
        [Sort_24.default.CanShape]: SortCanShape_1.default,
        [Sort_24.default.BreakerType]: SortBreakerType_1.default,
        [Sort_24.default.Acquired]: SortAcquired_1.default,
        [Sort_24.default.StatLegacyDistribution]: SortStatDistributionUniqueness_1.default,
        [Sort_24.default.Featured]: SortFeatured_1.default,
    };
    const DYNAMIC_SORTS = [
        SortStats_1.default,
    ];
    for (const [type, sort] of Object.entries(BASE_SORT_MAP))
        if (+type !== sort.id)
            throw new Error(`Sort ${Sort_24.default[+type]} implementation miscategorised`);
    class SortManager {
        static registerSort(id, sort) {
            if (this.sortMap[id])
                throw new Error(`Attempted to dynamically re-register sort ${id}`);
            this.sortMap[id] = sort;
        }
        static onInit(fn) {
            if (SortManager.initialised)
                fn();
            else
                SortManager.onInitFunctions.push(fn);
        }
        static async init() {
            if (SortManager.initialised)
                return;
            return SortManager.initialised = (async () => {
                for (const gen of DYNAMIC_SORTS) {
                    for (const sort of await gen()) {
                        if (typeof sort.id === "number")
                            throw new Error(`Cannot dynamically register sorts with numeric IDs, registered ${sort.id}`);
                        this.registerSort(sort.id, sort);
                    }
                }
                for (const onInit of SortManager.onInitFunctions)
                    onInit();
                return SortManager.initialised = true;
            })();
        }
        constructor(configuration) {
            this.inapplicableIds = [];
            this.inapplicableRegExp = [];
            this.event = new EventManager_18.EventManager(this);
            this.setConfiguration(configuration);
        }
        setConfiguration(configuration) {
            Object.assign(this, configuration);
            this.inapplicableIds = configuration.inapplicable.filter((sort) => typeof sort === "number");
            this.inapplicableRegExp = configuration.inapplicable.filter((sort) => typeof sort === "string")
                .map(regexString => new RegExp(`^${regexString}$`));
            this.default = this.default.filter(sort => !this.isInapplicable(SortManager.sortMap[typeof sort === "object" ? sort.reverse : sort]));
            SortManager.onInit(() => {
                let sort = (Store_10.default.get(`sort-${this.id}`) ?? [])
                    .map((sortName) => Sort_24.default[sortName] ?? sortName)
                    .filter(sort => SortManager.sortMap[sort]);
                const reversed = Store_10.default.get(`sort-${this.id}-reversed`) ?? {};
                if (!sort.length) {
                    sort = this.default.map(sort => typeof sort === "object" ? sort.reverse : sort);
                    for (const sortType of this.default) {
                        const sort = SortManager.sortMap[typeof sortType === "object" ? sortType.reverse : sortType];
                        const id = this.stringifyId(sort);
                        if (typeof sortType === "object") {
                            reversed[id] = true;
                        }
                        else {
                            delete reversed[id];
                        }
                    }
                }
                this.current = sort.map(sortType => SortManager.sortMap[sortType]);
                this.reversed = reversed;
            });
        }
        get() {
            return this.current;
        }
        getStateHash() {
            return this.current
                .map(sort => `${sort.id}:${this.isReversed(sort)}`)
                .join(",");
        }
        isReversed(sort) {
            return this.reversed[typeof sort === "object" ? this.stringifyId(sort) : sort] ?? false;
        }
        getDisabled() {
            return Object.values(SortManager.sortMap)
                .filter(sort => !this.current.includes(sort) && !this.isInapplicable(sort))
                .sort((a, b) => 0
                || (typeof a.id === "number" ? a.id : 99999999999) - (typeof b.id === "number" ? b.id : 99999999999)
                || `${a.id}`.localeCompare(`${b.id}`));
        }
        isInapplicable(sort) {
            return this.inapplicableIds.includes(sort.id)
                || this.inapplicableRegExp.some(regex => regex.test(`${sort.id}`));
        }
        set(sort, emit = true) {
            this.current.splice(0, Infinity, ...sort);
            Store_10.default.set(`sort-${this.id}`, this.current.map(this.stringifyId));
            if (emit)
                this.event.emit("update");
        }
        setReversed(sort, emit = true) {
            Store_10.default.set(`sort-${this.id}-reversed`, this.reversed = {
                ...Store_10.default.get(`sort-${this.id}-reversed`),
                ...this.current.toObject(current => [this.stringifyId(current), sort.includes(current)]),
            });
            if (emit)
                this.event.emit("update");
        }
        stringifyId(sort) {
            return typeof sort.id === "number" ? Sort_24.default[sort.id] : sort.id;
        }
        sort(itemA, itemB, requireDifference = true) {
            for (const sort of this.current) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                let result = sort.sort(itemA, itemB);
                if (this.reversed[this.stringifyId(sort)])
                    result = -result;
                if (result !== 0)
                    return result;
            }
            if ("id" in itemA && "id" in itemB) {
                const hasInstanceDifference = Number(!!itemB.reference.itemInstanceId) - Number(!!itemA.reference.itemInstanceId);
                if (hasInstanceDifference)
                    // sort things with an instance id before things without an instance id
                    return hasInstanceDifference;
            }
            if (!requireDifference)
                return 0;
            const partialItemA = itemA;
            const partialItemB = itemB;
            const compareA = partialItemA.reference?.itemInstanceId ?? `${partialItemA.reference?.itemHash ?? partialItemA.baseItem?.hash ?? 0}`;
            const compareB = partialItemB.reference?.itemInstanceId ?? `${partialItemB.reference?.itemHash ?? partialItemB.baseItem?.hash ?? 0}`;
            return compareA.localeCompare(compareB);
        }
    }
    SortManager.sortMap = BASE_SORT_MAP;
    SortManager.initialised = false;
    SortManager.onInitFunctions = [];
    __decorate([
        Bound_14.default
    ], SortManager.prototype, "isInapplicable", null);
    __decorate([
        Bound_14.default
    ], SortManager.prototype, "stringifyId", null);
    __decorate([
        Bound_14.default
    ], SortManager.prototype, "sort", null);
    exports.default = SortManager;
});
define("ui/destiny/sort/ItemSort", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/component/Drawer", "ui/component/utility/Sortable", "ui/destiny/component/ItemComponent", "ui/destiny/sort/Sort", "ui/utility/UiEventBus", "utility/decorator/Bound"], function (require, exports, Button_9, Component_33, Drawer_1, Sortable_1, ItemComponent_1, Sort_25, UiEventBus_2, Bound_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SortableSort = exports.ItemSortClasses = void 0;
    var ItemSortClasses;
    (function (ItemSortClasses) {
        ItemSortClasses["Main"] = "item-sort";
        ItemSortClasses["Button"] = "item-sort-button";
        ItemSortClasses["ButtonIcon"] = "item-sort-button-icon";
        ItemSortClasses["ButtonLabel"] = "item-sort-button-label";
        ItemSortClasses["ButtonSortText"] = "item-sort-button-sort-text";
        ItemSortClasses["Drawer"] = "item-sort-drawer";
        ItemSortClasses["DrawerPanel"] = "item-sort-drawer-panel";
        ItemSortClasses["Sorts"] = "item-sort-drawer-sorts";
        ItemSortClasses["Sort"] = "item-sort-drawer-sort";
        ItemSortClasses["SortTitle"] = "item-sort-drawer-sort-title";
        ItemSortClasses["SortIcon"] = "item-sort-drawer-sort-icon";
        ItemSortClasses["SortIconMask"] = "item-sort-drawer-sort-icon-mask";
        ItemSortClasses["SortOptions"] = "item-sort-drawer-sort-options";
        ItemSortClasses["SortsHeading"] = "item-sort-drawer-sorts-heading";
        ItemSortClasses["SortReverse"] = "item-sort-drawer-sort-reverse";
        ItemSortClasses["Sort_Reversed"] = "item-sort-drawer-sort--reversed";
        ItemSortClasses["SortButton"] = "item-sort-drawer-sort-button";
    })(ItemSortClasses || (exports.ItemSortClasses = ItemSortClasses = {}));
    class SortableSort extends Component_33.default {
        get reversed() {
            return this.classes.has(ItemSortClasses.Sort_Reversed);
        }
        get icon() {
            return Component_33.default.create("span")
                .classes.add(ItemSortClasses.SortIcon, `item-sort-drawer-sort-${this.sort.className ?? (typeof this.sort.id === "number" ? Sort_25.default[this.sort.id] : this.sort.id).toLowerCase()}-icon`)
                .prependTo(this.title);
        }
        get maskIcon() {
            return Component_33.default.create("span")
                .classes.add(ItemSortClasses.SortIconMask, `item-sort-drawer-sort-${this.sort.className ?? (typeof this.sort.id === "number" ? Sort_25.default[this.sort.id] : this.sort.id).toLowerCase()}-icon`)
                .prependTo(this.title);
        }
        onMake(sort) {
            this.sort = sort;
            this.classes.add(ItemSortClasses.Sort, `item-sort-drawer-sort-${sort.className ?? (typeof sort.id === "number" ? Sort_25.default[sort.id] : sort.id).toLowerCase()}`);
            this.title = Component_33.default.create("span")
                .classes.add(ItemSortClasses.SortTitle)
                .text.set(sort.name)
                .appendTo(this);
            sort.renderSortable?.(this);
            if (sort.renderSortableOptions)
                Button_9.default.create()
                    .classes.add(Button_9.ButtonClasses.Icon, ItemSortClasses.SortButton, ItemSortClasses.SortOptions)
                    .event.subscribe("click", this.onOptions)
                    .appendTo(this);
            Button_9.default.create()
                .classes.add(Button_9.ButtonClasses.Icon, ItemSortClasses.SortButton, ItemSortClasses.SortReverse)
                .event.subscribe("click", this.onReverse)
                .appendTo(this);
        }
        setReversed(reversed = true) {
            this.classes.toggle(reversed, ItemSortClasses.Sort_Reversed);
            return this;
        }
        onOptions() {
            this.event.emit("configure", { sort: this.sort });
        }
        onReverse() {
            this.setReversed(!this.reversed);
            this.event.emit("reverse", { sort: this.sort });
        }
    }
    exports.SortableSort = SortableSort;
    __decorate([
        Bound_15.default
    ], SortableSort.prototype, "onOptions", null);
    __decorate([
        Bound_15.default
    ], SortableSort.prototype, "onReverse", null);
    class ItemSort extends Component_33.default {
        onMake(sorter) {
            this.sorter = sorter;
            this.classes.add(ItemSortClasses.Main);
            ////////////////////////////////////
            // Button
            this.button = Button_9.default.create()
                .classes.add(ItemSortClasses.Button)
                .event.subscribe("click", this.toggleDrawer)
                .addIcon(icon => icon.classes.add(ItemSortClasses.ButtonIcon))
                .appendTo(this);
            this.label = Component_33.default.create()
                .classes.add(ItemSortClasses.ButtonLabel)
                .text.set(`Sort ${sorter.name}`)
                .appendTo(this.button);
            this.sortText = Component_33.default.create()
                .classes.add(ItemSortClasses.ButtonSortText)
                .appendTo(this.button);
            ////////////////////////////////////
            // Drawer
            this.drawer = Drawer_1.default.create()
                .classes.add(ItemSortClasses.Drawer)
                .event.subscribe("focus", this.focusDrawer)
                .appendTo(this);
            this.mainPanel = this.drawer.createPanel();
            Component_33.default.create()
                .classes.add(ItemSortClasses.SortsHeading)
                .text.set("Sort By")
                .appendTo(this.mainPanel);
            this.sortsList = Component_33.default.create()
                .classes.add(ItemSortClasses.Sorts)
                .appendTo(this.mainPanel);
            this.configurePanel = this.drawer.createPanel();
            this.configureTitle = Component_33.default.create()
                .classes.add(ItemSortClasses.SortsHeading)
                .text.set("Configure Sort")
                .appendTo(this.configurePanel);
            this.configureWrapper = Component_33.default.create()
                .appendTo(this.configurePanel);
            this.sorts = [];
            for (const sort of sorter.get())
                this.createSortableSort(sort, sorter.isReversed(sort));
            this.sortsDisabledHeading = Component_33.default.create()
                .classes.add(ItemSortClasses.SortsHeading)
                .text.set("Don't Sort By")
                .appendTo(this.sortsList);
            for (const sort of sorter.getDisabled())
                this.createSortableSort(sort, sorter.isReversed(sort));
            new Sortable_1.default(this.sortsList.element)
                .setInputFilter(event => !event.target.closest("button"))
                .event.subscribe("commit", this.onCommitSort);
            this.sortsDisabledHeading.attributes.remove("tabindex");
            ////////////////////////////////////
            // Setup
            this.updateSortDisplay();
            document.body.addEventListener("click", this.onClick);
            UiEventBus_2.default.subscribe("keydown", this.onKeydown);
            UiEventBus_2.default.subscribe("keyup", this.onKeyup);
        }
        createSortableSort(sort, reversed) {
            this.sorts.push(SortableSort.create([sort])
                .setReversed(reversed)
                .event.subscribe("configure", this.configureSort)
                .event.subscribe("reverse", this.reverseSort)
                .appendTo(this.sortsList));
        }
        configureSort({ sort }) {
            this.configureTitle.text.set(`Configure ${sort.name}`);
            this.configureWrapper.removeContents().tweak(sort.renderSortableOptions, this.onCommitSort);
            this.drawer.showPanel(this.configurePanel, true);
        }
        reverseSort({ sort }) {
            this.onCommitSort();
        }
        onClick(event) {
            if (!this.exists())
                return document.body.removeEventListener("click", this.onClick);
            if (event.target.closest(`.${ItemSortClasses.Main}`))
                return;
            this.closeDrawer();
        }
        onCommitSort() {
            const enabledSorts = [...this.sortsList.children()]
                .slice(0, this.sortsDisabledHeading.index());
            this.sorter.set(enabledSorts.map(child => child.sort), false);
            this.sorter.setReversed(enabledSorts.filter(sort => sort.reversed).map(child => child.sort));
            this.updateSortDisplay();
            this.event.emit("sort");
        }
        updateSortDisplay() {
            this.sortText.text.set(this.sorter.get()
                .map(sort => sort.shortName ?? sort.name)
                .join(", "));
        }
        onKeydown(event) {
            if (!document.contains(this.element)) {
                UiEventBus_2.default.unsubscribe("keydown", this.onKeydown);
                return;
            }
            if (event.useOverInput("s", "ctrl"))
                this.openDrawer();
            if (this.drawer.isOpen() && event.useOverInput("Escape"))
                this.closeDrawer();
        }
        onKeyup() {
            if (!document.contains(this.element)) {
                UiEventBus_2.default.unsubscribe("keyup", this.onKeyup);
                return;
            }
            if (!this.element.contains(document.activeElement))
                this.closeDrawer();
        }
        toggleDrawer() {
            if (!this.drawer.isOpen())
                this.openDrawer();
            else
                this.closeDrawer();
        }
        openDrawer() {
            if (this.drawer.isOpen())
                return;
            this.drawer.open();
            this.drawer.showPanel(this.mainPanel);
            ItemComponent_1.default.showExtra(ItemSortClasses.Main);
            this.focusDrawer();
        }
        closeDrawer() {
            this.drawer.close(true);
            ItemComponent_1.default.hideExtra(ItemSortClasses.Main);
        }
        focusDrawer() {
            const [firstSort] = this.sortsList.children();
            firstSort.element.focus();
        }
    }
    exports.default = ItemSort;
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "configureSort", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "reverseSort", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "onClick", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "onCommitSort", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "onKeydown", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "onKeyup", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "toggleDrawer", null);
    __decorate([
        Bound_15.default
    ], ItemSort.prototype, "focusDrawer", null);
});
define("ui/destiny/sort/Sort", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ISort = void 0;
    var Sort;
    (function (Sort) {
        Sort[Sort["Power"] = 0] = "Power";
        Sort[Sort["Name"] = 1] = "Name";
        Sort[Sort["Energy"] = 2] = "Energy";
        Sort[Sort["Pattern"] = 3] = "Pattern";
        Sort[Sort["Shaped"] = 4] = "Shaped";
        Sort[Sort["Masterwork"] = 5] = "Masterwork";
        Sort[Sort["Rarity"] = 6] = "Rarity";
        Sort[Sort["StatTotal"] = 7] = "StatTotal";
        Sort[Sort["StatDistribution"] = 8] = "StatDistribution";
        Sort[Sort["Moment"] = 9] = "Moment";
        Sort[Sort["AmmoType"] = 10] = "AmmoType";
        Sort[Sort["DamageType"] = 11] = "DamageType";
        Sort[Sort["WeaponType"] = 12] = "WeaponType";
        Sort[Sort["Quantity"] = 13] = "Quantity";
        Sort[Sort["Locked"] = 14] = "Locked";
        Sort[Sort["Harmonizable"] = 15] = "Harmonizable";
        Sort[Sort["Exotic"] = 16] = "Exotic";
        Sort[Sort["CanShape"] = 17] = "CanShape";
        Sort[Sort["BreakerType"] = 18] = "BreakerType";
        Sort[Sort["Acquired"] = 19] = "Acquired";
        Sort[Sort["StatLegacyDistribution"] = 20] = "StatLegacyDistribution";
        Sort[Sort["Featured"] = 21] = "Featured";
    })(Sort || (Sort = {}));
    exports.default = Sort;
    var ISort;
    (function (ISort) {
        function create(sort) {
            return sort;
        }
        ISort.create = create;
    })(ISort || (exports.ISort = ISort = {}));
});
define("ui/destiny/playeroverview/LoadoutTooltip", ["require", "exports", "ui/component/Component", "ui/utility/TooltipManager"], function (require, exports, Component_34, TooltipManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoadoutTooltipClasses = void 0;
    var LoadoutTooltipClasses;
    (function (LoadoutTooltipClasses) {
        LoadoutTooltipClasses["Main"] = "loadout-tooltip";
    })(LoadoutTooltipClasses || (exports.LoadoutTooltipClasses = LoadoutTooltipClasses = {}));
    class LoadoutTooltip extends TooltipManager_1.Tooltip {
        onMake() {
            this.classes.add(LoadoutTooltipClasses.Main);
            this.subtitle.text.set("Loadout");
            this.content.append(Component_34.default.create().text.set("This feature is a work-in-progress. Stay tuned!"));
        }
        set(loadout) {
            Object.assign(window, { loadout });
            console.log(loadout?.isEmpty() ? "Empty" : loadout?.name?.name ?? "Unknown", loadout);
            this.loadout = loadout;
            this.title.text.set(!loadout ? "Unknown Loadout" : loadout.name?.name ?? "Save New Loadout");
        }
    }
    exports.default = TooltipManager_1.default.create(tooltip => tooltip
        .make(LoadoutTooltip));
});
define("ui/destiny/playeroverview/LoadoutComponent", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/component/LoadedIcon", "ui/destiny/component/IItemComponent", "ui/destiny/playeroverview/LoadoutTooltip"], function (require, exports, Button_10, Component_35, LoadedIcon_1, IItemComponent_1, LoadoutTooltip_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoadoutClasses = void 0;
    var LoadoutClasses;
    (function (LoadoutClasses) {
        LoadoutClasses["Main"] = "loadout";
        LoadoutClasses["Image"] = "loadout-image";
        LoadoutClasses["ImageWrapper"] = "loadout-image-wrapper";
        LoadoutClasses["ImageIcon"] = "loadout-image-icon";
        LoadoutClasses["ImageBackground"] = "loadout-image-background";
        LoadoutClasses["Number"] = "loadout-number";
        LoadoutClasses["_Empty"] = "loadout--empty";
        LoadoutClasses["_Unknown"] = "loadout--unknown";
    })(LoadoutClasses || (exports.LoadoutClasses = LoadoutClasses = {}));
    class LoadoutComponent extends Component_35.default {
        // eslint-disable-next-line @typescript-eslint/require-await
        async onMake() {
            this.classes.add(Button_10.ButtonClasses.Main, IItemComponent_1.ItemClasses.Main, LoadoutClasses.Main);
            this.clearTooltip();
            this.imageWrapper = Component_35.default.create()
                .classes.add(LoadoutClasses.ImageWrapper)
                .appendTo(this);
            this.background = LoadedIcon_1.default.create([])
                .classes.add(IItemComponent_1.ItemClasses.Icon, LoadoutClasses.Image, LoadoutClasses.ImageBackground)
                .appendTo(this.imageWrapper);
            this.icon = LoadedIcon_1.default.create([])
                .classes.add(IItemComponent_1.ItemClasses.Icon, LoadoutClasses.Image, LoadoutClasses.ImageIcon)
                .appendTo(this.imageWrapper);
            this.number = Component_35.default.create()
                .classes.add(LoadoutClasses.Number)
                .appendTo(this);
            this.setTooltip(LoadoutTooltip_1.default, {
                initialise: tooltip => tooltip.set(this.loadout),
                differs: tooltip => tooltip.loadout !== this.loadout,
            });
        }
        set(index, loadout) {
            this.loadout = loadout;
            this.number.text.set(`${index + 1}`);
            this.style.set("--index", `${index}`);
            this.background.setPath(this.loadout?.colour && `https://www.bungie.net${this.loadout.colour.colorImagePath}`);
            this.icon.setPath(this.loadout?.icon && `https://www.bungie.net${this.loadout.icon.iconImagePath}`);
            this.classes.toggle(loadout?.isEmpty() ?? false, LoadoutClasses._Empty);
            this.classes.toggle(!loadout, LoadoutClasses._Unknown);
            return this;
        }
    }
    exports.default = LoadoutComponent;
});
define("ui/destiny/tooltip/item/ItemAmmo", ["require", "exports", "ui/component/Component", "ui/utility/Classes"], function (require, exports, Component_36, Classes_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemAmmoClasses = void 0;
    var ItemAmmoClasses;
    (function (ItemAmmoClasses) {
        ItemAmmoClasses["Main"] = "item-ammo-type";
        ItemAmmoClasses["Primary"] = "item-ammo-type-primary";
        ItemAmmoClasses["Special"] = "item-ammo-type-special";
        ItemAmmoClasses["Heavy"] = "item-ammo-type-heavy";
    })(ItemAmmoClasses || (exports.ItemAmmoClasses = ItemAmmoClasses = {}));
    class ItemAmmo extends Component_36.default {
        onMake() {
            this.classes.add(ItemAmmoClasses.Main);
        }
        setItem(item) {
            const ammoType = item.definition.equippingBlock?.ammoType;
            this.classes.toggle(!ammoType, Classes_5.Classes.Hidden);
            if (ammoType)
                this.classes.remove(ItemAmmoClasses.Primary, ItemAmmoClasses.Special, ItemAmmoClasses.Heavy)
                    .classes.add(ammoType === 1 /* DestinyAmmunitionType.Primary */ ? ItemAmmoClasses.Primary
                    : ammoType === 2 /* DestinyAmmunitionType.Special */ ? ItemAmmoClasses.Special
                        : ammoType === 3 /* DestinyAmmunitionType.Heavy */ ? ItemAmmoClasses.Heavy
                            : ItemAmmoClasses.Main)
                    .text.set(ammoType === 1 /* DestinyAmmunitionType.Primary */ ? "Primary"
                    : ammoType === 2 /* DestinyAmmunitionType.Special */ ? "Special"
                        : ammoType === 3 /* DestinyAmmunitionType.Heavy */ ? "Heavy"
                            : "");
            return this;
        }
    }
    exports.default = ItemAmmo;
});
define("ui/destiny/tooltip/item/RecoilDirection", ["require", "exports", "ui/component/Component"], function (require, exports, Component_37) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoilValue = recoilValue;
    exports.default = default_1;
    /**
     * **NOTE:** The maths in this file is pulled from the DIM source code (https://github.com/DestinyItemManager/DIM/blob/59c3b0c81c5f86d73e3ffb986143f73f5f3c6ee4/src/app/item-popup/RecoilStat.tsx),
     * and therefore falls under the MIT license in that project (https://github.com/DestinyItemManager/DIM/blob/43709b9128832fd26ec5832cb4d43d628a0c4aaf/LICENSE.md):
     *
     * MIT License
     *
     * Copyright (c) 2018 Destiny Item Manager
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    /**
     * A value from 100 to -100 where positive is right and negative is left and zero is straight up
     * See https://imgur.com/LKwWUNV
     */
    function recoilDirection(value) {
        return Math.sin((value + 5) * (Math.PI / 10)) * (100 - value);
    }
    /**
     * A value from 0 to 100 describing how straight up and down the recoil is, for sorting
     */
    function recoilValue(value) {
        const deviation = Math.abs(recoilDirection(value));
        return 100 - deviation + value / 100000;
    }
    // How much to bias the direction towards the center - at 1.0 this would mean recoil would swing 90
    const verticalScale = 0.8;
    // The maximum angle of the pie, where zero recoil is the widest and 100 recoil is the narrowest
    const maxSpread = 180; // degrees
    function default_1(value) {
        const direction = recoilDirection(value) * verticalScale * (Math.PI / 180); // Convert to radians
        const x = Math.sin(direction);
        const y = Math.cos(direction);
        const spread = 
        // Higher value means less spread
        ((100 - value) / 100) *
            // scaled by the spread factor (halved since we expand to either side)
            (maxSpread / 2) *
            // in radians
            (Math.PI / 180) *
            // flipped for negative
            Math.sign(direction);
        const xSpreadMore = Math.sin(direction + spread);
        const ySpreadMore = Math.cos(direction + spread);
        const xSpreadLess = Math.sin(direction - spread);
        const ySpreadLess = Math.cos(direction - spread);
        /**
         * DIM-licensed code ends here. But credit where credit is due, the following SVG generation is still based on
         * the SVG generation in the same RecoilStat.tsx file.
         */
        const svg = Component_37.default.create("svg")
            .attributes.set("viewBox", "0 0 2 1")
            .append(Component_37.default.create("circle")
            .attributes.set("r", "1")
            .attributes.set("cx", "1")
            .attributes.set("cy", "1"));
        if (value >= 95)
            Component_37.default.create("line")
                .attributes.set("x1", `${1 - x}`)
                .attributes.set("y1", `${1 + y}`)
                .attributes.set("x2", `${1 + x}`)
                .attributes.set("y2", `${1 - y}`)
                .appendTo(svg);
        else
            Component_37.default.create("path")
                .attributes.set("d", `
				M 1,1${ /* move to bottom middle */""}
				L ${1 + xSpreadMore},${1 - ySpreadMore}${ /* draw a line to the "more" side of the spread */""}
				A${ /* begin drawing an arc */""}
					1,1${ /* with the origin in the bottom middle */""}
					0${ /* angled at 0deg (relative to x axis) */""}
					0,${direction < 0 ? "1" : "0"}${ /* 1 = clockwise, 0 = anticlockwise */""}
					${1 + xSpreadLess},${1 - ySpreadLess}${ /* end the arc at the "less" side of the spread */""}
				Z${ /* close line to starting point (bottom middle) */""}
			`)
                .appendTo(svg);
        return svg;
    }
});
define("ui/destiny/tooltip/item/ItemStat", ["require", "exports", "ui/component/Component", "ui/destiny/tooltip/item/RecoilDirection", "ui/destiny/utility/Stat", "ui/utility/Classes", "utility/maths/Maths"], function (require, exports, Component_38, RecoilDirection_1, Stat_6, Classes_6, Maths_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemStatClasses = exports.CustomStat = void 0;
    var CustomStat;
    (function (CustomStat) {
        CustomStat[CustomStat["Total"] = -1] = "Total";
        CustomStat[CustomStat["Distribution"] = -2] = "Distribution";
        CustomStat[CustomStat["Tiers"] = -3] = "Tiers";
    })(CustomStat || (exports.CustomStat = CustomStat = {}));
    var ItemStatClasses;
    (function (ItemStatClasses) {
        ItemStatClasses["Wrapper"] = "item-stat-wrapper";
        ItemStatClasses["Main"] = "item-stat";
        ItemStatClasses["Label"] = "item-stat-label";
        ItemStatClasses["LabelMasterwork"] = "item-stat-label-masterwork";
        ItemStatClasses["GroupLabel"] = "item-stat-group-label";
        ItemStatClasses["Bar"] = "item-stat-bar";
        ItemStatClasses["BarChunked"] = "item-stat-bar-chunked";
        ItemStatClasses["BarBlock"] = "item-stat-bar-block";
        ItemStatClasses["BarBlockNegative"] = "item-stat-bar-block-negative";
        ItemStatClasses["Value"] = "item-stat-value";
        ItemStatClasses["ValueComponent"] = "item-stat-value-component";
        ItemStatClasses["ValueComponentNegative"] = "item-stat-value-component-negative";
        ItemStatClasses["Combined"] = "item-stat-combined";
        ItemStatClasses["Intrinsic"] = "item-stat-intrinsic";
        ItemStatClasses["Random"] = "item-stat-random";
        ItemStatClasses["Masterwork"] = "item-stat-masterwork";
        ItemStatClasses["Mod"] = "item-stat-mod";
        ItemStatClasses["Subclass"] = "item-stat-subclass";
        ItemStatClasses["Charge"] = "item-stat-charge";
        ItemStatClasses["Formula"] = "item-stat-formula";
        ItemStatClasses["Distribution"] = "item-stat-distribution-component";
        ItemStatClasses["DistributionGroupLabel"] = "item-stat-distribution-component-group-label";
    })(ItemStatClasses || (exports.ItemStatClasses = ItemStatClasses = {}));
    const customStats = {
        [CustomStat.Total]: {
            hash: CustomStat.Total,
            order: 1000,
            name: "Total",
            calculate: (stat, stats, item) => {
                const armourStats = Stat_6.ARMOUR_STAT_GROUPS.flat();
                stats = stats.filter(stat => armourStats.includes(stat.hash));
                const totalIntrinsic = stats.map(stat => stat?.intrinsic ?? 0)
                    .reduce((a, b) => a + b, 0);
                const totalRandom = stats.map(stat => stat?.roll ?? 0)
                    .reduce((a, b) => a + b, 0);
                const totalMasterwork = stats.map(stat => stat?.masterwork ?? 0)
                    .reduce((a, b) => a + b, 0);
                const totalMod = stats.map(stat => stat?.mod ?? 0)
                    .reduce((a, b) => a + b, 0);
                const totalSubclass = stats.map(stat => stat?.subclass ?? 0)
                    .reduce((a, b) => a + b, 0);
                const totalCharge = stats.map(stat => stat?.charge ?? 0)
                    .reduce((a, b) => a + b, 0);
                if (totalIntrinsic + totalMasterwork + totalMod + totalCharge === 0)
                    return undefined; // this item doesn't have armour stats
                return {
                    value: totalIntrinsic + totalRandom + totalMasterwork + totalMod + totalSubclass + totalCharge,
                    intrinsic: totalIntrinsic,
                    roll: totalRandom,
                    masterwork: totalMasterwork,
                    mod: totalMod,
                    subclass: totalSubclass,
                    charge: totalCharge,
                };
            },
        },
        [CustomStat.Distribution]: {
            hash: CustomStat.Distribution,
            order: 1001,
            name: "Distribution",
            calculate: (stat, stats, item) => {
                const distribution = item && Stat_6.IStatDistribution.get(item);
                if (!distribution?.overall)
                    return undefined; // this item doesn't have armour stats
                return {
                    value: distribution.overall,
                    combinedValue: distribution.overall,
                    combinedText: `${Math.floor(distribution.overall * 100)}%`,
                    renderFormula: () => distribution.groups.map((groupValue, i) => Component_38.default.create()
                        .classes.add(ItemStatClasses.Distribution)
                        .text.set(`${Math.floor(groupValue * 100)}%`)
                        // .append(Component.create("sup")
                        // 	.classes.add(ItemStatClasses.DistributionGroupLabel)
                        // 	.text.set(`${i + 1}`))
                        .style.set("--value", `${groupValue}`)),
                };
            },
        },
    };
    const renderArmourStat = (_, allStats, item) => Stat_6.ARMOUR_STAT_GROUPS.flat()
        .map(stat => allStats.find(display => display.hash === stat))
        .some(display => {
        const cdisplay = display?.calculate?.(display, allStats, item) ?? display;
        return cdisplay?.combinedValue ?? (cdisplay?.intrinsic ?? 0) + (cdisplay?.masterwork ?? 0) + (cdisplay?.mod ?? 0) + (cdisplay?.subclass ?? 0) + (cdisplay?.charge ?? 0);
    });
    const customStatDisplays = {
        // undrendered
        [Stat_6.Stat.Attack]: false,
        [Stat_6.Stat.Defense]: false,
        [Stat_6.Stat.Power]: false,
        [Stat_6.Stat.InventorySize]: false,
        [Stat_6.Stat.Mystery1]: false,
        [Stat_6.Stat.Mystery2]: false,
        [Stat_6.Stat.GhostEnergyCapacity]: false,
        [Stat_6.Stat.ModCost]: false,
        // weapons
        [Stat_6.Stat.AirborneEffectiveness]: {
            name: "Airborne Aim",
            render: (s, ss, item) => item?.definition.itemSubType !== 18 /* DestinyItemSubType.Sword */,
        },
        [Stat_6.Stat.RPM]: { name: "RPM", max: undefined },
        [Stat_6.Stat.DrawTime]: { max: undefined },
        [Stat_6.Stat.ChargeTime]: {
            bar: true,
            render: (s, ss, item) => item?.definition.itemSubType !== 31 /* DestinyItemSubType.Bow */
                && item?.definition.itemSubType !== 18 /* DestinyItemSubType.Sword */,
        },
        [Stat_6.Stat.RecoilDirection]: {
            bar: true,
            renderBar: (bar, stat) => bar.removeContents()
                .append((0, RecoilDirection_1.default)(stat.value ?? 0)),
        },
        [Stat_6.Stat.Magazine]: { render: (s, ss, item) => item?.definition.itemSubType !== 18 /* DestinyItemSubType.Sword */ },
        [Stat_6.Stat.Zoom]: { render: (s, ss, item) => item?.definition.itemSubType !== 18 /* DestinyItemSubType.Sword */ },
        [Stat_6.Stat.Stability]: { render: (s, ss, item) => item?.definition.itemSubType !== 18 /* DestinyItemSubType.Sword */ },
        [Stat_6.Stat.Range]: { render: (s, ss, item) => item?.definition.itemSubType !== 18 /* DestinyItemSubType.Sword */ },
        // armour
        [Stat_6.Stat.Mobility]: { uncapped: true, plus: true, max: Stat_6.ARMOUR_STAT_MAX_VISUAL, render: renderArmourStat },
        [Stat_6.Stat.Resilience]: { uncapped: true, plus: true, max: Stat_6.ARMOUR_STAT_MAX_VISUAL, render: renderArmourStat },
        [Stat_6.Stat.Recovery]: { uncapped: true, plus: true, max: Stat_6.ARMOUR_STAT_MAX_VISUAL, render: renderArmourStat },
        [Stat_6.Stat.Discipline]: { uncapped: true, plus: true, max: Stat_6.ARMOUR_STAT_MAX_VISUAL, render: renderArmourStat },
        [Stat_6.Stat.Intellect]: { uncapped: true, plus: true, max: Stat_6.ARMOUR_STAT_MAX_VISUAL, render: renderArmourStat },
        [Stat_6.Stat.Strength]: { uncapped: true, plus: true, max: Stat_6.ARMOUR_STAT_MAX_VISUAL, render: renderArmourStat },
        ...customStats,
    };
    for (const [stat, display] of Object.entries(customStatDisplays)) {
        if (!display)
            continue;
        const armourGroup = Stat_6.ARMOUR_STAT_GROUPS.findIndex(group => group.includes(+stat));
        if (armourGroup !== -1)
            display.group = armourGroup;
    }
    class ItemStat extends Component_38.default {
        onMake(stat) {
            this.stat = stat;
            const statName = Stat_6.Stat[this.stat.hash]
                ?? CustomStat[this.stat.hash]
                ?? this.stat.name
                ?? this.stat.definition?.displayProperties.name.replace(/\s+/g, "")
                ?? `${this.stat.hash}`;
            this.groupLabel = stat.group === undefined ? undefined : Component_38.default.create()
                // .text.set(`${stat.group + 1}`)
                .classes.add(ItemStatClasses.GroupLabel)
                .appendTo(this);
            this.label = Component_38.default.create()
                .classes.add(ItemStatClasses.Label)
                .appendTo(this);
            if (this.stat?.bar)
                this.bar = Component_38.default.create()
                    .classes.add(ItemStatClasses.Bar, `${ItemStatClasses.Bar}-${(statName).toLowerCase()}`)
                    .append(this.subclassBar = Component_38.default.create()
                    .classes.add(ItemStatClasses.BarBlock, ItemStatClasses.Subclass))
                    .append(this.intrinsicBar = Component_38.default.create()
                    .classes.add(ItemStatClasses.BarBlock, ItemStatClasses.Intrinsic))
                    .append(this.masterworkBar = Component_38.default.create()
                    .classes.add(ItemStatClasses.BarBlock, ItemStatClasses.Masterwork))
                    .append(this.modBar = Component_38.default.create()
                    .classes.add(ItemStatClasses.BarBlock, ItemStatClasses.Mod))
                    .append(this.chargeBar = Component_38.default.create()
                    .classes.add(ItemStatClasses.BarBlock, ItemStatClasses.Charge))
                    .appendTo(this);
            Component_38.default.create()
                .classes.add(ItemStatClasses.Value)
                .append(this.combinedText = Component_38.default.create()
                .classes.add(ItemStatClasses.Combined))
                .append(this.intrinsicText = Component_38.default.create()
                .classes.add(ItemStatClasses.ValueComponent, ItemStatClasses.Intrinsic))
                .append(this.masterworkText = Component_38.default.create()
                .classes.add(ItemStatClasses.ValueComponent, ItemStatClasses.Masterwork))
                .append(this.modText = Component_38.default.create()
                .classes.add(ItemStatClasses.ValueComponent, ItemStatClasses.Mod))
                .append(this.chargeText = Component_38.default.create()
                .classes.add(ItemStatClasses.ValueComponent, ItemStatClasses.Charge))
                .append(this.formulaText = Component_38.default.create()
                .classes.add(ItemStatClasses.ValueComponent, ItemStatClasses.Formula))
                .appendTo(this);
            this.classes.add(ItemStatClasses.Main, `${ItemStatClasses.Main}-${(statName).toLowerCase()}`);
            this.label.text.set(this.stat?.name ?? this.stat.definition?.displayProperties.name ?? "Unknown Stat");
            const icon = this.stat.definition?.displayProperties.icon;
            if (icon)
                this.label.style.set("--icon", `url("${icon}")`);
        }
        set(display, allStats, item) {
            this.stat = display;
            if (display?.calculate) {
                const calculatedDisplay = display.calculate(display, allStats, item);
                if (!calculatedDisplay) {
                    this.classes.add(Classes_6.Classes.Hidden);
                    return false;
                }
                display = { ...display, ...calculatedDisplay };
            }
            this.classes.remove(Classes_6.Classes.Hidden);
            if (display.group !== undefined && this.groupLabel && item) {
                const distribution = Stat_6.IStatDistribution.get(item);
                if (distribution.overall) {
                    this.groupLabel.style.set("--value", `${distribution.groups[display.group]}`);
                }
            }
            this.label.classes.toggle(!!display.masterwork && (item?.isWeapon() ?? false), ItemStatClasses.LabelMasterwork);
            if (display.intrinsic === undefined && display.masterwork === undefined && display.mod === undefined && display.renderFormula === undefined) {
                const render = this.render(display, display.value, true);
                this.combinedText.text.set(display.combinedText ?? render?.text);
                this.intrinsicText.text.set(render?.text);
                if (display.bar && display.max) {
                    const value = (render?.value ?? 0) / display.max;
                    this.intrinsicBar.style.set("--value", `${value}`)
                        .classes.toggle((render?.value ?? 0) < 0, ItemStatClasses.BarBlockNegative);
                    this.bar.style.set("--value", `${value}`);
                }
                return true;
            }
            let combinedValue = undefined;
            if (combinedValue === undefined) {
                combinedValue = display.combinedValue ?? (display.intrinsic ?? 0) + (display.masterwork ?? 0) + (display.mod ?? 0) + (display.subclass ?? 0) + (display.charge ?? 0);
                if (combinedValue < (display.min ?? -Infinity))
                    combinedValue = display.min;
                if (!display.uncapped && combinedValue > (display.max ?? Infinity))
                    combinedValue = display.max;
            }
            const combinedWithoutNegatives = combinedValue
                - [display.intrinsic ?? 0, display.masterwork ?? 0, display.mod ?? 0, display.subclass ?? 0, display.charge ?? 0]
                    .filter(v => v < 0).splat(Maths_6.default.sum);
            let render = this.render(display, combinedValue, true);
            this.combinedText.style.set("--value", `${render?.value ?? 0}`)
                .text.set(display.combinedText ?? render?.text);
            if (display.bar && display.max) {
                const renderWithoutNegatives = this.render(display, combinedWithoutNegatives, true);
                this.bar
                    .style.set("--value", `${(render?.value ?? 0) / display.max}`)
                    .style.set("--value-total", `${(renderWithoutNegatives?.value ?? 0) / display.max}`)
                    .classes.toggle(display.chunked ?? false, ItemStatClasses.BarChunked)
                    .tweak(display.renderBar, { ...display, ...render }, allStats, item);
            }
            let hadRender = render = this.render(display, display.intrinsic, true);
            this.intrinsicText.text.set(render?.text);
            if (display.bar && display.max)
                this.intrinsicBar.style.set("--value", `${(render?.value ?? 0) / display.max}`);
            render = this.render(display, display.masterwork, !hadRender);
            hadRender ||= render;
            this.masterworkText.text.set(render?.text)
                .classes.toggle(!render?.value && !display.displayEntireFormula, Classes_6.Classes.Hidden);
            if (display.bar && display.max)
                this.masterworkBar.style.set("--value", `${(render?.value ?? 0) / display.max}`);
            render = this.render(display, display.mod, !hadRender);
            hadRender ||= render;
            this.modText.text.set(render?.text)
                .classes.toggle((render?.value ?? 0) < 0, ItemStatClasses.ValueComponentNegative)
                .classes.toggle(!render?.value && !display.displayEntireFormula, Classes_6.Classes.Hidden);
            if (display.bar && display.max)
                this.modBar.style.set("--value", `${(render?.value ?? 0) / display.max}`)
                    .classes.toggle((render?.value ?? 0) < 0, ItemStatClasses.BarBlockNegative);
            render = this.render(display, display.subclass, !hadRender);
            hadRender ||= render;
            if (display.bar && display.max)
                this.subclassBar.style.set("--value", `${(render?.value ?? 0) / display.max}`)
                    .classes.toggle((render?.value ?? 0) < 0, ItemStatClasses.BarBlockNegative);
            render = this.render(display, display.charge, !hadRender);
            hadRender ||= render;
            this.chargeText.text.set(render?.text)
                .data.set("charge-value", render?.text)
                .classes.toggle(!render?.value && !display.displayEntireFormula, Classes_6.Classes.Hidden);
            if (display.bar && display.max)
                this.chargeBar.style.set("--value", `${(render?.value ?? 0) / display.max}`);
            this.formulaText.classes.toggle(!display.renderFormula, Classes_6.Classes.Hidden)
                .removeContents()
                .append(...display.renderFormula?.(display, allStats, item) ?? []);
            return true;
        }
        render(display, value, first) {
            if (value === undefined)
                return undefined;
            return {
                value,
                text: (!first || display.plus) && value >= 0 ? `+${value}` : `${value}`,
            };
        }
    }
    (function (ItemStat) {
        class Wrapper extends Component_38.default {
            onMake() {
                this.map = {};
                this.classes.add(ItemStatClasses.Wrapper);
            }
            setItem(item) {
                const stats = Object.values(item.stats?.values ?? {});
                return this.setStats(stats, item);
            }
            setStats(stats, item) {
                stats = stats.concat(Object.values(customStats));
                let hasAnyVisible = false;
                while (true) {
                    let sorted = false;
                    NextStat: for (const stat of stats) {
                        if (typeof stat.order !== "number") {
                            const searchHash = stat.order.after ?? stat.order.before;
                            for (const pivotStat of stats) {
                                if (pivotStat.hash === searchHash) {
                                    if (typeof pivotStat.order !== "number")
                                        // can't pivot on this stat yet, it doesn't have its own order fixed
                                        continue NextStat;
                                    stat.order = pivotStat.order + 0.01;
                                    sorted = true;
                                }
                            }
                        }
                    }
                    if (!sorted)
                        break;
                }
                stats.sort((a, b) => a.order - b.order);
                const renderedGroups = new Set();
                const statDisplays = {};
                for (const stat of stats) {
                    const custom = customStatDisplays[stat.hash];
                    if (custom === false || custom?.render?.(stat, stats, item) === false)
                        continue;
                    const display = {
                        ...stat,
                        ...custom,
                        ...stat.override,
                    };
                    const component = (this.map[stat.hash] ??= ItemStat.create([display])).appendTo(this);
                    const isVisible = component.set(display, stats, item);
                    hasAnyVisible ||= isVisible;
                    if (isVisible)
                        statDisplays[stat.hash] = display;
                    component.groupLabel?.classes.toggle(renderedGroups.has(custom?.group), Classes_6.Classes.Hidden);
                    renderedGroups.add(custom?.group);
                }
                for (const stat of Object.keys(this.map))
                    this.map[+stat].classes.toggle(!statDisplays[+stat], Classes_6.Classes.Hidden);
                this.classes.toggle(!hasAnyVisible, Classes_6.Classes.Hidden);
                return hasAnyVisible;
            }
        }
        ItemStat.Wrapper = Wrapper;
    })(ItemStat || (ItemStat = {}));
    exports.default = ItemStat;
});
define("ui/destiny/tooltip/item/ItemStatTracker", ["require", "exports", "ui/component/Component", "ui/utility/Classes", "ui/utility/DisplayProperties"], function (require, exports, Component_39, Classes_7, DisplayProperties_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemStatTrackerClasses = void 0;
    var ItemStatTrackerClasses;
    (function (ItemStatTrackerClasses) {
        ItemStatTrackerClasses["Main"] = "item-stat-tracker";
        ItemStatTrackerClasses["Icon"] = "item-stat-tracker-icon";
        ItemStatTrackerClasses["Label"] = "item-stat-tracker-label";
        ItemStatTrackerClasses["Value"] = "item-stat-tracker-value";
    })(ItemStatTrackerClasses || (exports.ItemStatTrackerClasses = ItemStatTrackerClasses = {}));
    class ItemStatTracker extends Component_39.default {
        onMake() {
            this.classes.add(ItemStatTrackerClasses.Main)
                .append(this.icon = Component_39.default.create()
                .classes.add(ItemStatTrackerClasses.Icon))
                .append(this.label = Component_39.default.create()
                .classes.add(ItemStatTrackerClasses.Label))
                .append(this.value = Component_39.default.create()
                .classes.add(ItemStatTrackerClasses.Value));
        }
        setItem(item) {
            const statTracker = item.getStatTracker();
            this.classes.toggle(!statTracker, Classes_7.Classes.Hidden);
            this.icon.style.set("--icon", DisplayProperties_2.default.icon(statTracker?.definition));
            this.label.text.set(statTracker?.definition.progressDescription ?? DisplayProperties_2.default.name(statTracker?.definition));
            this.value.text.set(`${(statTracker?.progress.progress ?? 0).toLocaleString()}`);
            return this;
        }
    }
    exports.default = ItemStatTracker;
});
define("ui/destiny/tooltip/item/ItemTooltipMods", ["require", "exports", "ui/component/Component", "ui/component/LoadedIcon", "ui/utility/DisplayProperties"], function (require, exports, Component_40, LoadedIcon_2, DisplayProperties_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemTooltipModsClasses = void 0;
    var ItemTooltipModsClasses;
    (function (ItemTooltipModsClasses) {
        ItemTooltipModsClasses["Main"] = "item-tooltip-mods";
        ItemTooltipModsClasses["Detailed"] = "item-tooltip-mods-detailed";
        ItemTooltipModsClasses["Shaped"] = "item-tooltip-mods-shaped";
        ItemTooltipModsClasses["Mod"] = "item-tooltip-mod";
        ItemTooltipModsClasses["ModEnhanced"] = "item-tooltip-mod-enhanced";
        ItemTooltipModsClasses["ModEnhancedArrow"] = "item-tooltip-mod-enhanced-arrow";
        ItemTooltipModsClasses["ModSocket"] = "item-tooltip-mod-socket";
        ItemTooltipModsClasses["ModIntrinsic"] = "item-tooltip-mod-intrinsic";
        ItemTooltipModsClasses["ModSocketEnhanced"] = "item-tooltip-mod-socket-enhanced";
        ItemTooltipModsClasses["ModSocketDefinition"] = "item-tooltip-mod-socket-definition";
        ItemTooltipModsClasses["ModSocketed"] = "item-tooltip-mod-socketed";
        ItemTooltipModsClasses["ModHasName"] = "item-tooltip-mod-has-name";
        ItemTooltipModsClasses["ModName"] = "item-tooltip-mod-name";
        ItemTooltipModsClasses["ModRequiredLevel"] = "item-tooltip-mod-required-level";
        ItemTooltipModsClasses["ModRequiredLevelAdept"] = "item-tooltip-mod-required-level-adept";
        ItemTooltipModsClasses["ModDescription"] = "item-tooltip-mod-description";
        ItemTooltipModsClasses["ModHasDescription"] = "item-tooltip-mod-has-description";
        ItemTooltipModsClasses["ModIcon"] = "item-tooltip-mod-icon";
    })(ItemTooltipModsClasses || (exports.ItemTooltipModsClasses = ItemTooltipModsClasses = {}));
    class ItemTooltipMods extends Component_40.default {
        onMake() {
            this.classes.add(ItemTooltipModsClasses.Main);
        }
        setDetailed(detailed = true) {
            this.classes.toggle(detailed, ItemTooltipModsClasses.Detailed);
            return this;
        }
        setShaped(shaped = true) {
            this.classes.toggle(shaped, ItemTooltipModsClasses.Shaped);
            return this;
        }
        isDetailed() {
            return this.classes.has(ItemTooltipModsClasses.Detailed);
        }
        isShaped() {
            return this.classes.has(ItemTooltipModsClasses.Shaped);
        }
        setItem(item, ...filters) {
            this.removeContents();
            this.addSockets(item, ItemTooltipModsClasses.ModIntrinsic, "Intrinsic", "!Intrinsic/Origin", ...filters);
            this.addPerks(item, ItemTooltipModsClasses.ModIntrinsic, "=Masterwork/ExoticCatalyst", ...filters);
            this.addSockets(item, ItemTooltipModsClasses.ModIntrinsic, "Intrinsic/Origin", ...filters);
            this.addSockets(item, undefined, "Perk", ...filters);
            this.addPerks(item, undefined, "Mod", ...filters);
            return this;
        }
        addPerks(item, socketClass, ...anyOfTypes) {
            const detailed = this.isDetailed();
            let i = 0;
            for (const socket of item.getSockets(...anyOfTypes)) {
                if (!socket.state || socket.state.isVisible === false)
                    continue;
                const plugs = socket.plugs ?? [];
                const plug = socket.socketedPlug;
                const displayablePerks = socket.socketedPlug?.perks
                    .filter(perk => perk.perkVisibility !== 2 /* ItemPerkVisibility.Hidden */
                    && perk.definition.isDisplayable
                    && (socket.is("Masterwork/ExoticCatalyst") ? item.isMasterwork() : true))
                    ?? [];
                for (const perk of displayablePerks) {
                    const socketComponent = Component_40.default.create()
                        .classes.add(ItemTooltipModsClasses.ModSocket, ...socketClass ? [socketClass] : [])
                        .classes.toggle(socket.state !== undefined && plugs.some(plug => plug.is("=Masterwork/ExoticCatalyst")), ItemTooltipModsClasses.ModSocketEnhanced)
                        .style.set("--socket-index", `${i++}`)
                        .appendTo(this);
                    const name = detailed ? DisplayProperties_3.default.nameIfShortOrName(perk.definition, plug?.definition)
                        : DisplayProperties_3.default.descriptionIfShortOrName(perk.definition, plug?.definition) ?? "Unknown";
                    const description = DisplayProperties_3.default.description(perk.definition);
                    const isEnhanced = plug?.is("=Masterwork/ExoticCatalyst") ?? false;
                    Component_40.default.create()
                        .classes.add(ItemTooltipModsClasses.Mod, ItemTooltipModsClasses.ModSocketed, ItemTooltipModsClasses.ModHasName)
                        .classes.toggle(isEnhanced, ItemTooltipModsClasses.ModEnhanced)
                        .append(LoadedIcon_2.default.create([DisplayProperties_3.default.icon(perk.definition, false)])
                        .classes.add(ItemTooltipModsClasses.ModIcon))
                        .append(!isEnhanced ? undefined : Component_40.default.create()
                        .classes.add(ItemTooltipModsClasses.ModEnhancedArrow))
                        .append(Component_40.default.create()
                        .classes.add(ItemTooltipModsClasses.ModName)
                        .text.set(name))
                        .append(!detailed || !description || description === name ? undefined : Component_40.default.create()
                        .classes.add(ItemTooltipModsClasses.ModDescription)
                        .text.set(description))
                        .appendTo(socketComponent);
                }
            }
        }
        addSockets(item, socketClass, ...anyOfTypes) {
            const isCollections = item.bucket.isCollections();
            let i = 0;
            let traitIndex = 0;
            for (const socket of item.getSockets(...anyOfTypes)) {
                if (!socket || socket.state?.isVisible === false)
                    continue;
                const plugs = (socket.plugs ?? [])
                    .filter(plug => plug.isNot("Perk/EmptyCraftingSocket", "Intrinsic/EmptyCraftingSocket"));
                const willDisplayMoreThanOnePlug = isCollections && plugs.length > 1;
                if (willDisplayMoreThanOnePlug && (this.isDetailed() || !plugs.some(plug => DisplayProperties_3.default.icon(plug.definition))))
                    continue;
                const socketComponent = Component_40.default.create()
                    .classes.add(ItemTooltipModsClasses.ModSocket, ...socketClass ? [socketClass] : [])
                    .classes.toggle(socket.state !== undefined && plugs.some(plug => plug.is("Perk/TraitEnhanced", "Intrinsic/FrameEnhanced")), ItemTooltipModsClasses.ModSocketEnhanced)
                    .classes.toggle(socket.state === undefined, ItemTooltipModsClasses.ModSocketDefinition)
                    .style.set("--socket-index", `${i++}`)
                    .appendTo(this);
                const mightDisplayMoreThan13PlugsDueToEnhanced = plugs.length > 13 && this.isShaped() && plugs.some(plug => plug.is("Perk/TraitEnhanced") && !(!item.shaped && !plug.craftingRequirements?.unlockRequirements.length));
                for (const plug of plugs.slice().sort((a, b) => Number(b.socketed && !isCollections) - Number(a.socketed && !isCollections))) {
                    if (!socket.state && plug.is("Intrinsic/FrameEnhanced"))
                        // skip enhanced intrinsics (duplicates) if this is an item definition (ie no actual socket state)
                        continue;
                    if (plug.is("Perk/TraitLocked"))
                        continue;
                    const isEnhanced = (false
                        || plug.is("Perk/TraitEnhanced", "Intrinsic/FrameEnhanced")
                        || (plug.categorisation?.category === 2 /* DeepsightPlugCategory.Perk */ && plug.type.endsWith("Enhanced")));
                    if (mightDisplayMoreThan13PlugsDueToEnhanced && !isEnhanced)
                        continue;
                    if (!item.instance && !item.shaped && isEnhanced && (!plug.craftingRequirements?.unlockRequirements.length || !this.isShaped()))
                        continue;
                    const plugComponent = Component_40.default.create()
                        .classes.add(ItemTooltipModsClasses.Mod)
                        .classes.toggle(!!plug?.socketed, ItemTooltipModsClasses.ModSocketed)
                        .classes.toggle(isEnhanced, ItemTooltipModsClasses.ModEnhanced)
                        .append(LoadedIcon_2.default.create([DisplayProperties_3.default.icon(plug.definition, false)])
                        .classes.add(ItemTooltipModsClasses.ModIcon))
                        .appendTo(socketComponent);
                    if (isEnhanced)
                        Component_40.default.create()
                            .classes.add(ItemTooltipModsClasses.ModEnhancedArrow)
                            .appendTo(plugComponent);
                    if (item.shaped && item.isAdept() && socket.is("Perk/Trait")) {
                        const requiredLevel = traitIndex ? 17 : 11;
                        const currentLevel = item.shaped.level?.progress.progress ?? 0;
                        if (currentLevel < requiredLevel)
                            Component_40.default.create()
                                .classes.add(ItemTooltipModsClasses.ModRequiredLevel, ItemTooltipModsClasses.ModRequiredLevelAdept)
                                .text.set(`${requiredLevel}`)
                                .appendTo(plugComponent);
                        traitIndex++;
                    }
                    const displayPlugs = plugs.filter(plug => plug.isNot("Intrinsic/FrameEnhanced"));
                    if (plug?.socketed && (socket.state || (displayPlugs?.length <= 1 || socket.is("Intrinsic", "!Intrinsic/Exotic", "!Intrinsic/Frame")))) {
                        plugComponent.classes.add(ItemTooltipModsClasses.ModHasName);
                        Component_40.default.create()
                            .classes.add(ItemTooltipModsClasses.ModName)
                            .text.set(DisplayProperties_3.default.name(plug.definition) ?? "Unknown")
                            .appendTo(plugComponent);
                        const description = this.isDetailed() && DisplayProperties_3.default.description(plug.definition);
                        if (description)
                            Component_40.default.create()
                                .classes.add(ItemTooltipModsClasses.ModDescription)
                                .text.set(description)
                                .appendTo(plugComponent.classes.add(ItemTooltipModsClasses.ModHasDescription));
                    }
                    else if (isCollections && item.deepsight?.pattern?.recipe && !item.isAdept() && this.isShaped()) {
                        Component_40.default.create()
                            .classes.add(ItemTooltipModsClasses.ModRequiredLevel)
                            .text.set(`${plug.craftingRequirements?.requiredLevel ?? 1}`)
                            .appendTo(plugComponent);
                    }
                    if (this.isDetailed())
                        break;
                }
            }
        }
    }
    exports.default = ItemTooltipMods;
});
define("ui/destiny/tooltip/item/ItemTooltipNotifications", ["require", "exports", "ui/component/Component", "ui/utility/DisplayProperties", "utility/Strings"], function (require, exports, Component_41, DisplayProperties_4, Strings_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemTooltipNotificationsClasses = void 0;
    const EXCLUDED_NOTIFICATIONS_SUBSTRINGS = [
        "Deepsight activation is available for this weapon.",
        "Deepsight activation is not available for this weapon instance.",
        "This weapon's Pattern can be extracted.",
        "This weapon can be enhanced.",
        "This weapon can be enhanced further.",
        "This weapon is fully enhanced.",
        "This weapon can be modified at the Relic.",
        "This weapon is fully enhanced and can be modified at the Relic on Mars.",
        "This weapon can be enhanced further and modified at the Relic on Mars.",
    ];
    var ItemTooltipNotificationsClasses;
    (function (ItemTooltipNotificationsClasses) {
        ItemTooltipNotificationsClasses["Main"] = "item-tooltip-notifications";
        ItemTooltipNotificationsClasses["Notification"] = "item-tooltip-notification";
        ItemTooltipNotificationsClasses["NotificationStyle"] = "item-tooltip-notification-style";
        ItemTooltipNotificationsClasses["NotificationIcon"] = "item-tooltip-notification-icon";
        ItemTooltipNotificationsClasses["NotificationDescription"] = "item-tooltip-notification-description";
    })(ItemTooltipNotificationsClasses || (exports.ItemTooltipNotificationsClasses = ItemTooltipNotificationsClasses = {}));
    class ItemTooltipPerks extends Component_41.default {
        onMake() {
            this.classes.add(ItemTooltipNotificationsClasses.Main);
        }
        setItem(item) {
            this.removeContents();
            for (const index of item.reference.tooltipNotificationIndexes ?? []) {
                const notification = item.definition.tooltipNotifications[index];
                if (!notification)
                    continue;
                if (EXCLUDED_NOTIFICATIONS_SUBSTRINGS.some(substring => notification.displayString.includes(substring)))
                    continue;
                Component_41.default.create()
                    .classes.add(ItemTooltipNotificationsClasses.Notification)
                    .classes.add(`${ItemTooltipNotificationsClasses.NotificationStyle}-${Strings_3.default.trimTextMatchingFromStart(notification.displayStyle, "ui_display_style_")}`)
                    .append(Component_41.default.create()
                    .classes.add(ItemTooltipNotificationsClasses.NotificationIcon))
                    .append(Component_41.default.create()
                    .classes.add(ItemTooltipNotificationsClasses.NotificationDescription)
                    .tweak(DisplayProperties_4.default.applyDescription, notification.displayString, item.character?.characterId))
                    .appendTo(this);
            }
        }
    }
    exports.default = ItemTooltipPerks;
});
define("ui/destiny/tooltip/item/ItemTooltipPerks", ["require", "exports", "ui/component/Component", "ui/utility/DisplayProperties"], function (require, exports, Component_42, DisplayProperties_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemTooltipPerksClasses = void 0;
    var ItemTooltipPerksClasses;
    (function (ItemTooltipPerksClasses) {
        ItemTooltipPerksClasses["Main"] = "item-tooltip-perks";
        ItemTooltipPerksClasses["Perk"] = "item-tooltip-perk";
        ItemTooltipPerksClasses["PerkIcon"] = "item-tooltip-perk-icon";
        ItemTooltipPerksClasses["PerkDisabled"] = "item-tooltip-perk-disabled";
        ItemTooltipPerksClasses["PerkDescription"] = "item-tooltip-perk-description";
    })(ItemTooltipPerksClasses || (exports.ItemTooltipPerksClasses = ItemTooltipPerksClasses = {}));
    class ItemTooltipPerks extends Component_42.default {
        onMake() {
            this.classes.add(ItemTooltipPerksClasses.Main);
        }
        setItem(item) {
            this.removeContents();
            for (const perk of item.perks ?? []) {
                if (!perk.definition.isDisplayable)
                    continue;
                if (perk.reference ? !perk.reference.visible : perk.perkVisibility === 2 /* ItemPerkVisibility.Hidden */)
                    continue;
                Component_42.default.create()
                    .classes.add(ItemTooltipPerksClasses.Perk)
                    .classes.toggle(perk.perkVisibility === 1 /* ItemPerkVisibility.Disabled */, ItemTooltipPerksClasses.PerkDisabled)
                    .append(Component_42.default.create()
                    .classes.add(ItemTooltipPerksClasses.PerkIcon)
                    .style.set("--icon", DisplayProperties_5.default.icon(perk.definition)))
                    .append(Component_42.default.create()
                    .classes.add(ItemTooltipPerksClasses.PerkDescription)
                    .tweak(DisplayProperties_5.default.applyDescription, DisplayProperties_5.default.description(perk.definition), item.character?.characterId))
                    .appendTo(this);
            }
        }
    }
    exports.default = ItemTooltipPerks;
});
define("ui/destiny/tooltip/item/ItemTooltipSource", ["require", "exports", "model/models/Manifest", "ui/component/Component", "ui/utility/DisplayProperties", "utility/decorator/Bound"], function (require, exports, Manifest_15, Component_43, DisplayProperties_6, Bound_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemTooltipSourceClasses = void 0;
    const _ = undefined;
    var ItemTooltipSourceClasses;
    (function (ItemTooltipSourceClasses) {
        ItemTooltipSourceClasses["Main"] = "item-tooltip-source";
        ItemTooltipSourceClasses["Heading"] = "item-tooltip-source-heading";
        ItemTooltipSourceClasses["ActivityWrapper"] = "item-tooltip-source-activity-wrapper";
        ItemTooltipSourceClasses["Activity"] = "item-tooltip-source-activity";
        ItemTooltipSourceClasses["ActivityName"] = "item-tooltip-source-activity-name";
        ItemTooltipSourceClasses["ActivityDescription"] = "item-tooltip-source-activity-description";
        ItemTooltipSourceClasses["ActivityPhaseWrapper"] = "item-tooltip-source-activity-phase-wrapper";
        ItemTooltipSourceClasses["ActivityPhase"] = "item-tooltip-source-activity-phase";
        ItemTooltipSourceClasses["ActivityPhaseIndex"] = "item-tooltip-source-activity-phase-index";
        ItemTooltipSourceClasses["ActivityPhaseName"] = "item-tooltip-source-activity-phase-name";
        ItemTooltipSourceClasses["ActivityPhaseChance"] = "item-tooltip-source-activity-phase-chance";
        ItemTooltipSourceClasses["ActivityPhaseChance_Wishlisted"] = "item-tooltip-source-activity-phase-chance--wishlisted";
        ItemTooltipSourceClasses["ActivityPhaseDescription"] = "item-tooltip-source-activity-phase-description";
        ItemTooltipSourceClasses["ActivityChallenge"] = "item-tooltip-source-activity-challenge";
        ItemTooltipSourceClasses["ActivityChallengePhaseIndex"] = "item-tooltip-source-activity-challenge-phase-index";
        ItemTooltipSourceClasses["ActivityRequiredItem"] = "item-tooltip-source-activity-required-item";
        ItemTooltipSourceClasses["ActivityRequiredItemLabel"] = "item-tooltip-source-activity-required-item-label";
        ItemTooltipSourceClasses["ActivityRequiredItemDescription"] = "item-tooltip-source-activity-required-item-description";
        ItemTooltipSourceClasses["Note"] = "item-tooltip-note";
        ItemTooltipSourceClasses["NoteHeading"] = "item-tooltip-note-heading";
    })(ItemTooltipSourceClasses || (exports.ItemTooltipSourceClasses = ItemTooltipSourceClasses = {}));
    class ItemTooltipSource extends Component_43.default {
        onMake() {
            this.classes.add(ItemTooltipSourceClasses.Main);
            this.heading = Component_43.default.create()
                .classes.add(ItemTooltipSourceClasses.Heading, ItemTooltipSourceClasses.Note, ItemTooltipSourceClasses.NoteHeading)
                .text.set("This item can drop from the following activities:")
                .appendTo(this);
            this.activityWrapper = Component_43.default.create()
                .classes.add(ItemTooltipSourceClasses.ActivityWrapper)
                .appendTo(this);
        }
        setItem(item) {
            this.activityWrapper.removeContents();
            if (!item.bucket.isCollections())
                return false;
            if (!item.sources?.length) {
                if (!item.hasWishlist())
                    return false;
                Component_43.default.create()
                    // .classes.add(ItemTooltipSourceClasses.Activity)
                    .tweak(this.renderDropChance, item)
                    .appendTo(this.activityWrapper);
                return true;
            }
            const hashes = new Set();
            for (const source of item.sources) {
                if (hashes.has(source.activityDefinition.hash))
                    continue;
                hashes.add(source.activityDefinition.hash);
                let activity = source.activityDefinition;
                if (source.isActiveMasterDrop) {
                    if (!source.masterActivityDefinition)
                        // missing master activity, can't display source
                        continue;
                    activity = source.masterActivityDefinition;
                }
                const activityComponent = Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.Activity)
                    .style.set("--icon", _
                    ?? DisplayProperties_6.default.icon(source.dropTable.displayProperties)
                    ?? DisplayProperties_6.default.icon(activity))
                    .appendTo(this.activityWrapper);
                const lostSectorDisplay = !source.activityDefinition.activityModeHashes?.includes(103143560 /* ActivityModeHashes.LostSector */) ? undefined
                    : source.isActiveDrop ? undefined
                        : { name: "Lost Sector", description: "This item is not currently available." };
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityName)
                    .text.set(_
                    ?? DisplayProperties_6.default.name(lostSectorDisplay)
                    ?? DisplayProperties_6.default.name(source.dropTable.displayProperties)
                    ?? DisplayProperties_6.default.name(activity))
                    .appendTo(activityComponent);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityDescription)
                    .tweak(DisplayProperties_6.default.applyDescription, (DisplayProperties_6.default.description(lostSectorDisplay)
                    ?? DisplayProperties_6.default.description(source.dropTable.displayProperties)
                    ?? DisplayProperties_6.default.description(activity)), {
                    character: item.owner?.characterId,
                    singleLine: true,
                })
                    .appendTo(activityComponent);
                const phasesWrapper = Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseWrapper)
                    .appendTo(activityComponent);
                if (source.requiresQuest !== undefined)
                    this.renderRequiredItems(phasesWrapper, item, source, [source.requiresQuest], "quest");
                if (source.requiresItems?.length)
                    this.renderRequiredItems(phasesWrapper, item, source, source.requiresItems);
                if (!source.isActiveMasterDrop && source.dropTable.encounters?.length)
                    this.renderPhases(phasesWrapper, item, source);
                else if (source.activeChallenges.length && item.isFomo())
                    this.renderChallenge(phasesWrapper, item, source);
                else if (source.purchaseOnly)
                    Component_43.default.create()
                        .classes.add(ItemTooltipSourceClasses.ActivityChallenge)
                        .style.set("--icon", DisplayProperties_6.default.icon("./image/png/activity/cache.png"))
                        .append(Component_43.default.create()
                        .classes.add(ItemTooltipSourceClasses.ActivityPhaseName)
                        .text.set("Purchase Only"))
                        .append(Component_43.default.create()
                        .classes.add(ItemTooltipSourceClasses.ActivityPhaseDescription)
                        .text.set("This item is available in the end-of-activity cache."))
                        .appendTo(phasesWrapper);
                else
                    Component_43.default.create()
                        .style.set("display", "contents")
                        .tweak(this.renderDropChance, item)
                        .appendTo(activityComponent);
            }
            return true;
        }
        renderRequiredItems(wrapper, forItem, source, items, type = "item") {
            for (const item of items) {
                const challengeComponent = Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityChallenge)
                    .style.set("--icon", item ? DisplayProperties_6.default.icon(item) : undefined)
                    .appendTo(wrapper);
                const typeText = type === "item" ? "Item" : "Quest";
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseName)
                    .text.set(item ? DisplayProperties_6.default.name(item) : "Unknown Item")
                    .append(Component_43.default.create("span")
                    .classes.add(ItemTooltipSourceClasses.ActivityRequiredItemLabel)
                    .text.set(` \xa0//\xa0 Required ${typeText}`))
                    .appendTo(challengeComponent);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityRequiredItemDescription)
                    .text.set(item ? DisplayProperties_6.default.description(item) : `This ${type} is required to obtain ${DisplayProperties_6.default.name(forItem.definition)}`)
                    .appendTo(challengeComponent);
            }
        }
        renderChallenge(wrapper, item, source) {
            for (const challenge of source.activeChallenges) {
                const challengeHashes = source.dropTable.rotations?.challenges;
                const challengeIndex = challengeHashes?.indexOf(challenge.hash) ?? -1;
                const encounters = source.dropTable.encounters?.filter(encounter => !encounter.traversal);
                const phase = challengeHashes?.length === encounters?.length ? encounters?.[challengeIndex] : undefined;
                const challengeComponent = Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityChallenge)
                    .style.set("--icon", DisplayProperties_6.default.icon(challenge))
                    .appendTo(wrapper);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseName)
                    .append(Component_43.default.create("span")
                    .text.set(DisplayProperties_6.default.name(challenge)))
                    .tweak(this.renderDropChance, item, source.dropTable.master?.dropTable ?? {})
                    .appendTo(challengeComponent);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseDescription)
                    .append(challengeIndex < 0 ? undefined : Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityChallengePhaseIndex)
                    .text.set(`${challengeIndex + 1}`))
                    .text.set(DisplayProperties_6.default.name(phase))
                    .appendTo(challengeComponent);
            }
        }
        renderPhases(wrapper, item, source) {
            if (!source.dropTable.encounters?.length)
                return;
            let realEncounterIndex = 0;
            for (let i = 0; i < source.dropTable.encounters.length; i++) {
                const encounter = source.dropTable.encounters[i];
                if (encounter.traversal)
                    continue;
                realEncounterIndex++;
                const dropTable = encounter.dropTableMergeStrategy === "replace" ? encounter.dropTable
                    : { ...source.dropTable.dropTable, ...encounter.dropTable };
                if (!dropTable?.[item.definition.hash])
                    continue;
                const phaseComponent = Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhase)
                    .appendTo(wrapper);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseIndex)
                    .text.set(`${realEncounterIndex}`)
                    .appendTo(phaseComponent);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseName)
                    .append(Component_43.default.create("span")
                    .text.set(DisplayProperties_6.default.name(encounter)))
                    .tweak(this.renderDropChance, item, dropTable)
                    .appendTo(phaseComponent);
                Component_43.default.create()
                    .classes.add(ItemTooltipSourceClasses.ActivityPhaseDescription)
                    .text.set(DisplayProperties_6.default.description(encounter) || `Clear ${DisplayProperties_6.default.name(encounter)}`)
                    .appendTo(phaseComponent);
            }
        }
        renderDropChance(wrapper, item, dropTable) {
            if (!dropTable && !item.hasWishlist())
                return;
            const drop = !dropTable ? {} : dropTable?.[item.definition.hash];
            if (!drop)
                return;
            if (item.isExotic())
                return;
            if (drop.requiresQuest || drop.requiresItems)
                return;
            Component_43.default.create("span")
                .classes.add(ItemTooltipSourceClasses.ActivityPhaseChance)
                .tweak(async (span) => {
                const { DestinyInventoryItemDefinition } = await Manifest_15.default.await();
                const items = !dropTable ? [item.definition] : await Promise.all(Object.keys(dropTable)
                    .map(hash => DestinyInventoryItemDefinition.get(hash)));
                const totalDrops = items
                    .filter(item => true
                    // && !/\([\w -]+\)\s*$/.test(item?.displayProperties.name ?? "")
                    && item?.classType !== 1 /* DestinyClass.Hunter */
                    && item?.classType !== 0 /* DestinyClass.Titan */
                    && !item?.sockets?.socketEntries.some(socket => socket.singleInitialItemHash === 3727270518 /* InventoryItemHashes.ArtificeArmorIntrinsicPlug */)
                    && item?.inventory?.tierType !== 6 /* TierType.Exotic */
                    && !item?.itemCategoryHashes?.includes(3109687656 /* ItemCategoryHashes.Dummies */)
                    && !item?.itemCategoryHashes?.includes(40 /* ItemCategoryHashes.Materials */))
                    .length;
                const wishlistChance = item.getWishlistChance();
                span.classes.toggle(wishlistChance !== 1, ItemTooltipSourceClasses.ActivityPhaseChance_Wishlisted);
                span.text.set(`${((1 / totalDrops) * wishlistChance * 100).toFixed(1)}% \xa0- \xa01 in ${Math.round(totalDrops / wishlistChance)}`);
            })
                .appendTo(wrapper);
        }
    }
    exports.default = ItemTooltipSource;
    __decorate([
        Bound_16.default
    ], ItemTooltipSource.prototype, "renderDropChance", null);
});
define("ui/destiny/utility/ElementTypes", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ElementTypes;
    (function (ElementTypes) {
        ElementTypes.COLOURS = {
            arc: 0x7aecf3,
            solar: 0xf0631e,
            void: 0xb185df,
            stasis: 0x4d88ff,
            strand: 0x35e366,
        };
        function getColour(element) {
            return ElementTypes.COLOURS[element]
                ?.toString(16)
                .padStart(6, "0")
                .padStart(7, "#");
        }
        ElementTypes.getColour = getColour;
    })(ElementTypes || (ElementTypes = {}));
    exports.default = ElementTypes;
});
define("ui/destiny/tooltip/ItemTooltip", ["require", "exports", "model/models/Manifest", "model/models/items/Item", "ui/component/Component", "ui/component/Hints", "ui/destiny/playeroverview/LoadoutComponent", "ui/destiny/tooltip/item/ItemAmmo", "ui/destiny/tooltip/item/ItemStat", "ui/destiny/tooltip/item/ItemStatTracker", "ui/destiny/tooltip/item/ItemTooltipMods", "ui/destiny/tooltip/item/ItemTooltipNotifications", "ui/destiny/tooltip/item/ItemTooltipPerks", "ui/destiny/tooltip/item/ItemTooltipSource", "ui/destiny/utility/ElementTypes", "ui/utility/Classes", "ui/utility/DisplayProperties", "ui/utility/TooltipManager", "ui/utility/UiEventBus", "utility/Arrays", "utility/decorator/Bound"], function (require, exports, Manifest_16, Item_3, Component_44, Hints_2, LoadoutComponent_1, ItemAmmo_1, ItemStat_1, ItemStatTracker_1, ItemTooltipMods_1, ItemTooltipNotifications_1, ItemTooltipPerks_1, ItemTooltipSource_1, ElementTypes_1, Classes_8, DisplayProperties_7, TooltipManager_2, UiEventBus_3, Arrays_7, Bound_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemTooltipClasses = void 0;
    const _ = undefined;
    var ItemTooltipClasses;
    (function (ItemTooltipClasses) {
        ItemTooltipClasses["Main"] = "item-tooltip";
        ItemTooltipClasses["Rarity_"] = "item-tooltip-tier-";
        ItemTooltipClasses["Extra"] = "item-tooltip-extra";
        ItemTooltipClasses["Content"] = "item-tooltip-content";
        ItemTooltipClasses["ProgressBar"] = "item-tooltip-progress-bar";
        ItemTooltipClasses["MomentWatermark"] = "item-tooltip-moment-watermark";
        ItemTooltipClasses["MomentWatermark_Featured"] = "item-tooltip-moment-watermark--featured";
        // MomentWatermark_Sunset = "item-tooltip-moment-watermark--sunset",
        ItemTooltipClasses["MomentWatermarkTier"] = "item-tooltip-moment-watermark-tier";
        ItemTooltipClasses["MomentWatermarkTier_"] = "item-tooltip-moment-watermark-tier--";
        ItemTooltipClasses["MomentWatermarkTierDot"] = "item-tooltip-moment-watermark-tier-dot";
        ItemTooltipClasses["Locked"] = "item-tooltip-locked";
        ItemTooltipClasses["Unlocked"] = "item-tooltip-unlocked";
        ItemTooltipClasses["Masterwork"] = "item-tooltip-masterwork";
        ItemTooltipClasses["Artifact"] = "item-tooltip-artifact";
        ItemTooltipClasses["PrimaryInfo"] = "item-tooltip-primary-info";
        ItemTooltipClasses["PrimaryStat"] = "item-tooltip-primary-stat";
        ItemTooltipClasses["PrimaryStatValue"] = "item-tooltip-primary-stat-value";
        ItemTooltipClasses["PrimaryStatLabel"] = "item-tooltip-primary-stat-label";
        ItemTooltipClasses["PrimaryStatDamage"] = "item-tooltip-primary-stat-damage";
        ItemTooltipClasses["PrimaryStatDamageIcon"] = "item-tooltip-primary-stat-damage-icon";
        ItemTooltipClasses["PrimaryStatHasElementRight"] = "item-tooltip-primary-stat-has-element-right";
        ItemTooltipClasses["Energy"] = "item-tooltip-energy";
        ItemTooltipClasses["EnergyValue"] = "item-tooltip-energy-value";
        ItemTooltipClasses["WeaponLevel"] = "item-tooltip-weapon-level";
        ItemTooltipClasses["WeaponLevelLabel"] = "item-tooltip-weapon-level-label";
        ItemTooltipClasses["WeaponLevelProgress"] = "item-tooltip-weapon-level-progress";
        ItemTooltipClasses["WeaponLevelEnhanced"] = "item-tooltip-weapon-level-enhanced";
        ItemTooltipClasses["Catalyst"] = "item-tooltip-catalyst";
        ItemTooltipClasses["Description"] = "item-tooltip-description";
        ItemTooltipClasses["Stats"] = "item-tooltip-stats";
        ItemTooltipClasses["Deepsight"] = "item-tooltip-deepsight";
        ItemTooltipClasses["DeepsightPatternLabel"] = "item-tooltip-deepsight-pattern-label";
        ItemTooltipClasses["DeepsightPatternNumber"] = "item-tooltip-deepsight-pattern-number";
        ItemTooltipClasses["DeepsightPatternOutOf"] = "item-tooltip-deepsight-pattern-out-of";
        ItemTooltipClasses["DeepsightPatternRequired"] = "item-tooltip-deepsight-pattern-required";
        ItemTooltipClasses["DeepsightPatternRequiredUnit"] = "item-tooltip-deepsight-pattern-required-unit";
        ItemTooltipClasses["DeepsightProgressBar"] = "item-tooltip-deepsight-progress-bar";
        ItemTooltipClasses["DeepsightProgressValue"] = "item-tooltip-deepsight-progress-value";
        ItemTooltipClasses["Enhance"] = "item-tooltip-enhance";
        ItemTooltipClasses["Wishlist"] = "item-tooltip-wishlist";
        ItemTooltipClasses["Wishlisted"] = "item-tooltip-wishlisted";
        ItemTooltipClasses["Fomo"] = "item-tooltip-fomo";
        ItemTooltipClasses["Note"] = "item-tooltip-note";
        ItemTooltipClasses["NoteHeading"] = "item-tooltip-note-heading";
        ItemTooltipClasses["Flavour"] = "item-tooltip-flavour";
        ItemTooltipClasses["RandomRollHeading"] = "item-tooltip-random-roll-heading";
        ItemTooltipClasses["LoadoutsWrapper"] = "item-tooltip-loadouts-wrapper";
        ItemTooltipClasses["Loadouts"] = "item-tooltip-loadouts";
        ItemTooltipClasses["Loadout"] = "item-tooltip-loadout";
    })(ItemTooltipClasses || (exports.ItemTooltipClasses = ItemTooltipClasses = {}));
    class ItemTooltip extends TooltipManager_2.Tooltip {
        constructor() {
            super(...arguments);
            this.awaitingShiftForLock = false;
        }
        onMake() {
            this.classes.add(ItemTooltipClasses.Main);
            this.content.classes.add(ItemTooltipClasses.Content);
            this.moment = Component_44.default.create()
                .classes.add(ItemTooltipClasses.MomentWatermark, Classes_8.Classes.Hidden)
                .appendTo(this.header);
            this.tier = Component_44.default.create()
                .classes.add(ItemTooltipClasses.MomentWatermarkTier)
                .appendTo(this.moment);
            this.locked = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Locked, Classes_8.Classes.Hidden)
                .appendTo(this.rarity);
            this.primaryInfo = Component_44.default.create()
                .classes.add(ItemTooltipClasses.PrimaryInfo)
                .appendTo(this.content);
            this.primaryStat = Component_44.default.create()
                .classes.add(ItemTooltipClasses.PrimaryStat)
                .appendTo(this.primaryInfo);
            this.primaryStatValue = Component_44.default.create()
                .classes.add(ItemTooltipClasses.PrimaryStatValue)
                .appendTo(this.primaryStat);
            this.primaryStatDamageIcon = Component_44.default.create("img")
                .classes.add(ItemTooltipClasses.PrimaryStatDamageIcon)
                .appendTo(this.primaryStatValue);
            this.primaryStatLabel = Component_44.default.create()
                .classes.add(ItemTooltipClasses.PrimaryStatLabel)
                .appendTo(this.primaryStat);
            this.ammoType = ItemAmmo_1.default.create()
                .appendTo(this.primaryInfo);
            this.energy = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Energy)
                .appendTo(this.primaryInfo);
            this.energyValue = Component_44.default.create()
                .classes.add(ItemTooltipClasses.EnergyValue)
                .appendTo(this.energy);
            this.energy.text.add("Energy");
            this.weaponLevel = Component_44.default.create()
                .classes.add(ItemTooltipClasses.WeaponLevel, ItemTooltipClasses.ProgressBar)
                .append(this.weaponLevelLabel = Component_44.default.create()
                .classes.add(ItemTooltipClasses.WeaponLevelLabel))
                .append(this.weaponLevelProgress = Component_44.default.create()
                .classes.add(ItemTooltipClasses.WeaponLevelProgress))
                .appendTo(this.primaryInfo);
            this.statTracker = ItemStatTracker_1.default.create()
                .appendTo(this.primaryInfo);
            this.description = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Description)
                .appendTo(this.primaryInfo);
            this.perks = ItemTooltipPerks_1.default.create()
                .appendTo(this.primaryInfo);
            this.stats = ItemStat_1.default.Wrapper.create()
                .classes.add(ItemTooltipClasses.Stats)
                .appendTo(this.content);
            this.mods = ItemTooltipMods_1.default.create()
                .appendTo(this.content);
            this.notifications = ItemTooltipNotifications_1.default.create()
                .appendTo(this.content);
            this.deepsight = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Note, ItemTooltipClasses.Deepsight)
                .append(this.deepsightPatternLabel = Component_44.default.create()
                .classes.add(ItemTooltipClasses.DeepsightPatternLabel))
                .append(this.deepsightPatternNumber = Component_44.default.create()
                .classes.add(ItemTooltipClasses.DeepsightPatternNumber))
                .append(this.deepsightPatternOutOf = Component_44.default.create()
                .classes.add(ItemTooltipClasses.DeepsightPatternOutOf)
                .text.add(" / ")
                .append(this.deepsightPatternRequired = Component_44.default.create()
                .classes.add(ItemTooltipClasses.DeepsightPatternRequired))
                .append(this.deepsightPatternRequiredUnit = Component_44.default.create()
                .classes.add(ItemTooltipClasses.DeepsightPatternRequiredUnit)))
                .appendTo(this.content);
            this.enhance = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Note, ItemTooltipClasses.Enhance)
                .append(this.enhanceText = Component_44.default.create())
                .appendTo(this.content);
            this.wishlist = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Note, ItemTooltipClasses.Wishlist)
                .appendTo(this.content);
            this.note = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Note)
                .appendTo(this.content);
            this.fomo = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Note, ItemTooltipClasses.Fomo)
                .appendTo(this.content);
            this.hintEquipToCharacter = Hints_2.Hint.create([Hints_2.IInput.get("MouseLeft")])
                .appendTo(this.hints);
            this.hintUnequipFromCharacter = Hints_2.Hint.create([Hints_2.IInput.get("MouseLeft")])
                .tweak(hint => hint.label.text.set("Unequip"))
                .appendTo(this.hints);
            this.hintPullToCharacter = Hints_2.Hint.create([Hints_2.IInput.get("MouseLeft")])
                .appendTo(this.hints);
            this.hintVault = Hints_2.Hint.create([Hints_2.IInput.get("MouseLeft", "Shift")])
                .tweak(hint => hint.label.text.set("Vault"))
                .appendTo(this.hints);
            this.hintInspect = Hints_2.Hint.create([Hints_2.IInput.get("MouseRight")])
                .tweak(hint => hint.label.text.set("Details"))
                .appendTo(this.hints);
            this.extra.classes.add(ItemTooltipClasses.Extra);
            this.extra.content.classes.add(ItemTooltipClasses.Content);
            this.flavour = this.extra.title
                .classes.add(ItemTooltipClasses.Flavour);
            this.detailedMods = ItemTooltipMods_1.default.create()
                .setDetailed()
                .appendTo(this.extra.content);
            this.randomRollHeading = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Note, ItemTooltipClasses.NoteHeading)
                .appendTo(this.extra.content);
            this.randomMods = ItemTooltipMods_1.default.create()
                .appendTo(this.extra.content);
            this.source = ItemTooltipSource_1.default.create()
                .appendTo(this.extra.content);
            this.hintCollections = Hints_2.Hint.create([Hints_2.IInput.get("MouseRight", "Shift")])
                .tweak(hint => hint.label.text.set("Collections"))
                .appendTo(this.extra.hints);
            this.loadoutsWrapper = Component_44.default.create()
                .classes.add(ItemTooltipClasses.LoadoutsWrapper, ItemTooltipClasses.Note)
                .append(this.loadouts = Component_44.default.create()
                .classes.add(ItemTooltipClasses.Loadouts))
                .appendTo(this.extra.content);
            UiEventBus_3.default.subscribe("keydown", this.onGlobalKeydown);
            UiEventBus_3.default.subscribe("keyup", this.onGlobalKeyup);
        }
        onGlobalKeydown(event) {
            if (event.matches("Shift")) {
                this.hintInspect.label.text.set("Collections");
                this.awaitingShiftForLock = true;
            }
        }
        onGlobalKeyup(event) {
            if (event.matches("Shift")) {
                this.hintInspect.label.text.set("Details");
                if (!event.usedAnotherKeyDuring && this.awaitingShiftForLock) {
                    this.locked.classes.add(ItemTooltipClasses.Unlocked)
                        .classes.remove(Classes_8.Classes.Hidden);
                    void this.item?.setLocked(!this.item.isLocked())
                        .then(locked => this.locked.classes.remove(ItemTooltipClasses.Unlocked)
                        .classes.toggle(!locked, Classes_8.Classes.Hidden));
                }
                this.awaitingShiftForLock = false;
            }
        }
        async setItem(item, inventory) {
            this.item = item;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.$i = window.item = item;
            console.log(DisplayProperties_7.default.name(item.definition), item);
            const { DestinyItemTierTypeDefinition, DestinyDamageTypeDefinition, DestinyClassDefinition } = await Manifest_16.default.await();
            let tierHash = item.definition.inventory?.tierTypeHash;
            if (item.definition.itemCategoryHashes?.includes(3109687656 /* ItemCategoryHashes.Dummies */) || item.definition.itemType === 0 /* DestinyItemType.None */)
                tierHash = undefined;
            const rarity = await DestinyItemTierTypeDefinition.get(tierHash);
            const tierName = (tierHash === undefined ? "none" : item.definition.inventory?.tierTypeName ?? rarity?.displayProperties.name ?? "none")?.toLowerCase();
            this.classes.removeWhere(cls => cls.startsWith(ItemTooltipClasses.Rarity_))
                .classes.add(`${ItemTooltipClasses.Rarity_}${tierName}`)
                .classes.toggle(item.isMasterwork(), ItemTooltipClasses.Masterwork)
                .classes.toggle(!!item.definition.itemCategoryHashes?.includes(1378222069 /* ItemCategoryHashes.SeasonalArtifacts */), ItemTooltipClasses.Artifact);
            this.title.text.set(DisplayProperties_7.default.name(item.definition));
            this.subtitle.removeContents();
            this.subtitle.text.set(item.definition.itemTypeDisplayName ?? "Unknown");
            this.rarity.text.set(rarity && item.definition.inventory?.tierTypeName);
            this.locked.classes.toggle(!item.isLocked(), Classes_8.Classes.Hidden);
            const momentIcon = item.definition.iconWatermark;
            this.moment.classes.toggle(!momentIcon, Classes_8.Classes.Hidden)
                .classes.toggle(!!item?.definition.isFeaturedItem, ItemTooltipClasses.MomentWatermark_Featured);
            if (momentIcon)
                this.moment.style.set("--icon", `url("${momentIcon.startsWith("/") ? `https://www.bungie.net${momentIcon}` : momentIcon}")`);
            const tier = item.instance?.gearTier;
            this.tier.classes.toggle(!tier, Classes_8.Classes.Hidden);
            if (tier)
                this.tier.classes.removeWhere(cls => cls.startsWith(ItemTooltipClasses.MomentWatermarkTier_))
                    .classes.add(`${ItemTooltipClasses.MomentWatermarkTier_}${tier}`)
                    .removeContents()
                    .append(...Arrays_7.default.range(tier).map(() => Component_44.default.create()
                    .classes.add(ItemTooltipClasses.MomentWatermarkTierDot)));
            const primaryStat = item.getPower();
            const damageType = await DestinyDamageTypeDefinition.get(item.getDamageType());
            const energy = item.instance?.energy;
            const ammoType = item.definition.equippingBlock?.ammoType;
            this.primaryStat
                .classes.toggle(!primaryStat && damageType === undefined, Classes_8.Classes.Hidden)
                .classes.toggle(!!ammoType || !!energy, ItemTooltipClasses.PrimaryStatHasElementRight)
                .classes.removeWhere(cls => cls.startsWith("item-tooltip-energy-type-"));
            this.primaryStatValue
                .text.set(`${primaryStat ?? item.owner?.power ?? "0"}`)
                .classes.toggle(damageType !== undefined, ItemTooltipClasses.PrimaryStatDamage);
            this.primaryStatDamageIcon.classes.toggle(damageType === undefined, Classes_8.Classes.Hidden);
            if (damageType !== undefined) {
                const damageTypeName = (damageType?.displayProperties.name ?? "Unknown").toLowerCase();
                this.primaryStatValue
                    .classes.add(`item-tooltip-energy-type-${damageTypeName}`)
                    .style.set("--colour", ElementTypes_1.default.getColour(damageTypeName));
                this.primaryStatDamageIcon.attributes.set("src", DisplayProperties_7.default.icon(damageType, false));
            }
            this.primaryStatLabel
                .text.set(this.item.instance?.primaryStat?.statHash === 1501155019 /* StatHashes.Speed */ ? "Speed" : "Power")
                .classes.toggle(!!item.definition.equippingBlock?.ammoType || energy !== undefined, Classes_8.Classes.Hidden);
            this.ammoType.setItem(item);
            this.energy.classes.toggle(energy === undefined, Classes_8.Classes.Hidden);
            if (energy !== undefined)
                this.energyValue.text.set(`${energy.energyCapacity}`);
            this.weaponLevel.classes.toggle(!item.shaped && (!item.catalyst || item.isMasterwork()), Classes_8.Classes.Hidden)
                .classes.toggle(!item.shaped && !!item.catalyst, ItemTooltipClasses.Catalyst);
            if (item.shaped) {
                const progressObjective = item.shaped.progress?.progress;
                const progress = (progressObjective?.progress ?? 0) / (progressObjective?.completionValue ?? 1);
                this.weaponLevel.style.set("--progress", `${progress}`);
                this.weaponLevelLabel.text.set(`Weapon Lv. ${item.shaped.level?.progress.progress ?? 0}`);
                this.weaponLevelProgress.text.set(`${Math.floor(progress * 100)}%`);
            }
            else if (item.catalyst && (!item.catalyst.complete || !item.isMasterwork())) {
                const progress = (item.catalyst.progress ?? 0) / (item.catalyst.completionValue ?? 1);
                this.weaponLevel.style.set("--progress", `${progress}`);
                const obscured = item.catalyst.state.state & 8 /* DestinyRecordState.Obscured */;
                const needsInsertion = item.catalyst.complete && !item.isMasterwork();
                this.weaponLevelLabel.text.set(needsInsertion ? "Insert the Catalyst" : obscured ? "Catalyst Not Acquired" : item.catalyst.progressDescription);
                this.weaponLevelProgress.text.set(obscured || needsInsertion ? "" : `${Math.floor(progress * 100)}%`);
            }
            const description = DisplayProperties_7.default.description(item.definition);
            this.description.classes.toggle(!description, Classes_8.Classes.Hidden)
                .removeContents()
                .append(Component_44.default.create()
                .tweak(DisplayProperties_7.default.applyDescription, description));
            this.statTracker.setItem(item);
            this.perks.setItem(item);
            this.stats.setItem(item);
            this.mods
                .setShaped(item.bucket.isCollections())
                .setItem(item);
            this.notifications.setItem(item);
            const showPattern = item.deepsight?.pattern?.record && !item.shaped;
            this.deepsight.classes.toggle(!showPattern, Classes_8.Classes.Hidden);
            if (showPattern) {
                const complete = !!item.deepsight?.pattern?.progress?.complete;
                this.deepsightPatternLabel
                    .text.set(inventory?.isCrafted(item.definition.hash) ? "You have already shaped this weapon."
                    : complete ? "This weapon's pattern is unlocked."
                        : item.bucket.isCollections() ? "This weapon can be shaped."
                            : item.deepsight?.resonance ? "This [b]Pattern[/b] can be extracted."
                                : item.deepsight?.activation ? "This [b]Pattern[/b] can be [b]Activated[/b]."
                                    : "You have extracted this pattern.");
                const progress = !!item.deepsight?.pattern?.progress;
                this.deepsightPatternNumber.classes.toggle(!progress || complete, Classes_8.Classes.Hidden);
                this.deepsightPatternOutOf.classes.toggle(!progress || complete, Classes_8.Classes.Hidden);
                this.deepsightPatternNumber.text.set(`${item.deepsight.pattern.progress?.progress ?? 0}`);
                this.deepsightPatternRequired.text.set(`${item.deepsight.pattern.progress?.completionValue}`);
                this.deepsightPatternRequiredUnit.classes.toggle(!progress || complete, Classes_8.Classes.Hidden);
                this.deepsightPatternRequiredUnit.text.set("extractions");
            }
            const wishlists = !item.instance || item.shaped ? undefined : await item.getMatchingWishlists();
            this.wishlist.classes.toggle(wishlists === undefined, Classes_8.Classes.Hidden);
            if (wishlists !== undefined)
                this.wishlist.classes.toggle(wishlists && wishlists.length > 0, ItemTooltipClasses.Wishlisted)
                    .text.set(!wishlists ? "All rolls of this item are marked as junk."
                    : wishlists.length === 0 ? "This item does not match a wishlisted roll."
                        : wishlists.length === 1 && wishlists[0].name === "Wishlist" ? "This item matches your wishlist."
                            : `This item matches wishlist${wishlists.length > 1 ? "s" : ""}: ${wishlists.map(list => list.name).join(", ")}`);
            const fomoState = item.isFomo();
            this.fomo.classes.toggle(!fomoState, Classes_8.Classes.Hidden)
                .text.set(fomoState === Item_3.ItemFomoState.TemporaryAvailability ? "This item is currently available."
                : "This item's activity is currently repeatable.");
            const enhancementSocket = true
                && item.getSocket("Masterwork/Enhancement")
                && (!item.shaped || item.deepsight?.pattern?.recipe);
            this.enhance.classes.toggle(!enhancementSocket, Classes_8.Classes.Hidden);
            this.enhanceText.text.set(_
                || (item.shaped && item.deepsight?.pattern?.recipe && "This weapon can be modified at the [b]Relic[/b].")
                || (!item.shaped && "This weapon can be [b]Enhanced[/b].")
                || undefined);
            this.weaponLevel.classes.toggle(!!enhancementSocket, ItemTooltipClasses.WeaponLevelEnhanced);
            this.note.classes.add(Classes_8.Classes.Hidden);
            const shaped = item.bucket.isCollections() && item.deepsight?.pattern?.progress?.complete && !inventory?.isCrafted(item.definition.hash);
            if (item.isNotAcquired() && !shaped && !item.deepsight?.pattern?.progress?.progress) {
                this.note.classes.remove(Classes_8.Classes.Hidden);
                this.note.text.set("This item has has not been acquired.");
            }
            const owner = item.owner;
            const cls = !owner ? undefined : await DestinyClassDefinition.get(owner.classHash);
            const className = cls?.displayProperties.name ?? "Unknown";
            this.hintPullToCharacter.label.text.set(`Pull to ${className}`);
            this.hintEquipToCharacter.label.text.set(`Equip to ${className}`);
            const inEngramBucket = item.reference.bucketHash === 375726501 /* InventoryBucketHashes.Engrams */;
            this.hintVault.classes.toggle(item.bucket.isVault() || inEngramBucket || item.bucket.isCollections() || item.bucket.is(1469714392 /* InventoryBucketHashes.Consumables */) || item.bucket.is(3313201758 /* InventoryBucketHashes.Modifications */), Classes_8.Classes.Hidden);
            this.hintPullToCharacter.classes.toggle(item.bucket.isCharacter() || !!item.equipped || inEngramBucket || item.bucket.isCollections() || item.bucket.is(1469714392 /* InventoryBucketHashes.Consumables */) || item.bucket.is(3313201758 /* InventoryBucketHashes.Modifications */), Classes_8.Classes.Hidden);
            this.hintEquipToCharacter.classes.toggle(!item.bucket.isCharacter() || !!item.equipped, Classes_8.Classes.Hidden);
            this.hintUnequipFromCharacter.classes.toggle(!item.bucket.isCharacter() || !item.equipped, Classes_8.Classes.Hidden);
            const flavour = !!item.definition.flavorText;
            this.flavour.classes.toggle(!flavour, Classes_8.Classes.Hidden);
            this.flavour.text.set(item.definition.flavorText);
            this.randomRollHeading.classes.add(Classes_8.Classes.Hidden);
            this.randomMods.classes.add(Classes_8.Classes.Hidden);
            if (item.bucket.isCollections()) {
                this.detailedMods.setItem(item);
            }
            else {
                this.detailedMods.setItem(item);
                if (item.isWeapon() && item.collections?.hasRandomRolls()) {
                    this.randomRollHeading.classes.remove(Classes_8.Classes.Hidden)
                        .text.set(item.shaped ? "This item can be shaped with the following perks:"
                        : "This item can roll the following perks:");
                    this.randomMods.classes.remove(Classes_8.Classes.Hidden)
                        .setShaped(!!item.shaped)
                        .setItem(item.collections, "!Intrinsic");
                }
            }
            const source = this.source.setItem(item);
            this.source.classes.toggle(!source, Classes_8.Classes.Hidden);
            const loadouts = this.item.getLoadouts();
            this.loadoutsWrapper.classes.toggle(!loadouts.length, Classes_8.Classes.Hidden);
            if (loadouts.length)
                this.loadouts.removeContents()
                    .append(...loadouts.map((loadout, i) => LoadoutComponent_1.default.create([])
                    .classes.add(ItemTooltipClasses.Loadout)
                    .set(i, loadout)));
            this.extra.classes.toggle(!flavour && !this.detailedMods.hasContents() && !source, Classes_8.Classes.Hidden);
        }
    }
    __decorate([
        Bound_17.default
    ], ItemTooltip.prototype, "onGlobalKeydown", null);
    __decorate([
        Bound_17.default
    ], ItemTooltip.prototype, "onGlobalKeyup", null);
    exports.default = TooltipManager_2.default.create(tooltip => tooltip
        .make(ItemTooltip));
});
define("ui/utility/ExtraInfoManager", ["require", "exports", "ui/utility/UiEventBus", "utility/Store"], function (require, exports, UiEventBus_4, Store_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ExtraInfoManager {
        constructor() {
            this.enablersMain = new Set();
            this.enablers = new Map();
            UiEventBus_4.default.subscribe("keydown", event => {
                if (event.use("e"))
                    if (Store_11.default.items.settingsToggleExtra)
                        this.toggleMain("KEY");
                    else
                        this.enableMain("KEY");
            });
            UiEventBus_4.default.subscribe("keyup", event => {
                if (!Store_11.default.items.settingsToggleExtra && event.use("e"))
                    this.disableMain("KEY");
            });
            if (Store_11.default.items.settingsAlwaysShowExtra)
                document.documentElement.classList.add("show-extra-info");
            Store_11.default.event.subscribe("setSettingsAlwaysShowExtra", ({ value }) => this.update());
        }
        enableMain(id) {
            this.enablersMain.add(id);
            this.update();
            document.documentElement.classList.toggle("show-extra-info", !Store_11.default.items.settingsAlwaysShowExtra);
        }
        disableMain(id) {
            this.enablersMain.delete(id);
            if (!this.enablersMain.size)
                this.update();
        }
        toggleMain(id, newState = !this.enablersMain.has(id)) {
            if (newState)
                this.enableMain(id);
            else
                this.disableMain(id);
        }
        shouldShowExtraInfo() {
            return !!Store_11.default.items.settingsAlwaysShowExtra === !this.enablersMain.size;
        }
        update() {
            const extraInfo = this.shouldShowExtraInfo();
            document.documentElement.classList.toggle("show-extra-info", extraInfo);
            document.documentElement.classList.toggle("no-extra-info", !extraInfo);
            for (const [id, enablers] of this.enablers.entries())
                this.updateSubExtraInfo(id, enablers);
        }
        updateSubExtraInfo(id, enablers = this.enablers.get(id)) {
            if (!enablers)
                return;
            const subExtraInfo = this.shouldShowExtraInfo() || !!enablers.size;
            document.documentElement.classList.toggle(`show-${id}-extra-info`, subExtraInfo);
            document.documentElement.classList.toggle(`no-${id}-extra-info`, !subExtraInfo);
        }
        register(id) {
            this.enablers.set(id, new Set());
            this.updateSubExtraInfo(id);
        }
        enable(id, reason = "n/a") {
            let enablers = this.enablers.get(id);
            if (!enablers)
                this.enablers.set(id, enablers = new Set());
            const size = enablers.size;
            enablers.add(reason);
            if (size)
                return; // already had enabler
            this.updateSubExtraInfo(id, enablers);
        }
        disable(id, reason = "n/a") {
            const enablers = this.enablers.get(id);
            if (!enablers?.size)
                return;
            enablers.delete(reason);
            if (!enablers.size)
                this.updateSubExtraInfo(id, enablers);
        }
        toggle(id, reason = "n/a", newState = !this.enablers.get(id)?.has(reason)) {
            if (newState)
                this.enable(id, reason);
            else
                this.disable(id, reason);
        }
    }
    exports.default = new ExtraInfoManager;
});
define("ui/destiny/component/ItemComponent", ["require", "exports", "model/models/Manifest", "ui/component/Button", "ui/component/Component", "ui/component/Loadable", "ui/component/LoadedIcon", "ui/destiny/component/IItemComponent", "ui/destiny/component/Slot", "ui/destiny/sort/Sort", "ui/destiny/sort/sorts/SortQuantity", "ui/destiny/tooltip/ItemTooltip", "ui/utility/Classes", "ui/utility/DisplayProperties", "ui/utility/ExtraInfoManager", "utility/Async", "utility/Store", "utility/decorator/Bound"], function (require, exports, Manifest_17, Button_11, Component_45, Loadable_3, LoadedIcon_3, IItemComponent_2, Slot_1, Sort_26, SortQuantity_2, ItemTooltip_1, Classes_9, DisplayProperties_8, ExtraInfoManager_1, Async_5, Store_12, Bound_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ItemComponent extends Button_11.default {
        static showExtra(id) {
            ExtraInfoManager_1.default.enable("item", id);
        }
        static hideExtra(id) {
            ExtraInfoManager_1.default.disable("item", id);
        }
        static toggleExtra(id, newState) {
            ExtraInfoManager_1.default.toggle("item", id, newState);
        }
        async onMake(...args) {
            super.onMake(...args);
            const [item, inventory] = args;
            this.tooltipPadding = 0;
            this.classes.add(IItemComponent_2.ItemClasses.Main);
            this.inventory = inventory;
            this.event.subscribe("click", this.onClick);
            this.event.subscribe("contextmenu", this.onContextMenu);
            if (item) {
                const done = this.setItem(item);
                await done;
            }
        }
        update(event) {
            if (!document.contains(this.element)) {
                this.item?.event.unsubscribe("update", this.update);
                this.item?.event.unsubscribe("loadStart", this.loadStart);
                this.item?.event.unsubscribe("loadEnd", this.loadEnd);
                return;
            }
            void (async () => {
                while (this.lastUpdatePromise)
                    await this.lastUpdatePromise;
                const updatePromise = this.lastUpdatePromise = this.setItem(event.item);
                await this.lastUpdatePromise;
                if (this.lastUpdatePromise === updatePromise)
                    delete this.lastUpdatePromise;
            })();
        }
        loadStart() {
            this.loadingSpinny?.classes.remove(Classes_9.Classes.Hidden);
        }
        loadEnd() {
            this.loadingSpinny?.classes.add(Classes_9.Classes.Hidden);
        }
        async setItem(item, inventory) {
            this.inventory = inventory ?? this.inventory;
            if (item !== this.item) {
                this.item?.event.unsubscribe("update", this.update);
                this.item?.event.unsubscribe("loadStart", this.loadStart);
                this.item?.event.unsubscribe("loadEnd", this.loadEnd);
                item?.event.subscribe("update", this.update);
                item?.event.subscribe("loadStart", this.loadStart);
                item?.event.subscribe("loadEnd", this.loadEnd);
                this.item = item;
            }
            while (this.settingItem)
                await this.settingItem;
            this.settingItem = this.renderItem(item);
            await this.settingItem;
            delete this.settingItem;
        }
        getIcon(index, pathSupplier) {
            return this.icon ??= LoadedIcon_3.default.create([pathSupplier?.()])
                .classes.add(IItemComponent_2.ItemClasses.Icon)
                .tweak(icon => this.initialiseIcon(icon))
                .indexInto(this, index);
        }
        async renderItem(item) {
            // note  this tooltip def is also in DraggableItemComponent
            this.setTooltip(ItemTooltip_1.default, {
                initialise: tooltip => item && tooltip.setPadding(this.tooltipPadding)
                    .setItem(item, this.inventory),
                differs: tooltip => tooltip.item?.reference.itemInstanceId !== item?.reference.itemInstanceId,
            });
            this.classes.toggle(!!item?.isMasterwork(), IItemComponent_2.ItemClasses.IsMasterwork);
            this.classes.toggle(!!item?.definition.isFeaturedItem, IItemComponent_2.ItemClasses._Featured);
            this.extra ??= Component_45.default.create("span")
                .classes.add(IItemComponent_2.ItemClasses.Extra);
            const borderless = item?.definition.itemType === 8 /* DestinyItemType.Engram */
                || item?.definition.itemType === 25 /* DestinyItemType.Package */
                || item?.definition.itemTypeDisplayName == "Umbral Engram";
            this.classes.toggle(borderless, IItemComponent_2.ItemClasses.Borderless);
            const isContainer = item?.definition.uiItemDisplayStyle === "ui_display_style_set_container";
            this.classes.toggle(isContainer, IItemComponent_2.ItemClasses._Container);
            Slot_1.default.setWide(this.parent(`.${Slot_1.SlotClasses.Main}`), isContainer);
            const { DestinyItemTierTypeDefinition } = await Manifest_17.default.await();
            const tier = await DestinyItemTierTypeDefinition.get(item?.definition.inventory?.tierTypeHash);
            this.classes.removeWhere(cls => cls.startsWith("item-tier-"))
                .classes.add(`item-tier-${(item?.definition.inventory?.tierTypeName ?? tier?.displayProperties?.name ?? "Common")?.toLowerCase()}`);
            const ornament = item?.getOrnament();
            const hasUniversalOrnament = !!ornament
                && tier?.displayProperties.name === "Legendary"
                && !!item?.definition.traitIds?.some(id => id === "item_type.armor" || id.startsWith("item.armor."));
            let index = 0;
            this.getIcon(index++, () => DisplayProperties_8.default.icon(ornament?.definition, false) ?? DisplayProperties_8.default.icon(item?.definition, false))
                .classes.toggle(hasUniversalOrnament, IItemComponent_2.ItemClasses.UniversalArmourOrnament);
            const classified = item?.definition.displayProperties.icon === "/img/misc/missing_icon_d2.png";
            this.classes.toggle(classified, IItemComponent_2.ItemClasses._Classified);
            if (classified)
                (this.classified ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.Classified)
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            else
                this.classified?.classes.add(Classes_9.Classes.Hidden);
            index++;
            const wishlisted = !item?.instance || item.shaped ? undefined : await item.isWishlisted();
            const displayWishlistedBorder = wishlisted && Store_12.default.items.settingsDisplayWishlistedHighlights;
            const displayJunkBorder = wishlisted === false && !Store_12.default.items.settingsDisableDisplayNonWishlistedHighlights;
            const canShape = item?.bucket.isCollections() && item.deepsight?.pattern?.progress?.complete && !this.inventory?.isCrafted(item.definition.hash);
            const shaped = item?.shaped || canShape;
            this.classes.toggle(!!item?.isNotAcquired() && !shaped && !item.deepsight?.pattern?.progress?.progress, IItemComponent_2.ItemClasses.NotAcquired);
            const shouldShowShapedOrEnhancedOrAdeptIcon = shaped
                ? !item?.isMasterwork()
                : item?.bucket.isCollections()
                    ? item?.isAdept()
                    : item?.canEnhance() && !displayJunkBorder;
            if (shouldShowShapedOrEnhancedOrAdeptIcon)
                (this.iconShaped ??= Component_45.default.create("span")
                    .classes.toggle(!!shaped, IItemComponent_2.ItemClasses.Shaped)
                    .classes.toggle(!!item?.canEnhance(), IItemComponent_2.ItemClasses.CanEnhance)
                    .classes.toggle(!!item?.isAdept(), IItemComponent_2.ItemClasses.Adept)
                    .append(Component_45.default.create("span"))
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            else
                this.iconShaped?.classes.add(Classes_9.Classes.Hidden);
            index++;
            let watermark;
            if (item?.isSunset())
                watermark = item?.definition.iconWatermarkShelved ?? item?.definition.iconWatermark;
            else
                watermark = item?.definition.iconWatermark ?? item?.definition.iconWatermarkShelved;
            if (watermark)
                (this.momentWatermark ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.MomentWatermark)
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden)
                    .classes.toggle(!!item?.definition.isFeaturedItem, IItemComponent_2.ItemClasses.MomentWatermark_Featured)
                    // .classes.toggle(!watermark && !!item?.moment?.displayProperties.icon, ItemClasses.MomentWatermarkCustom)
                    .style.set("--watermark", watermark && `url("https://www.bungie.net${watermark}")`);
            // .style.set("--icon", item?.moment?.displayProperties.icon && `url("${item.moment.displayProperties.icon}")`);
            else
                this.momentWatermark?.classes.add(Classes_9.Classes.Hidden);
            index++;
            if ((item?.isLocked() || item?.isChangingLockState()))
                (this.iconLock ??= Component_45.default.create("span")
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden)
                    .classes.toggle(item.isChangingLockState(), IItemComponent_2.ItemClasses.Unlocked)
                    .classes.toggle(!item.isChangingLockState(), IItemComponent_2.ItemClasses.Locked)
                    .classes.toggle(!Store_12.default.items.settingsDisplayLocksOnItems, Classes_9.Classes.ShowIfExtraInfo);
            else
                this.iconLock?.classes.add(Classes_9.Classes.Hidden);
            index++;
            this.deepsight?.classes.add(Classes_9.Classes.Hidden);
            this.deepsightHasPattern?.classes.add(Classes_9.Classes.Hidden);
            this.deepsightPattern?.classes.add(Classes_9.Classes.Hidden);
            if (!shaped) {
                if (item?.hasDeepsight())
                    (this.deepsight ??= Component_45.default.create("span")
                        .classes.add(IItemComponent_2.ItemClasses.Deepsight)
                        .indexInto(this, index))
                        .classes.remove(Classes_9.Classes.Hidden);
                if (item?.deepsight?.pattern?.record) {
                    (this.deepsightHasPattern ??= Component_45.default.create("span")
                        .classes.add(IItemComponent_2.ItemClasses.DeepsightHasPattern)
                        .indexInto(this, index + 1))
                        .classes.remove(Classes_9.Classes.Hidden);
                    if (!displayJunkBorder)
                        (this.deepsightPattern ??= Component_45.default.create("span")
                            .classes.add(IItemComponent_2.ItemClasses.DeepsightPattern)
                            .indexInto(this, index + 2))
                            .classes.remove(Classes_9.Classes.Hidden)
                            .classes.toggle(!!item.deepsight.pattern.progress?.complete, IItemComponent_2.ItemClasses.DeepsightPatternUnlocked);
                }
            }
            index += 3;
            this.loadouted?.classes.add(Classes_9.Classes.Hidden);
            const isLoadouted = !!this.item?.getLoadouts().length;
            this.classes.toggle(isLoadouted, IItemComponent_2.ItemClasses._Loadouted);
            if (isLoadouted)
                (this.loadouted ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.LoadoutedBookmark)
                    .append(Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.LoadoutedBookmark1))
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            index++;
            this.artifice?.classes.add(Classes_9.Classes.Hidden);
            if (item?.isArtifice())
                (this.artifice ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.Artifice)
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            index++;
            this.masterwork?.classes.add(Classes_9.Classes.Hidden);
            this.wishlist?.classes.add(Classes_9.Classes.Hidden);
            const isArtifact = !!item?.definition.itemCategoryHashes?.includes(1378222069 /* ItemCategoryHashes.SeasonalArtifacts */);
            if (item?.isMasterwork())
                (this.masterwork ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.Masterwork)
                    .append(Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.MasterworkSpinny))
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden)
                    .classes.toggle(isArtifact, IItemComponent_2.ItemClasses.Artifact)
                    .classes.toggle(displayJunkBorder, IItemComponent_2.ItemClasses.MasterworkShiftedDueToJunkBorder);
            else if (displayWishlistedBorder)
                (this.wishlist ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.Wishlist)
                    .append(item?.canEnhance() ? undefined : Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.WishlistIcon))
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            index++;
            if (displayJunkBorder)
                (this.junk ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.WishlistNoMatch)
                    .append(Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.WishlistNoMatchIcon))
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            else
                this.junk?.classes.add(Classes_9.Classes.Hidden);
            index++;
            if (item?.isFomo() && !item.deepsight?.pattern?.progress?.complete)
                (this.fomo ??= Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.Fomo)
                    .append(Component_45.default.create("span")
                    .classes.add(IItemComponent_2.ItemClasses.FomoIcon))
                    .indexInto(this, index))
                    .classes.remove(Classes_9.Classes.Hidden);
            else
                this.fomo?.classes.add(Classes_9.Classes.Hidden);
            index++;
            const hasThickBorder = false
                || !!item?.isMasterwork()
                || displayWishlistedBorder
                || displayJunkBorder
                || !!item?.isFomo()
                || (!shaped && !!item?.hasDeepsight());
            this.classes.toggle(hasThickBorder, IItemComponent_2.ItemClasses._HasThickBorder);
            void Async_5.default.debounce(this.rerenderExtra);
            this.extra.indexInto(this, index);
            index++;
            (this.loadingSpinny ??= Component_45.default.create("span")
                .classes.add(Loadable_3.default.Classes.LoadingSpinny, IItemComponent_2.ItemClasses.Loading)
                .append(Component_45.default.create("span").classes.add(Loadable_3.default.Classes.LoadingSpinny1))
                .append(Component_45.default.create("span").classes.add(Loadable_3.default.Classes.LoadingSpinny2))
                .indexInto(this, index))
                .classes.toggle(!item?.transferring, Classes_9.Classes.Hidden);
        }
        initialiseIcon(icon) { }
        setSortedBy(sorter) {
            this.sorter = sorter && new WeakRef(sorter);
            this.event.emit("setSorter");
            sorter?.event.until(this.event.waitFor("setSorter"), event => event
                .subscribe("update", () => Async_5.default.debounce(this.rerenderExtra)));
            void Async_5.default.debounce(this.rerenderExtra);
            return this;
        }
        setTooltipPadding(padding) {
            this.tooltipPadding = padding;
            return this;
        }
        setDisableInteractions() {
            this.disableInteractions = true;
            return this;
        }
        async rerenderExtra() {
            this.extra?.removeContents();
            if (!this.item || !this.extra)
                return;
            const sorts = this.sorter?.deref()?.get()?.slice() ?? [];
            if (this.item.reference.quantity > 1 && !sorts.includes(SortQuantity_2.default))
                sorts.push(SortQuantity_2.default);
            let extra = 0;
            let encounteredQuantityOrPowerState = 0;
            for (const sort of sorts) {
                if (!sort.render)
                    continue;
                const rendered = await sort.render(this.item);
                if (!rendered)
                    continue;
                if (encounteredQuantityOrPowerState || sort.id === Sort_26.default.Quantity || sort.id === Sort_26.default.Power)
                    encounteredQuantityOrPowerState++;
                rendered.classes.add(IItemComponent_2.ItemClasses.ExtraInfo)
                    .appendTo(this.extra);
                if (++extra === 3)
                    break;
            }
            const empty = extra === 0 || (this.item.definition.inventory?.bucketTypeHash === 375726501 /* InventoryBucketHashes.Engrams */ && extra === 1);
            this.extra.classes.toggle(empty, IItemComponent_2.ItemClasses.Extra_Empty);
            this.extra.classes.toggle(!empty, IItemComponent_2.ItemClasses.Extra_NonEmpty);
            this.extra.classes.toggle(encounteredQuantityOrPowerState === 1 && extra < 3, IItemComponent_2.ItemClasses.ExtraNoneAfterQuantityOrPower);
        }
        async onClick(event) {
            if (!this.item)
                return;
            const character = this.item.owner?.characterId;
            if (!character)
                return;
            if (Component_45.default.window.width <= 800)
                return viewManager.showItemTooltip(this.item);
            if (this.disableInteractions)
                return;
            if (!event.use("MouseLeft"))
                return;
            if (event.shiftKey)
                // update this item component's bucket so future clicks transfer to the right place
                await this.item.transferToggleVaulted(character);
            else {
                if (!this.item.bucket.isCharacter())
                    await this.item.transferToCharacter(character);
                else if (this.item.equipped)
                    await this.item.unequip();
                else
                    await this.item.equip(character);
            }
        }
        onContextMenu(event) {
            if (!this.item)
                return;
            if (Component_45.default.window.width <= 800)
                return;
            if (this.disableInteractions)
                return;
            if (!event.use("MouseRight"))
                return;
            event.preventDefault();
            event.stopPropagation();
            if (event.shiftKey)
                viewManager.showCollections(this.item);
            else
                viewManager.showItem(this.item);
        }
    }
    (() => {
        ExtraInfoManager_1.default.register("item");
    })();
    ItemComponent.defaultType = "span";
    exports.default = ItemComponent;
    __decorate([
        Bound_18.default
    ], ItemComponent.prototype, "update", null);
    __decorate([
        Bound_18.default
    ], ItemComponent.prototype, "loadStart", null);
    __decorate([
        Bound_18.default
    ], ItemComponent.prototype, "loadEnd", null);
    __decorate([
        Bound_18.default
    ], ItemComponent.prototype, "rerenderExtra", null);
    __decorate([
        Bound_18.default
    ], ItemComponent.prototype, "onClick", null);
    __decorate([
        Bound_18.default
    ], ItemComponent.prototype, "onContextMenu", null);
});
define("ui/destiny/playeroverview/LoadoutsComponent", ["require", "exports", "ui/component/Component", "ui/destiny/playeroverview/LoadoutComponent", "ui/utility/Classes"], function (require, exports, Component_46, LoadoutComponent_2, Classes_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoadoutsClasses = void 0;
    var LoadoutsClasses;
    (function (LoadoutsClasses) {
        LoadoutsClasses["Main"] = "loadouts";
    })(LoadoutsClasses || (exports.LoadoutsClasses = LoadoutsClasses = {}));
    class LoadoutsComponent extends Component_46.default {
        onMake() {
            this.classes.add(LoadoutsClasses.Main, Classes_10.Classes.Hidden);
            this.loadouts = [];
            for (let i = 0; i < 10; i++)
                this.loadouts.push(LoadoutComponent_2.default.create([])
                    .appendTo(this));
        }
        set(inventory, character) {
            for (let i = 0; i < 10; i++) {
                const loadout = character.loadouts[i];
                this.loadouts[i].set(i, loadout);
            }
        }
    }
    exports.default = LoadoutsComponent;
});
define("ui/destiny/playeroverview/StatsOverview", ["require", "exports", "model/models/enum/DamageTypes", "ui/destiny/tooltip/item/ItemStat", "ui/destiny/utility/Stat", "utility/maths/Maths"], function (require, exports, DamageTypes_3, ItemStat_2, Stat_7, Maths_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsOverviewClasses = void 0;
    var StatsOverviewClasses;
    (function (StatsOverviewClasses) {
        StatsOverviewClasses["Main"] = "stats-overview";
        StatsOverviewClasses["IsDamageType"] = "stats-overview--damage-type";
        StatsOverviewClasses["Wrapper"] = "stats-overview-wrapper";
    })(StatsOverviewClasses || (exports.StatsOverviewClasses = StatsOverviewClasses = {}));
    class StatsOverview extends ItemStat_2.default.Wrapper {
        onMake() {
            super.onMake();
            this.classes.add(StatsOverviewClasses.Main);
        }
        set(character, buckets) {
            const equippedItems = buckets.map(bucket => bucket.equippedItem)
                .filter(item => item?.isArmour() || item?.definition.itemCategoryHashes?.includes(50 /* ItemCategoryHashes.Subclasses */));
            const subclass = equippedItems.find(item => item?.definition.itemCategoryHashes?.includes(50 /* ItemCategoryHashes.Subclasses */));
            this.classes.removeWhere(cls => cls.startsWith(StatsOverviewClasses.IsDamageType))
                .classes.add(`${StatsOverviewClasses.IsDamageType}-${DamageTypes_3.default.nameOf(subclass?.getDamageType())}`);
            const displays = [];
            for (const group of Stat_7.ARMOUR_STAT_GROUPS) {
                for (const hash of group) {
                    let statInstance;
                    const statValues = {
                        value: 0,
                        mod: 0,
                        intrinsic: 0,
                        masterwork: 0,
                        roll: 0,
                        subclass: 0,
                        charge: 0,
                    };
                    for (const item of equippedItems) {
                        const stat = item?.stats?.values[hash];
                        let value = stat?.value ?? 0;
                        statValues.mod += stat?.mod ?? 0;
                        statValues.intrinsic += stat?.intrinsic ?? 0;
                        statValues.masterwork += stat?.masterwork ?? 0;
                        statValues.roll += stat?.roll ?? 0;
                        statValues.charge += stat?.charge ?? 0;
                        statInstance ??= stat;
                        if (item?.definition.itemCategoryHashes?.includes(50 /* ItemCategoryHashes.Subclasses */)) {
                            value = 0;
                            statValues.subclass += item.getSocketedPlugs("Subclass/Fragment")
                                .map(fragment => {
                                // const isClassStat = fragment.getCategorisationAs(DeepsightPlugCategory.Subclass)?.affectsClassStat;
                                // if (isClassStat && character.stat?.hash !== hash)
                                // 	return 0;
                                return fragment.definition?.investmentStats?.find(stat => stat.statTypeHash === hash)?.value ?? 0;
                            })
                                .splat(Maths_7.default.sum);
                        }
                        statValues.value += value;
                    }
                    if (!statInstance?.definition) {
                        console.warn(`No equipped items have stat ${hash}`);
                        continue;
                    }
                    statValues.value += statValues.subclass;
                    displays.push({
                        ...statInstance,
                        ...statValues,
                        override: {
                            max: 100,
                            group: undefined,
                            plus: undefined,
                            chunked: true,
                        },
                    });
                }
            }
            displays.push({
                hash: ItemStat_2.CustomStat.Tiers,
                order: 1002,
                name: "Tiers",
                calculate: (stat, stats, item) => {
                    const armourStats = Stat_7.ARMOUR_STAT_GROUPS.flat();
                    stats = stats.filter(stat => armourStats.includes(stat.hash));
                    const tiers = stats.map(stat => Math.floor((stat.value ?? 0) / 10)).splat(Maths_7.default.sum);
                    const chargeTiers = stats.map(stat => Math.floor((stat.charge ?? 0) / 10)).splat(Maths_7.default.sum);
                    return {
                        value: tiers + chargeTiers,
                        intrinsic: tiers,
                        charge: chargeTiers,
                    };
                },
            });
            this.setStats(displays);
        }
    }
    exports.default = StatsOverview;
});
define("ui/destiny/tooltip/ItemSubclassTooltip", ["require", "exports", "model/models/enum/DamageTypes", "ui/component/Component", "ui/component/LoadedIcon", "ui/utility/Classes", "ui/utility/DisplayProperties", "ui/utility/TooltipManager"], function (require, exports, DamageTypes_4, Component_47, LoadedIcon_4, Classes_11, DisplayProperties_9, TooltipManager_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ItemSubclassTooltipClasses;
    (function (ItemSubclassTooltipClasses) {
        ItemSubclassTooltipClasses["Main"] = "item-subclass-tooltip";
        ItemSubclassTooltipClasses["Header"] = "item-subclass-tooltip-header";
        ItemSubclassTooltipClasses["DamageTypeIcon"] = "item-subclass-tooltip-damage-type-icon";
        ItemSubclassTooltipClasses["IsDamageType"] = "item-subclass-tooltip--damage-type";
        ItemSubclassTooltipClasses["Title"] = "item-subclass-tooltip-title";
        ItemSubclassTooltipClasses["Subtitle"] = "item-subclass-tooltip-subtitle";
        ItemSubclassTooltipClasses["Content"] = "item-subclass-tooltip-content";
        ItemSubclassTooltipClasses["Super"] = "item-subclass-tooltip-super";
        ItemSubclassTooltipClasses["SuperImage"] = "item-subclass-tooltip-super-image";
        ItemSubclassTooltipClasses["SuperName"] = "item-subclass-tooltip-super-name";
        ItemSubclassTooltipClasses["Flavour"] = "item-subclass-tooltip-flavour";
    })(ItemSubclassTooltipClasses || (ItemSubclassTooltipClasses = {}));
    class ItemSubclassTooltip extends TooltipManager_3.Tooltip {
        onMake() {
            this.classes.add(ItemSubclassTooltipClasses.Main);
            this.header.classes.add(ItemSubclassTooltipClasses.Header);
            this.title.classes.add(ItemSubclassTooltipClasses.Title);
            this.subtitle.classes.add(ItemSubclassTooltipClasses.Subtitle);
            this.content.classes.add(ItemSubclassTooltipClasses.Content);
            this.damageTypeIcon = Component_47.default.create()
                .classes.add(ItemSubclassTooltipClasses.DamageTypeIcon)
                .prependTo(this.header);
            this.superWrapper = Component_47.default.create()
                .classes.add(ItemSubclassTooltipClasses.Super)
                .appendTo(this.content);
            this.superImage = LoadedIcon_4.default.create([])
                .classes.add(ItemSubclassTooltipClasses.SuperImage)
                .appendTo(this.superWrapper);
            this.superName = Component_47.default.create()
                .classes.add(ItemSubclassTooltipClasses.SuperName)
                .appendTo(this.superWrapper);
            this.flavour = Component_47.default.create()
                .classes.add(ItemSubclassTooltipClasses.Flavour)
                .appendTo(this.content);
        }
        set(item) {
            this.item = item;
            console.log(DisplayProperties_9.default.name(item.definition), item);
            this.classes.removeWhere(cls => cls.startsWith(ItemSubclassTooltipClasses.IsDamageType))
                .classes.add(`${ItemSubclassTooltipClasses.IsDamageType}-${DamageTypes_4.default.nameOf(item.getDamageType())}`);
            const damageType = DamageTypes_4.default.get(item.getDamageType());
            this.damageTypeIcon.classes.toggle(!damageType?.displayProperties.icon, Classes_11.Classes.Hidden)
                .style.set("--icon", DisplayProperties_9.default.icon(damageType));
            this.title.text.set(DisplayProperties_9.default.name(item.definition));
            this.subtitle.text.set(item.definition.itemTypeDisplayName);
            const superAbility = item.getSocketedPlug("=Subclass/Super");
            const superName = DisplayProperties_9.default.name(superAbility?.definition);
            this.superWrapper.classes.toggle(!superName, Classes_11.Classes.Hidden);
            if (superName) {
                this.superName.text.set(superName);
                const highResIcon = superAbility?.definition?.displayProperties.highResIcon;
                this.superImage.classes.toggle(!highResIcon, Classes_11.Classes.Hidden)
                    .setPath(highResIcon && `https://www.bungie.net${highResIcon}`);
            }
            this.flavour.text.set(item.definition.flavorText);
        }
    }
    exports.default = TooltipManager_3.default.create(tooltip => tooltip
        .make(ItemSubclassTooltip));
});
define("model/models/WallpaperMoments", ["require", "exports", "model/Model", "model/models/manifest/DeepsightManifest"], function (require, exports, Model_13, DeepsightManifest_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Model_13.default.createDynamic("Daily", async (_) => DeepsightManifest_3.DeepsightManifest.await()
        .then(async (manifest) => {
        const wallpaperMomentsRaw = await manifest.DeepsightWallpaperDefinition.all();
        const moments = await manifest.DeepsightMomentDefinition.all();
        return wallpaperMomentsRaw
            .map(def => ({
            ...def,
            moment: moments.find(moment => def.hash === moment.hash),
        }))
            .sort((a, b) => +(a.moment?.hash || 0) - +(b.moment?.hash || 0));
    }));
});
// export async function createWallpaperThumbnail (wallpaper: string) {
// 	const image = new Image();
// 	image.src = wallpaper;
// 	await new Promise(resolve => image.onload = resolve);
// 	const canvas = document.createElement("canvas");
// 	canvas.width = 144;
// 	canvas.height = 81;
// 	const context = canvas.getContext("2d")!;
// 	context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
// 	return canvas;
// }
define("utility/Functions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Functions;
    (function (Functions) {
        function resolve(fn, ...args) {
            return typeof fn === "function" ? fn(...args) : fn;
        }
        Functions.resolve = resolve;
    })(Functions || (Functions = {}));
    exports.default = Functions;
});
define("ui/component/BackgroundManager", ["require", "exports", "model/models/WallpaperMoments", "ui/component/Component", "ui/utility/Classes", "utility/Arrays", "utility/Env", "utility/Functions", "utility/Store", "utility/decorator/Bound"], function (require, exports, WallpaperMoments_1, Component_48, Classes_12, Arrays_8, Env_5, Functions_1, Store_13, Bound_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BackgroundClasses;
    (function (BackgroundClasses) {
        BackgroundClasses["Surface"] = "background-surface";
        BackgroundClasses["Blur"] = "background-surface-blur";
        BackgroundClasses["Darkened"] = "background-surface--darkened";
        BackgroundClasses["Prismatic"] = "background-surface--prismatic";
        BackgroundClasses["Image"] = "background-image";
    })(BackgroundClasses || (BackgroundClasses = {}));
    class Background extends Component_48.default {
        static async initialiseMain() {
            const moments = await WallpaperMoments_1.default.await();
            const latestMoment = moments.slice().sort((a, b) => b.hash - a.hash)[0];
            const currentYear = Math.max(...moments.map(moment => moment.moment.year ?? 0));
            const currentSeason = moments.findLast(moment => moment.moment.season);
            const currentExpansion = moments.find(moment => moment.moment.expansion && moment.moment.year === currentYear);
            const seasonsThisYear = moments.filter(moment => moment.moment.season && moment.moment.year === currentYear);
            const wallpapers = latestMoment === currentSeason && seasonsThisYear.length === 1
                ? [...currentExpansion?.wallpapers ?? [], ...currentSeason.wallpapers]
                : latestMoment.wallpapers;
            if (!wallpapers.length)
                wallpapers.push(...latestMoment.wallpapers);
            const manager = this.main ??= Background
                .create([() => Store_13.default.items.settingsBackground
                    ?? (Store_13.default.items.settingsBackgroundNoUseDefault ? undefined
                        : wallpapers[Math.floor(Math.random() * wallpapers.length)])])
                .setBlurred(() => Store_13.default.items.settingsBackgroundBlur === true ? 1 : Store_13.default.items.settingsBackgroundBlur)
                .prependTo(document.body);
            Store_13.default.event.subscribe(["setSettingsBackground", "deleteSettingsBackground", "setSettingsBackgroundUseDefault", "deleteSettingsBackgroundUseDefault"], manager.updateBackground);
            Store_13.default.event.subscribe("setSettingsBackgroundBlur", manager.updateBackgroundBlur);
            Store_13.default.event.subscribe("setSettingsBackgroundFollowMouse", manager.updateBackgroundFollowMouse);
            Store_13.default.event.subscribe(["setSettingsBackgroundRainbow", "deleteSettingsBackgroundRainbow"], manager.updateBackgroundPrismatic);
            Store_13.default.event.subscribe(["setSettingsBackgroundRainbowVibrancy", "deleteSettingsBackgroundRainbowVibrancy"], manager.updateBackgroundPrismatic);
            Store_13.default.event.subscribe(["setSettingsBackgroundDarkness", "deleteSettingsBackgroundDarkness"], manager.updateBackgroundDarkness);
        }
        static getScrollAmount() {
            return Store_13.default.items.settingsBackgroundFollowMouse ? 0.05 : 0;
        }
        onMake(path) {
            this.path = path;
            this.classes.add(BackgroundClasses.Surface);
            this.unfiltered = false;
            this.backgrounds = [];
            this.updateBackground();
            this.updateBackgroundBlur();
            this.updateBackgroundDarkness();
            this.updateBackgroundPrismatic();
            this.updateBackgroundFollowMouse();
            document.body.addEventListener("mousemove", event => {
                this.element.scrollLeft = (event.clientX / Component_48.default.window.width) * Component_48.default.window.width * Background.getScrollAmount();
                this.element.scrollTop = (event.clientY / Component_48.default.window.height) * Component_48.default.window.height * Background.getScrollAmount();
            });
        }
        setPath(path) {
            this.path = path;
            this.updateBackground();
            return this;
        }
        setBlurred(blurred) {
            this.blurred = blurred;
            this.updateBackgroundBlur();
            return this;
        }
        setUnfiltered(unfiltered) {
            this.unfiltered = unfiltered;
            this.updateBackgroundDarkness();
            this.updateBackgroundPrismatic();
            return this;
        }
        updateBackground() {
            const background = Arrays_8.default.resolve(Functions_1.default.resolve(this.path));
            this.removeContents();
            this.backgrounds = [];
            if (background.length) {
                this.classes.add(Classes_12.Classes.Hidden);
                const remotepath = "https://deepsight.gg/";
                let loaded = 0;
                for (let i = 0; i < background.length; i++) {
                    const path = background[i];
                    this.backgrounds.push(Component_48.default.create("img")
                        .classes.add(BackgroundClasses.Image, `${BackgroundClasses.Image}-${i}`)
                        .attributes.set("src", path.startsWith(remotepath) ? `${Env_5.default.DEEPSIGHT_PATH}${path.slice(remotepath.length)}` : path)
                        .event.subscribe("load", () => {
                        loaded++;
                        if (loaded >= background.length)
                            this.classes.remove(Classes_12.Classes.Hidden);
                    })
                        .appendTo(this));
                }
            }
        }
        updateBackgroundBlur() {
            this.classes.toggle(!!Functions_1.default.resolve(this.blurred), BackgroundClasses.Blur)
                .style.set("--blur", `${Store_13.default.items.settingsBackgroundBlur ?? 1}`);
        }
        updateBackgroundDarkness() {
            this.classes.toggle(!Functions_1.default.resolve(this.unfiltered), BackgroundClasses.Darkened)
                .style.set("--darkness", `${Store_13.default.items.settingsBackgroundDarkness ?? 0.5}`);
        }
        updateBackgroundPrismatic() {
            this.classes.toggle(!Functions_1.default.resolve(this.unfiltered), BackgroundClasses.Prismatic)
                .style.set("--prismatic-vibrancy", `${Store_13.default.items.settingsBackgroundRainbowVibrancy ?? 0.5}`);
        }
        updateBackgroundFollowMouse() {
            this.style.set("--scroll-amount", `${Background.getScrollAmount()}`);
        }
    }
    exports.default = Background;
    __decorate([
        Bound_19.default
    ], Background.prototype, "updateBackground", null);
    __decorate([
        Bound_19.default
    ], Background.prototype, "updateBackgroundBlur", null);
    __decorate([
        Bound_19.default
    ], Background.prototype, "updateBackgroundDarkness", null);
    __decorate([
        Bound_19.default
    ], Background.prototype, "updateBackgroundPrismatic", null);
    __decorate([
        Bound_19.default
    ], Background.prototype, "updateBackgroundFollowMouse", null);
});
define("ui/view/View", ["require", "exports", "model/models/Characters", "model/models/DeepsightStats", "model/models/Manifest", "model/models/enum/EnumModel", "ui/component/BackgroundManager", "ui/component/Button", "ui/component/Component", "ui/component/Loadable", "ui/destiny/sort/SortManager", "ui/utility/Classes", "utility/EventManager", "utility/Functions"], function (require, exports, Characters_5, DeepsightStats_2, Manifest_18, EnumModel_7, BackgroundManager_1, Button_12, Component_49, Loadable_4, SortManager_1, Classes_13, EventManager_19, Functions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var View;
    (function (View) {
        class Factory {
            constructor() {
                this.otherModels = [];
                this.initialisers = [];
                this.definition = [];
            }
            using(...models) {
                this.otherModels.push(...models);
                return this;
            }
            initialise(initialiser) {
                this.initialisers.push(initialiser);
                return this;
            }
            wrapper() {
                return this;
            }
            define() {
                return this;
            }
            helper(helper) {
                Object.assign(this, helper);
                return this;
            }
            configure(definition) {
                this.definition.push(definition);
                return this;
            }
            clone() {
                const clone = Object.assign(new Factory(), this);
                this.definition = this.definition.slice();
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                this.otherModels = [...this.otherModels];
                this.initialisers = [...this.initialisers];
                return clone;
            }
            create(definition) {
                for (let i = this.definition.length - 1; i >= 0; i--) {
                    const currentDef = this.definition[i];
                    definition = typeof currentDef === "function" ? { ...currentDef(definition), ...definition } : { ...currentDef, ...definition };
                }
                return new Handler({
                    ...definition,
                    models: this.otherModels,
                    initialise: async (component, ...requirements) => {
                        await Promise.all([
                            DeepsightStats_2.default.await(),
                            Manifest_18.default.await(),
                            EnumModel_7.default.awaitAll(),
                            Characters_5.default.awaitReady(),
                        ]);
                        await SortManager_1.default.init();
                        for (const initialiser of [...this.initialisers, definition.initialise]) {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                            await initialiser?.(component, ...requirements);
                        }
                    },
                });
            }
        }
        View.Factory = Factory;
        function create(definition) {
            return new Handler(definition);
        }
        View.create = create;
        class Handler {
            constructor(definition) {
                Object.assign(this, definition);
            }
            get definition() {
                return this;
            }
            show(...args) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                const view = WrapperComponent.create([this, ...args]);
                View.event.emit("show", { view });
            }
            hide() {
                View.event.emit("hide");
            }
        }
        View.Handler = Handler;
        View.event = EventManager_19.EventManager.make();
        let Classes;
        (function (Classes) {
            Classes["Main"] = "view";
            Classes["Content"] = "view-content";
            Classes["Header"] = "view-header";
            Classes["Footer"] = "view-footer";
            Classes["FooterButton"] = "view-footer-button";
            Classes["FooterButtonIcon"] = "view-footer-button-icon";
            Classes["FooterButtonLabel"] = "view-footer-button-label";
            Classes["FooterButtonText"] = "view-footer-button-text";
            Classes["Hidden"] = "view-hidden";
            Classes["Loadable"] = "view-loadable";
            Classes["Title"] = "view-title";
            Classes["Subtitle"] = "view-subtitle";
            Classes["Subview"] = "view-subview";
            Classes["Background"] = "view-background";
        })(Classes = View.Classes || (View.Classes = {}));
        function registerFooterButton(button) {
            button.classes.remove(Button_12.ButtonClasses.Main)
                .classes.add(Classes.FooterButton)
                .innerIcon?.classes.add(Classes.FooterButtonIcon);
        }
        View.registerFooterButton = registerFooterButton;
        class ContentComponent extends Component_49.default {
            onMake(definition) {
                this.definition = definition;
                this.header = Component_49.default.create()
                    .classes.add(Classes.Header, Classes.Header.replace("-", `-${this.definition.id}-`), Classes_13.Classes.Hidden)
                    .appendTo(this);
                this.title = Component_49.default.create()
                    .classes.add(Classes.Title, Classes.Title.replace("-", `-${this.definition.id}-`), Classes_13.Classes.Hidden)
                    .appendTo(this.header);
                this.subtitle = Component_49.default.create()
                    .classes.add(Classes.Subtitle, Classes.Subtitle.replace("-", `-${this.definition.id}-`), Classes_13.Classes.Hidden)
                    .appendTo(this.header);
                this.classes.add(Classes.Content, `view-${this.definition.id}-content`);
            }
        }
        View.ContentComponent = ContentComponent;
        class WrapperComponent extends Component_49.default {
            get header() { return this.content.header; }
            get title() { return this.content.title; }
            get subtitle() { return this.content.subtitle; }
            get footer() {
                Object.defineProperty(this, "footer", { value: this._footer });
                return this._footer.classes.remove(Classes_13.Classes.Hidden);
            }
            setBackground(...src) {
                this.background?.remove();
                return this.background = BackgroundManager_1.default.create([src])
                    .prependTo(this);
            }
            get hash() {
                let hash = this.definition.hash;
                if (typeof hash === "string" || hash === null)
                    return hash;
                if (typeof hash === "function")
                    hash = hash?.(...this._args.slice(1));
                return hash ?? this.definition.id;
            }
            get noProfileInURL() {
                return Functions_2.default.resolve(this.definition.noProfileInURL, ...this._args.slice(1)) ?? false;
            }
            onMake(definition, ...args) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                this._args = [definition, ...args];
                this.definition = definition;
                this.classes.add(Classes.Main, `view-${this.definition.id}`);
                this.style.set("--index", `${WrapperComponent.index++}`);
                this._footer = Component_49.default.create()
                    .classes.add(Classes.Footer, Classes.Footer.replace("-", `-${this.definition.id}-`), Classes_13.Classes.Hidden)
                    .appendTo(this);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument
                this.content = ContentComponent.create([definition])
                    .classes.add(Classes.Content.replace("-", `-${this.definition.id}-`))
                    .appendTo(this);
                if (!this.definition.models) {
                    this.initialise(...[]);
                    return;
                }
                let models = this.definition.models;
                if (typeof models === "function")
                    models = models(...args);
                Loadable_4.default.create(...models)
                    .onReady((...results) => this.initialise?.(...results))
                    .classes.add(Classes.Loadable)
                    .appendTo(this);
            }
            setTitle(tweak) {
                this.content.header.classes.remove(Classes_13.Classes.Hidden);
                this.content.title.classes.remove(Classes_13.Classes.Hidden).tweak(tweak);
                this.event.emit("updateTitle");
                return this;
            }
            setSubtitle(type, tweak) {
                this.content.header.classes.remove(Classes_13.Classes.Hidden);
                this.content.subtitle.classes.add(`${Classes.Subtitle}-${type}`).classes.remove(Classes_13.Classes.Hidden).tweak(tweak);
                return this;
            }
            updateHash(...args) {
                const realArgs = this._args;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                this._args = [realArgs[0], ...args];
                this.event.emit("updateHash", { args });
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                this._args = realArgs;
                return this;
            }
            initialise(...args) {
                this.definition.initialise?.(this, ...args);
                this.event.emit("initialise");
                return this.content;
            }
            back() {
                this.event.emit("back");
            }
        }
        WrapperComponent.index = 0;
        View.WrapperComponent = WrapperComponent;
    })(View || (View = {}));
    exports.default = View;
});
define("ui/component/Card", ["require", "exports", "ui/component/Component"], function (require, exports, Component_50) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CardClasses = void 0;
    var CardClasses;
    (function (CardClasses) {
        CardClasses["Main"] = "card";
        CardClasses["Header"] = "card-header";
        CardClasses["Title"] = "card-title";
        CardClasses["TitleButton"] = "card-title-button";
        CardClasses["Icon"] = "card-icon";
        CardClasses["Background"] = "card-background";
        CardClasses["BackgroundWrapper"] = "card-background-wrapper";
        CardClasses["Content"] = "card-content";
        CardClasses["ContentWrapper"] = "card-content-wrapper";
        CardClasses["DisplayModeBlock"] = "card-block";
        CardClasses["DisplayModeBlockHeader"] = "card-block-header";
        CardClasses["DisplayModeBlockTitle"] = "card-block-title";
        CardClasses["DisplayModeBlockTitleButton"] = "card-block-title-button";
        CardClasses["DisplayModeBlockIcon"] = "card-block-icon";
        CardClasses["DisplayModeBlockBackground"] = "card-block-background";
        CardClasses["DisplayModeBlockBackgroundWrapper"] = "card-block-background-wrapper";
        CardClasses["DisplayModeBlockContent"] = "card-block-content";
        CardClasses["DisplayModeBlockContentWrapper"] = "card-block-content-wrapper";
        CardClasses["DisplayModeSection"] = "card-section";
        CardClasses["DisplayModeSectionHeader"] = "card-section-header";
        CardClasses["DisplayModeSectionTitle"] = "card-section-title";
        CardClasses["DisplayModeSectionTitleButton"] = "card-section-title-button";
        CardClasses["DisplayModeSectionIcon"] = "card-section-icon";
        CardClasses["DisplayModeSectionBackground"] = "card-section-background";
        CardClasses["DisplayModeSectionBackgroundWrapper"] = "card-section-background-wrapper";
        CardClasses["DisplayModeSectionContent"] = "card-section-content";
        CardClasses["DisplayModeSectionContentWrapper"] = "card-section-content-wrapper";
        CardClasses["DisplayModeCard"] = "card-card";
        CardClasses["DisplayModeCardHeader"] = "card-card-header";
        CardClasses["DisplayModeCardTitle"] = "card-card-title";
        CardClasses["DisplayModeCardTitleButton"] = "card-card-title-button";
        CardClasses["DisplayModeCardIcon"] = "card-card-icon";
        CardClasses["DisplayModeCardBackground"] = "card-card-background";
        CardClasses["DisplayModeCardBackgroundWrapper"] = "card-card-background-wrapper";
        CardClasses["DisplayModeCardContent"] = "card-card-content";
        CardClasses["DisplayModeCardContentWrapper"] = "card-card-content-wrapper";
    })(CardClasses || (exports.CardClasses = CardClasses = {}));
    const displayModes = [
        CardClasses.DisplayModeBlock,
        CardClasses.DisplayModeSection,
        CardClasses.DisplayModeCard,
    ];
    class Card extends Component_50.default {
        /**
         * Only supports DisplayModeBlock and DisplayModeSection atm
         */
        get icon() {
            if (this._icon?.element.parentElement !== this.title.element)
                delete this._icon;
            return this._icon ??= Component_50.default.create()
                .classes.add(CardClasses.Icon, `${this.getDisplayMode()}-icon`)
                .appendTo(this.title);
        }
        /**
         * Only supports DisplayModeCard atm
         */
        get background() {
            return this._background ??= Component_50.default.create("img")
                .classes.add(CardClasses.Background, `${this.getDisplayMode()}-background`)
                .appendTo(this._backgroundWrapper = Component_50.default.create()
                .classes.add(CardClasses.BackgroundWrapper, `${this.getDisplayMode()}-background-wrapper`)
                .prependTo(this));
        }
        onMake(...args) {
            this.classes.add(CardClasses.Main);
            this.header = Component_50.default.create()
                .classes.add(CardClasses.Header)
                .appendTo(this);
            this.title = Component_50.default.create()
                .classes.add(CardClasses.Title)
                .appendTo(this.header);
            this.contentWrapper = Component_50.default.create()
                .classes.add(CardClasses.ContentWrapper)
                .appendTo(this);
            this.content = Component_50.default.create()
                .classes.add(CardClasses.Content)
                .appendTo(this.contentWrapper);
            this.setDisplayMode(CardClasses.DisplayModeBlock);
        }
        getDisplayMode() {
            const result = this.classes.has(CardClasses.DisplayModeBlock) ? CardClasses.DisplayModeBlock
                : this.classes.has(CardClasses.DisplayModeCard) ? CardClasses.DisplayModeCard
                    : this.classes.has(CardClasses.DisplayModeSection) ? CardClasses.DisplayModeSection
                        : undefined;
            if (!result)
                throw new Error("Card has no display mode");
            return result;
        }
        setDisplayMode(displayMode) {
            const titleButtons = [...this.title.children()].filter(child => child.classes.has(CardClasses.TitleButton));
            for (const displayMode of displayModes) {
                this.classes.remove(displayMode);
                this.header.classes.remove(`${displayMode}-header`);
                this.title.classes.remove(`${displayMode}-title`);
                this.content.classes.remove(`${displayMode}-content`);
                this.contentWrapper.classes.remove(`${displayMode}-content-wrapper`);
                this._icon?.classes.remove(`${displayMode}-icon`);
                this._background?.classes.remove(`${displayMode}-background`);
                this._backgroundWrapper?.classes.remove(`${displayMode}-background-wrapper`);
                titleButtons.forEach(button => button.classes.remove(`${displayMode}-title-button`));
            }
            this.classes.add(displayMode);
            this.header.classes.add(`${displayMode}-header`);
            this.title.classes.add(`${displayMode}-title`);
            this.content.classes.add(`${displayMode}-content`);
            this.contentWrapper.classes.add(`${displayMode}-content-wrapper`);
            this._icon?.classes.add(`${displayMode}-icon`);
            this._background?.classes.add(`${displayMode}-background`);
            this._backgroundWrapper?.classes.add(`${displayMode}-background-wrapper`);
            titleButtons.forEach(button => button.classes.add(`${displayMode}-title-button`));
            return this;
        }
    }
    Card.DISPLAY_MODES = displayModes;
    exports.default = Card;
});
define("ui/destiny/filter/ItemFilter", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/component/Drawer", "ui/destiny/component/EnumIcon", "ui/destiny/filter/Filter", "ui/utility/Classes", "ui/utility/UiEventBus", "utility/Async", "utility/Store", "utility/Strings", "utility/decorator/Bound"], function (require, exports, Button_13, Component_51, Drawer_2, EnumIcon_7, Filter_1, Classes_14, UiEventBus_5, Async_6, Store_14, Strings_4, Bound_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterChipButton = exports.ItemFilterClasses = void 0;
    const QUOTES = {
        "\"": "\"",
        "'": "'",
        "`": "`",
        "(": ")",
        "[": "]",
    };
    var ItemFilterClasses;
    (function (ItemFilterClasses) {
        ItemFilterClasses["Main"] = "item-filter";
        ItemFilterClasses["Button"] = "item-filter-button";
        ItemFilterClasses["ButtonIcon"] = "item-filter-button-icon";
        ItemFilterClasses["ButtonLabel"] = "item-filter-button-label";
        ItemFilterClasses["Input"] = "item-filter-input";
        ItemFilterClasses["Reset"] = "item-filter-reset";
        ItemFilterClasses["Reset1"] = "item-filter-reset1";
        ItemFilterClasses["FilterChip"] = "item-filter-chip";
        ItemFilterClasses["FilterChipPrefix"] = "item-filter-chip-prefix";
        ItemFilterClasses["FilterChipValue"] = "item-filter-chip-value";
        ItemFilterClasses["FilterChipValueHasIcon"] = "item-filter-chip-value-has-icon";
        ItemFilterClasses["FilterChipValueHasMaskIcon"] = "item-filter-chip-value-has-mask-icon";
        ItemFilterClasses["FilterChipRaw"] = "item-filter-chip-raw";
        ItemFilterClasses["Drawer"] = "item-filter-drawer";
        ItemFilterClasses["DrawerPanel"] = "item-filter-drawer-panel";
        ItemFilterClasses["FiltersHeading"] = "item-filter-heading";
        ItemFilterClasses["SuggestedFilters"] = "item-filter-suggested";
        ItemFilterClasses["FilterId"] = "item-filter-id";
        ItemFilterClasses["FilterChipButton"] = "item-filter-chip-button";
        ItemFilterClasses["FilterChipButtonPrefix"] = "item-filter-chip-button-prefix";
        ItemFilterClasses["FilterChipButtonValue"] = "item-filter-chip-button-value";
        ItemFilterClasses["FilterChipButtonValueId"] = "item-filter-chip-button-value-id";
        ItemFilterClasses["FilterChipButtonValueHasIcon"] = "item-filter-chip-button-value-has-icon";
        ItemFilterClasses["FilterChipButtonValueHasMaskIcon"] = "item-filter-chip-button-value-has-mask-icon";
        ItemFilterClasses["FilterChipButtonValueHint"] = "item-filter-chip-button-value-hint";
        ItemFilterClasses["FilterChipButtonSelected"] = "item-filter-chip-button-selected";
    })(ItemFilterClasses || (exports.ItemFilterClasses = ItemFilterClasses = {}));
    class FilterChipButton extends Button_13.default {
        constructor() {
            super(...arguments);
            this.visible = true;
        }
        onMake(filter, value, icon, isHint) {
            super.onMake(filter, value, icon, isHint);
            this.isHint = isHint ?? false;
            this.shouldHideByDefault = !isHint && !!filter.suggestedValueHint && !!filter.suggestedValues?.length && filter.suggestedValues.length > 5;
            icon ??= Filter_1.IFilter.icon(value, filter.icon);
            const maskIcon = Filter_1.IFilter.icon(value, filter.maskIcon);
            const usedIcon = icon ?? maskIcon;
            this.prefix = filter.prefix;
            this.value = value;
            this.searchableValue = ` ${value.toLowerCase()}`;
            this.id = `${filter.prefix}${value.toLowerCase()}`;
            this.classes.add(ItemFilterClasses.FilterChipButton)
                .classes.toggle(this.shouldHideByDefault, Classes_14.Classes.Hidden)
                .classes.add(`${ItemFilterClasses.FilterId}-${filter.internalName}`)
                .attributes.set("data-id", this.id)
                .append(Component_51.default.create("span")
                .classes.add(ItemFilterClasses.FilterChipButtonPrefix)
                .text.set(filter.prefix))
                .append(Component_51.default.create("span")
                .classes.add(ItemFilterClasses.FilterChipButtonValue)
                .classes.add(`${ItemFilterClasses.FilterChipButtonValueId}-${filter.internalName}`)
                .classes.toggle(isHint ?? false, ItemFilterClasses.FilterChipButtonValueHint)
                .classes.toggle(icon !== undefined, ItemFilterClasses.FilterChipButtonValueHasIcon)
                .classes.toggle(maskIcon !== undefined, ItemFilterClasses.FilterChipButtonValueHasMaskIcon)
                .text.set(value)
                .style.set("--icon", typeof usedIcon === "string" ? usedIcon : undefined)
                .tweak(async (valueSpan) => Array.isArray(usedIcon)
                && !await EnumIcon_7.default.applyIconVar(valueSpan, ...usedIcon)
                && valueSpan.classes.remove(ItemFilterClasses.FilterChipButtonValueHasIcon, ItemFilterClasses.FilterChipButtonValueHasMaskIcon)))
                .style.set("--colour", Filter_1.IFilter.colour(value, filter.colour));
        }
        show() {
            this.classes.remove(Classes_14.Classes.Hidden);
            this.visible = true;
            return this;
        }
        hide() {
            this.classes.add(Classes_14.Classes.Hidden);
            this.visible = false;
            return this;
        }
        toggle(visible) {
            this.classes.toggle(!visible, Classes_14.Classes.Hidden);
            this.visible = visible;
            return this;
        }
    }
    exports.FilterChipButton = FilterChipButton;
    FilterChipButton.defaultType = "span";
    class ItemFilter extends Component_51.default {
        static getFor(filterer) {
            return filterer.uiComponent ??= ItemFilter.create([filterer]);
        }
        onMake(filterer) {
            this.filterer = filterer;
            this.classes.add(ItemFilterClasses.Main);
            ////////////////////////////////////
            // Button
            this.button = Button_13.default.create()
                .classes.add(ItemFilterClasses.Button)
                .event.subscribe("click", this.openDrawer)
                .event.subscribe("focus", this.openDrawer)
                .addIcon(icon => icon.classes.add(ItemFilterClasses.ButtonIcon))
                .appendTo(this);
            this.label = Component_51.default.create()
                .classes.add(ItemFilterClasses.ButtonLabel)
                .text.set(`Filter ${filterer.name}`)
                .appendTo(this.button);
            this.input = Component_51.default.create()
                .classes.add(ItemFilterClasses.Input)
                .attributes.add("contenteditable")
                .attributes.set("spellcheck", "false")
                .attributes.set("placeholder", "No filter enabled")
                .text.set(Store_14.default.items.settingsClearItemFilterOnSwitchingViews ? "" : Store_14.default.items.itemFilter ?? "")
                .event.subscribe("paste", this.onPaste)
                .event.subscribe("input", this.onInput)
                .event.subscribe("focus", () => {
                this.button.attributes.set("tabindex", "-1");
                void this.openDrawer();
            })
                .event.subscribe("blur", () => {
                this.button.attributes.remove("tabindex");
            })
                .appendTo(this.button);
            this.resetButton = Button_13.default.create()
                .classes.add(ItemFilterClasses.Reset, Classes_14.Classes.Hidden)
                .event.subscribe("click", () => this.reset(true))
                .append(Component_51.default.create()
                .classes.add(ItemFilterClasses.Reset1))
                .appendTo(this.button);
            ////////////////////////////////////
            // Drawer
            this.drawer = Drawer_2.default.create()
                .classes.add(ItemFilterClasses.Drawer)
                .attributes.set("tabindex", "-1")
                .event.subscribe("click", () => this.input.element.focus())
                .appendTo(this);
            this.mainPanel = this.drawer.createPanel();
            Component_51.default.create()
                .classes.add(ItemFilterClasses.FiltersHeading)
                .text.set("Suggested Filters")
                .appendTo(this.mainPanel);
            const suggestedFilters = Component_51.default.create()
                .classes.add(ItemFilterClasses.SuggestedFilters)
                .appendTo(this.mainPanel);
            this.suggestedChips = [];
            for (const filter of filterer.getApplicable()) {
                if (!filter.suggestedValues?.length && !filter.suggestedValueHint)
                    continue;
                if (filter.suggestedValueHint)
                    this.suggestedChips.push(FilterChipButton.create([filter, filter.suggestedValueHint, undefined, true])
                        .event.subscribe("mousedown", () => this.ignoreNextSelectionChange = true)
                        .event.subscribe("click", () => this.toggleChip(filter))
                        .tweak(filter.tweakChip, filter.suggestedValueHint)
                        .appendTo(suggestedFilters));
                for (const value of filter.suggestedValues ?? [])
                    this.suggestedChips.push(FilterChipButton.create([filter, typeof value === "string" ? value : value.name, typeof value === "string" ? undefined : value.icon])
                        .tweak(filter.tweakChip, typeof value === "string" ? value : value.name)
                        .event.subscribe("mousedown", () => this.ignoreNextSelectionChange = true)
                        .event.subscribe("click", () => this.toggleChip(filter, typeof value === "string" ? value : value.name))
                        .appendTo(suggestedFilters));
            }
            UiEventBus_5.default.subscribe("keydown", this.onGlobalKeydown);
            this.cleanup();
            document.addEventListener("selectionchange", this.onSelectionChange);
        }
        isFiltered() {
            return this.input.hasContents();
        }
        reset(focus = false) {
            this.input.removeContents();
            this.cleanup(focus);
            this.filterChips();
        }
        async openDrawer() {
            if (!this.drawer.classes.has(Classes_14.Classes.Hidden))
                return this.input.element.focus();
            this.drawer.open();
            await Async_6.default.sleep(0); // next tick
            this.input.element.focus();
            const selection = document.getSelection();
            if (!this.input.element.contains(selection?.focusNode ?? null) || !this.input.element.contains(selection?.anchorNode ?? null))
                selection?.selectAllChildren(this.input.element);
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            document.addEventListener("focusout", this.onFocusOut);
        }
        closeDrawer() {
            this.drawer.close();
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            document.removeEventListener("focusout", this.onFocusOut);
        }
        async onFocusOut() {
            await Async_6.default.sleep(0); // next tick
            if (this.element.contains(document.activeElement))
                return;
            this.closeDrawer();
        }
        onSelectionChange() {
            if (!document.contains(this.element)) {
                document.removeEventListener("selectionchange", this.onSelectionChange);
                return;
            }
            if (this.ignoreNextSelectionChange) {
                delete this.ignoreNextSelectionChange;
                return;
            }
            const selection = document.getSelection();
            if (!selection?.anchorNode || !selection.focusNode)
                this.lastSelectionRange = undefined;
            else {
                this.lastSelectionRange = selection.getRangeAt(0).cloneRange();
            }
            if (selection?.isCollapsed && this.input.contains(selection.anchorNode) && this.input.contains(selection.focusNode))
                this.filterChips();
        }
        onGlobalKeydown(event) {
            if (!document.contains(this.element)) {
                UiEventBus_5.default.unsubscribe("keydown", this.onGlobalKeydown);
                return;
            }
            if (event.useOverInput("f", "ctrl")) {
                this.input.element.focus();
                void this.openDrawer();
            }
            if (this.input.isFocused()) {
                if (event.useOverInput("Escape")) {
                    this.closeDrawer();
                    this.reset(true);
                }
                if (event.useOverInput("ArrowUp")) {
                    this.selectUp();
                }
                if (event.useOverInput("ArrowDown")) {
                    this.selectDown();
                }
                if (this.currentSelection) {
                    if (event.useOverInput("ArrowLeft")) {
                        this.selectLeft();
                    }
                    if (event.useOverInput("ArrowRight")) {
                        this.selectRight();
                    }
                    if (event.useOverInput(" ") || event.useOverInput("Enter")) {
                        this.currentSelection.event.emit(new MouseEvent("click"));
                        return;
                    }
                }
            }
            if (this.drawer.isOpen() && event.useOverInput("Enter")) {
                this.closeDrawer();
                this.event.emit(new SubmitEvent("submit"));
            }
            // cancel keybinds
            event.useOverInput("b", "ctrl");
            event.useOverInput("i", "ctrl");
            event.useOverInput("u", "ctrl");
        }
        onPaste(event) {
            event.preventDefault();
            const data = event.clipboardData?.getData("text/plain");
            if (!data)
                return;
            const selection = document.getSelection();
            for (let i = 0; i < (selection?.rangeCount ?? 0); i++) {
                const range = selection?.getRangeAt(i);
                if (!range)
                    continue;
                if (!this.input.element.contains(range.startContainer) || !this.input.element.contains(range.endContainer))
                    continue;
                range.deleteContents();
                range.insertNode(document.createTextNode(data.replace(/\n/g, "")));
                range.collapse();
            }
            void this.openDrawer();
            this.cleanup();
            this.filterChips();
        }
        get visibleChips() {
            return this._visibleChips ??= this.suggestedChips.filter(chip => !chip.classes.has(Classes_14.Classes.Hidden));
        }
        getCurrentSelection(from) {
            return this.currentSelection ??= this.getSelectionFrom(from === "front" ? "end" : "front");
        }
        getSelectionFrom(from) {
            return from === "front" ? this.visibleChips[0] : this.visibleChips[this.visibleChips.length - 1];
        }
        findSelection(getSortIndex, currentBox) {
            for (const filter of this.visibleChips)
                filter.getRect(true);
            const sorted = this.visibleChips.sort((a, b) => getSortIndex(b.getRect(), currentBox) - getSortIndex(a.getRect(), currentBox));
            return getSortIndex(sorted[0].getRect(), currentBox) < 0 ? undefined : sorted[0];
        }
        select(from, getSortIndex, defaultToFrom = true) {
            delete this._visibleChips;
            const currentSelection = this.getCurrentSelection("end");
            const currentBox = currentSelection.getRect(true);
            const selection = this.findSelection(getSortIndex, currentBox)
                ?? (defaultToFrom ? this.getSelectionFrom(from) : undefined);
            if (selection) {
                this.currentSelection?.classes.remove(ItemFilterClasses.FilterChipButtonSelected, Button_13.ButtonClasses.Selected);
                this.currentSelection = selection;
                this.currentSelection?.classes.add(ItemFilterClasses.FilterChipButtonSelected, Button_13.ButtonClasses.Selected);
                this.currentSelection?.element.scrollIntoView({ block: "center" });
            }
        }
        selectUp() {
            this.select("end", (rect, currentBox) => currentBox.top < rect.bottom ? -1000000 : (100000 - Math.abs(rect.bottom - currentBox.top)) * 10000 - Math.abs(rect.centerX - currentBox.centerX));
        }
        selectDown() {
            this.select("front", (rect, currentBox) => currentBox.bottom > rect.top ? -1000000 : (100000 - Math.abs(rect.top - currentBox.bottom)) * 10000 - Math.abs(rect.centerX - currentBox.centerX));
        }
        selectLeft() {
            this.select("end", (rect, currentBox) => currentBox.centerY !== rect.centerY ? -10000000 : currentBox.left < rect.right ? -1000000 : 10000 - (Math.abs(rect.centerX - currentBox.centerX)), false);
        }
        selectRight() {
            this.select("front", (rect, currentBox) => currentBox.centerY !== rect.centerY ? -10000000 : currentBox.right > rect.left ? -1000000 : 10000 - (Math.abs(currentBox.centerX - rect.centerX)), false);
        }
        toggleChip(filter, value) {
            const chipText = `${filter.prefix}${!value ? "" : value.includes(" ") ? `"${value}"` : value}`;
            const editingChip = this.getEditingChip();
            const textContent = this.input.element.textContent ?? "";
            let removed = false;
            if (!editingChip) {
                const chipRegex = new RegExp(`(?<=^| |\xa0)${chipText}(?= |\xa0|$)`);
                removed = chipRegex.test(textContent);
                if (removed)
                    this.input.element.textContent = textContent.replace(chipRegex, "");
                else
                    this.input.element.appendChild(document.createTextNode(chipText));
            }
            else {
                editingChip.value?.remove();
                editingChip.prefix.replaceWith(document.createTextNode(chipText));
            }
            this.cleanup();
            if (removed || value)
                this.setCursorAtEnd();
            else
                this.setCursorAtLastChipValue();
            this.filterChips();
        }
        onInput(event) {
            void this.openDrawer();
            this.cleanup();
            this.filterChips();
        }
        cleanup(focus = true) {
            const ranges = this.getRanges();
            const tokens = this.getTokens();
            const selection = document.getSelection();
            selection.removeAllRanges();
            this.input.removeContents();
            this.filterer.reset();
            const rangeElements = ranges.map(() => new Range());
            let lastEnd = -1;
            for (const token of tokens) {
                if (this.input.element.childNodes.length)
                    // space between tokens
                    this.input.element.appendChild(document.createTextNode(" "));
                // handle range being in whitespace
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i];
                    for (let ri = 0; ri < 2; ri++) {
                        if (range[ri] <= token.start && range[ri] > lastEnd) {
                            rangeElements[i][ri === 0 ? "setStart" : "setEnd"](this.input.element.lastChild ?? this.input.element, this.input.element.lastChild ? 1 : 0);
                        }
                    }
                }
                const raw = token.raw ?? token.text;
                if (raw[0] === "-") {
                    token.text = `!${token.text.slice(1)}`;
                    if (token.raw)
                        token.raw = `!${token.raw.slice(1)}`;
                }
                const filter = this.filterer.add(raw);
                if (!filter)
                    continue;
                const valueRaw = token.text.slice(filter.prefix.length);
                const value = Strings_4.default.extractFromQuotes(valueRaw).toLowerCase();
                const forceAddQuotes = valueRaw.length > value.length;
                let textNode;
                Component_51.default.create("span")
                    .classes.add(ItemFilterClasses.FilterChip, ItemFilterClasses.FilterChipPrefix)
                    .classes.toggle(filter.id === Filter_1.default.Raw, ItemFilterClasses.FilterChipRaw)
                    .style.set("--colour", Filter_1.IFilter.colour(value, filter.colour))
                    .append(textNode = document.createTextNode(filter.prefix))
                    .appendTo(this.input);
                // handle range being in prefix
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i];
                    for (let ri = 0; ri < 2; ri++) {
                        if (range[ri] >= token.start && range[ri] <= token.start + filter.prefix.length) {
                            rangeElements[i][ri === 0 ? "setStart" : "setEnd"](textNode, range[ri] - token.start);
                        }
                    }
                }
                const icon = Filter_1.IFilter.icon(value, filter.icon);
                const maskIcon = Filter_1.IFilter.icon(value, filter.maskIcon);
                const usedIcon = icon ?? maskIcon;
                Component_51.default.create("span")
                    .classes.add(ItemFilterClasses.FilterChip, ItemFilterClasses.FilterChipValue)
                    .classes.add(`${ItemFilterClasses.FilterId}-${filter.internalName}`)
                    .classes.toggle(filter.id === Filter_1.default.Raw, ItemFilterClasses.FilterChipRaw)
                    .classes.toggle(icon !== undefined, ItemFilterClasses.FilterChipValueHasIcon)
                    .classes.toggle(maskIcon !== undefined, ItemFilterClasses.FilterChipValueHasMaskIcon)
                    .style.set("--colour", Filter_1.IFilter.colour(value, filter.colour))
                    .style.set("--icon", typeof usedIcon === "string" ? usedIcon : undefined)
                    .tweak(async (valueSpan) => Array.isArray(usedIcon)
                    && !await EnumIcon_7.default.applyIconVar(valueSpan, ...usedIcon)
                    && valueSpan.classes.remove(ItemFilterClasses.FilterChipValueHasIcon, ItemFilterClasses.FilterChipValueHasMaskIcon))
                    .append(textNode = document.createTextNode(forceAddQuotes || value.includes(" ") ? `"${value}"` : value))
                    .appendTo(this.input);
                // handle range being in value
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i];
                    for (let ri = 0; ri < 2; ri++) {
                        if (range[ri] >= token.start + filter.prefix.length && range[ri] <= token.end) {
                            rangeElements[i][ri === 0 ? "setStart" : "setEnd"](textNode, Math.min(range[ri] - (token.start + filter.prefix.length), textNode.length));
                        }
                    }
                }
                lastEnd = token.end;
            }
            if (this.input.element.textContent?.trim())
                this.input.element.appendChild(document.createTextNode("\xa0"));
            // handle range being in whitespace after all tokens
            if (this.input.element.lastChild)
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i];
                    for (let ri = 0; ri < 2; ri++) {
                        if (range[ri] > lastEnd) {
                            rangeElements[i][ri === 0 ? "setStart" : "setEnd"](this.input.element.lastChild, 1);
                        }
                    }
                }
            if (focus) {
                if (!tokens.length)
                    selection.collapse(this.input.element);
                else
                    for (const range of rangeElements) {
                        if (range.startContainer === document || range.endContainer === document)
                            continue;
                        selection.addRange(range);
                    }
            }
            this.resetButton.classes.toggle(!tokens.length, Classes_14.Classes.Hidden);
            Store_14.default.items.itemFilter = this.input.element.textContent ?? "";
            if (this.filterer.hasChanged())
                this.event.emit("filter");
        }
        getEditingChip() {
            const selection = this.lastSelectionRange ?? document.getSelection()?.getRangeAt(0);
            const currentInputChip = !selection?.collapsed ? undefined
                : (selection.startContainer?.nodeType === Node.TEXT_NODE ? selection.startContainer.parentElement : selection.startContainer)
                    ?.closest(`.${ItemFilterClasses.FilterChip}`);
            const prefix = currentInputChip?.classList.contains(ItemFilterClasses.FilterChipPrefix) ? currentInputChip : currentInputChip?.previousElementSibling;
            const value = currentInputChip?.classList.contains(ItemFilterClasses.FilterChipValue) ? currentInputChip : currentInputChip?.nextElementSibling;
            return prefix ? {
                prefix,
                value,
            } : undefined;
        }
        filterChips() {
            this.currentSelection?.classes.remove(ItemFilterClasses.FilterChipButtonSelected, Button_13.ButtonClasses.Selected);
            delete this.currentSelection;
            const editingChip = this.getEditingChip();
            const currentChips = this.filterer.getFilterIds();
            const prefix = editingChip?.prefix.textContent ?? "";
            const value = Strings_4.default.extractFromQuotes(editingChip?.value?.textContent);
            const id = `${prefix}${value}`;
            const words = !value ? [] : value.toLowerCase().split(/\s+/g);
            for (const chip of this.suggestedChips) {
                if (currentChips.includes(chip.id)) {
                    chip.hide();
                    continue;
                }
                if (chip.isHint) {
                    chip.toggle(!id || chip.id.startsWith(id) && id.length < chip.prefix.length);
                    continue;
                }
                const wordsInChip = () => words.every(word => chip.searchableValue.includes(` ${word}`));
                if (chip.shouldHideByDefault)
                    chip.toggle(!!id && (!prefix && !!words.length && (wordsInChip() || chip.prefix.startsWith(id)) || id.startsWith(chip.prefix) && wordsInChip()));
                else
                    chip.toggle(!id || (!prefix && !!words.length && (wordsInChip() || chip.prefix.startsWith(id)) || id.startsWith(chip.prefix) && wordsInChip()));
            }
        }
        getTokens() {
            const text = `${this.input.element.textContent ?? ""} `; // end text in a space so it ends the last token the same way
            const tokens = [];
            let start = -1;
            for (let i = 0; i < text.length; i++) {
                const isWhitespace = text[i] === " " || text[i] === "\xa0" || text[i] === "\t" || text[i] === "\n" || text[i] === "\r";
                if (start === -1) {
                    // not in token
                    if (!isWhitespace)
                        start = i;
                }
                else {
                    // in token
                    if (isWhitespace) {
                        const tokenText = text.slice(start, i);
                        tokens.push({
                            text: tokenText,
                            raw: tokenText.replace(/["'`[\]()]/g, "")
                                .replace(/[\s\n\r]+/g, " ")
                                .trim(),
                            start,
                            end: i,
                        });
                        start = -1;
                    }
                }
                if (start !== -1 && text[i] in QUOTES) {
                    const quote = QUOTES[text[i]];
                    // upon entering a quote, continue until reaching the end quote
                    const textEndingInQuote = `${this.input.element.textContent ?? ""}${quote}`;
                    for (i++; i < textEndingInQuote.length; i++)
                        if (textEndingInQuote[i] === quote)
                            break;
                    if (i === textEndingInQuote.length - 1)
                        i--;
                }
            }
            return tokens;
        }
        getRanges() {
            let i = 0;
            const selection = document.getSelection();
            const rangePositions = [];
            for (const node of this.input.element.childNodes) {
                let length = 0;
                switch (node.nodeType) {
                    case Node.TEXT_NODE: {
                        length = node.length;
                        break;
                    }
                    case Node.ELEMENT_NODE: {
                        length = node.textContent?.length ?? 0;
                        break;
                    }
                }
                for (let ri = 0; ri < selection.rangeCount; ri++) {
                    rangePositions[ri] ??= [-1, -1];
                    const range = selection.getRangeAt(ri);
                    if (range.startContainer === node || range.startContainer === node.firstChild)
                        rangePositions[ri][0] = i + range.startOffset;
                    if (range.endContainer === node || range.endContainer === node.firstChild)
                        rangePositions[ri][1] = i + range.endOffset;
                }
                i += length;
            }
            return rangePositions.filter(([start, end]) => start !== -1 && end !== -1);
        }
        setCursorAtEnd(node) {
            const selection = document.getSelection();
            selection?.removeAllRanges();
            const range = new Range();
            range.selectNodeContents(node ?? this.input.element);
            range.collapse();
            selection?.addRange(range);
        }
        setCursorAtLastChipValue() {
            this.setCursorAtEnd(this.input.element.querySelector(`.${ItemFilterClasses.FilterChipValue}:last-child`));
        }
    }
    exports.default = ItemFilter;
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "reset", null);
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "openDrawer", null);
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "onFocusOut", null);
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "onSelectionChange", null);
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "onGlobalKeydown", null);
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "onPaste", null);
    __decorate([
        Bound_20.default
    ], ItemFilter.prototype, "onInput", null);
});
define("ui/destiny/filter/Filter", ["require", "exports", "utility/Arrays"], function (require, exports, Arrays_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IFilter = void 0;
    var Filter;
    (function (Filter) {
        Filter[Filter["Element"] = 0] = "Element";
        Filter[Filter["WeaponType"] = 1] = "WeaponType";
        Filter[Filter["Perk"] = 2] = "Perk";
        Filter[Filter["Ammo"] = 3] = "Ammo";
        Filter[Filter["BreakerType"] = 4] = "BreakerType";
        Filter[Filter["Rarity"] = 5] = "Rarity";
        Filter[Filter["Artifice"] = 6] = "Artifice";
        Filter[Filter["Masterwork"] = 7] = "Masterwork";
        Filter[Filter["Adept"] = 8] = "Adept";
        Filter[Filter["Shaped"] = 9] = "Shaped";
        Filter[Filter["Pattern"] = 10] = "Pattern";
        Filter[Filter["Enhancement"] = 11] = "Enhancement";
        Filter[Filter["Unlevelled"] = 12] = "Unlevelled";
        Filter[Filter["Catalyst"] = 13] = "Catalyst";
        Filter[Filter["Moment"] = 14] = "Moment";
        Filter[Filter["Duplicate"] = 15] = "Duplicate";
        Filter[Filter["Acquired"] = 16] = "Acquired";
        Filter[Filter["Locked"] = 17] = "Locked";
        Filter[Filter["Featured"] = 18] = "Featured";
        Filter[Filter["Raw"] = 19] = "Raw";
    })(Filter || (Filter = {}));
    exports.default = Filter;
    var IFilter;
    (function (IFilter) {
        function create(filter) {
            return filter;
        }
        IFilter.create = create;
        function createBoolean(filter) {
            return ["is:", "not:"].map(prefix => ({
                ...filter,
                prefix,
                apply: prefix === "not:" ? (filterValue, item) => !filter.apply(filterValue, item)
                    : (filterValue, item) => filter.apply(filterValue, item),
            }));
        }
        IFilter.createBoolean = createBoolean;
        function async(filterGenerator) {
            return filterGenerator;
        }
        IFilter.async = async;
        function colour(value, colour) {
            if (colour === undefined)
                return undefined;
            if (typeof colour === "function")
                colour = colour(value);
            if (typeof colour === "string")
                return colour;
            return `#${colour.toString(16).padStart(6, "0")}`;
        }
        IFilter.colour = colour;
        function icon(value, icon) {
            if (typeof icon === "function")
                icon = icon(value);
            if (icon === undefined)
                return undefined;
            if (typeof icon === "string")
                return icon;
            if (Array.isArray(icon))
                return icon;
            return Arrays_9.default.tuple(icon, value);
        }
        IFilter.icon = icon;
    })(IFilter || (exports.IFilter = IFilter = {}));
});
define("ui/destiny/filter/filters/FilterAcquired", ["require", "exports", "model/models/ProfileBatch", "model/models/items/Collectibles", "model/models/items/Item", "ui/destiny/filter/Filter"], function (require, exports, ProfileBatch_8, Collectibles_3, Item_4, Filter_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_2.IFilter.createBoolean({
        id: Filter_2.default.Acquired,
        colour: 0xAAAAAA,
        suggestedValues: ["acquired"],
        matches: value => "acquired".startsWith(value) || "obtained".startsWith(value),
        apply: (value, item) => value === ""
            || Collectibles_3.default.isAcquired(ProfileBatch_8.default.latest, item.definition.collectibleHash)
            || (item instanceof Item_4.default && !item.isNotAcquired()),
    });
});
define("ui/destiny/filter/filters/FilterAdept", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_3.IFilter.createBoolean({
        id: Filter_3.default.Adept,
        colour: 0xFFB21C,
        suggestedValues: ["adept"],
        matches: value => "adept".startsWith(value),
        apply: (value, item) => value === "" || !!item.isAdept(),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/adept.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterAmmo", ["require", "exports", "ui/destiny/filter/Filter", "ui/utility/DisplayProperties"], function (require, exports, Filter_4, DisplayProperties_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_4.IFilter.create({
        id: Filter_4.default.Ammo,
        prefix: "ammo:",
        colour: 0x444444,
        suggestedValues: ["primary", "special"],
        or: true,
        matches: value => "primary".startsWith(value) || "special".startsWith(value) || "heavy".startsWith(value),
        apply: (value, item) => value === ""
            || item.definition.equippingBlock?.ammoType === ("primary".startsWith(value) ? 1 /* DestinyAmmunitionType.Primary */
                : "special".startsWith(value) ? 2 /* DestinyAmmunitionType.Special */
                    : 3 /* DestinyAmmunitionType.Heavy */),
        icon: value => value === "" ? undefined
            : DisplayProperties_10.default.icon(`/img/destiny_content/ammo_types/${"primary".startsWith(value) ? "primary" : "special".startsWith(value) ? "special" : "heavy"}.png`),
    });
});
define("ui/destiny/filter/filters/FilterArtifice", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_5.IFilter.createBoolean({
        id: Filter_5.default.Artifice,
        colour: 0x817C7C,
        suggestedValues: ["artifice"],
        matches: value => "artifice".startsWith(value),
        apply: (value, item) => value === "" || !!item.isArtifice(),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/artifice.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterBreakerType", ["require", "exports", "model/models/enum/BreakerTypes", "ui/destiny/filter/Filter"], function (require, exports, BreakerTypes_4, Filter_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_6.IFilter.async(async () => {
        return Promise.resolve({
            id: Filter_6.default.BreakerType,
            prefix: "stun:",
            colour: 0x620d4c,
            suggestedValues: ["", "overload", "barrier", "unstoppable"],
            or: true,
            apply: (value, item) => {
                const breakerType = value === "" ? 0 /* DestinyBreakerType.None */
                    : "overload".startsWith(value) || "disruption".startsWith(value) ? 2 /* DestinyBreakerType.Disruption */
                        : "unstoppable".startsWith(value) || "stagger".startsWith(value) ? 3 /* DestinyBreakerType.Stagger */
                            : "barrier".startsWith(value) || "shield piercing".startsWith(value) ? 1 /* DestinyBreakerType.ShieldPiercing */
                                : 0 /* DestinyBreakerType.None */;
                if (!breakerType)
                    return !!item.breakerTypes?.length;
                return !!item.breakerTypes?.some(type => type.enumValue === breakerType);
            },
            icon: value => [
                BreakerTypes_4.default,
                value === "" ? undefined
                    : "overload".startsWith(value) || "disruption".startsWith(value) ? 2 /* DestinyBreakerType.Disruption */
                        : "unstoppable".startsWith(value) || "stagger".startsWith(value) ? 3 /* DestinyBreakerType.Stagger */
                            : "barrier".startsWith(value) || "shield piercing".startsWith(value) ? 1 /* DestinyBreakerType.ShieldPiercing */
                                : undefined,
            ],
        });
    });
});
define("ui/destiny/filter/filters/FilterCatalyst", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const defaultState = 16 /* DestinyRecordState.Invisible */ | 8 /* DestinyRecordState.Obscured */ | 4 /* DestinyRecordState.ObjectiveNotCompleted */;
    exports.default = Filter_7.IFilter.create({
        id: Filter_7.default.Catalyst,
        prefix: "catalyst:",
        colour: 0xCEAE33,
        suggestedValues: ["incomplete", "unacquired", "complete"],
        apply: (value, item) => value === ""
            || ("none".startsWith(value) && !item.catalyst)
            || ("unacquired".startsWith(value) && !!((item.catalyst?.state.state ?? defaultState) & 8 /* DestinyRecordState.Obscured */))
            || ("acquired".startsWith(value) && !((item.catalyst?.state.state ?? defaultState) & 8 /* DestinyRecordState.Obscured */))
            || ("incomplete".startsWith(value) && !((item.catalyst?.state.state ?? defaultState) & 8 /* DestinyRecordState.Obscured */) && !item.catalyst?.complete)
            || ("complete".startsWith(value) && !!item.catalyst?.complete),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/masterwork.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterDuplicate", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_8.IFilter.createBoolean({
        id: Filter_8.default.Duplicate,
        colour: 0x555555,
        suggestedValues: ["duplicate"],
        matches: value => "dupe".startsWith(value) || "duplicate".startsWith(value),
        apply: (value, item) => value === ""
            || !!inventory?.getItems(i => i.id !== item.id && i.getBaseName() === item.getBaseName()).length,
    });
});
define("ui/destiny/filter/filters/FilterElement", ["require", "exports", "model/models/Manifest", "ui/destiny/filter/Filter", "ui/destiny/utility/ElementTypes", "ui/utility/DisplayProperties"], function (require, exports, Manifest_19, Filter_9, ElementTypes_2, DisplayProperties_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const DAMAGE_TYPE_RAID = 1067729826;
    const ENERGY_TYPE_ANY = 1198124803;
    const ENERGY_TYPE_GHOST = 3340383460;
    const ENERGY_TYPE_SUBCLASS = 3440230265;
    exports.default = Filter_9.IFilter.async(async () => {
        const { DestinyDamageTypeDefinition, DestinyEnergyTypeDefinition } = await Manifest_19.default.await();
        const damages = (await DestinyDamageTypeDefinition.all())
            .filter(type => type.hash !== DAMAGE_TYPE_RAID)
            .sort((a, b) => a.enumValue - b.enumValue);
        const energies = (await DestinyEnergyTypeDefinition.all())
            .filter(type => type.hash !== ENERGY_TYPE_ANY && type.hash !== ENERGY_TYPE_GHOST && type.hash !== ENERGY_TYPE_SUBCLASS)
            .sort((a, b) => a.enumValue - b.enumValue);
        function definition(value, itemOrPlug) {
            if (!itemOrPlug || "id" in itemOrPlug)
                return itemDefinition(value, itemOrPlug);
            return plugDefinition(value, itemOrPlug);
        }
        function itemDefinition(value, item) {
            if (value === "")
                return null;
            const damageTypeHash = item?.instance?.damageTypeHash ?? item?.definition.defaultDamageTypeHash;
            const resultDamages = damages.filter(element => element.displayProperties.name.toLowerCase().startsWith(value)
                && (!item || element.hash === damageTypeHash));
            if (resultDamages.length === 1)
                return resultDamages[0];
            if (resultDamages.length > 1)
                return null;
            const resultEnergies = energies.filter(element => element.displayProperties.name.toLowerCase().startsWith(value)
                && (!item || element.hash === item.instance?.energy?.energyTypeHash));
            if (resultEnergies.length === 1)
                return resultEnergies[0];
            if (resultEnergies.length > 1)
                return null;
            return undefined;
        }
        function plugDefinition(value, plug) {
            if (plug.categorisation?.category === 4 /* DeepsightPlugCategory.Subclass */) {
                const damageType = plug.categorisation.damageType;
                if (!damageType)
                    return null;
                const resultDamages = damages.filter(element => element.displayProperties.name.toLowerCase().startsWith(value)
                    && (element.hash === damageType));
                if (resultDamages.length === 1)
                    return resultDamages[0];
                if (resultDamages.length > 1)
                    return null;
                return undefined;
            }
        }
        return {
            id: Filter_9.default.Element,
            prefix: "element:",
            suggestedValues: damages.map(element => element.displayProperties.name.toLowerCase()),
            or: true,
            matches: value => damages.some(element => element.displayProperties.name.toLowerCase().startsWith(value)),
            apply: (value, item) => definition(value, item) !== undefined,
            colour: value => ElementTypes_2.default.getColour(definition(value)?.displayProperties.name.toLowerCase()) ?? 0xaaaaaa,
            maskIcon: value => DisplayProperties_11.default.icon(definition(value) ?? undefined),
        };
    });
});
define("ui/destiny/filter/filters/FilterEnhance", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_10.IFilter.createBoolean({
        id: Filter_10.default.Enhancement,
        colour: 0xE3513C,
        suggestedValues: ["enhancement"],
        matches: value => "enhancement".startsWith(value),
        apply: (value, item) => value === "" || (!!item.canEnhance() && !item.isMasterwork()),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/enhanced.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterFeatured", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_11.IFilter.createBoolean({
        id: Filter_11.default.Featured,
        colour: 0x19afaf,
        suggestedValues: ["featured"],
        matches: value => "featured".startsWith(value),
        apply: (value, item) => value === ""
            || item.definition.isFeaturedItem,
        // maskIcon: value => value === "" ? undefined
        // 	: "url(\"./image/svg/lock.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterLocked", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_12.IFilter.createBoolean({
        id: Filter_12.default.Locked,
        colour: 0xAAAAAA,
        suggestedValues: ["locked"],
        matches: value => "locked".startsWith(value),
        apply: (value, item) => value === ""
            || item.isLocked()
            || item.isChangingLockState(),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/lock.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterMasterwork", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_13.IFilter.createBoolean({
        id: Filter_13.default.Masterwork,
        colour: 0xd4b73c,
        suggestedValues: ["masterwork"],
        matches: value => "masterwork".startsWith(value),
        apply: (value, item) => value === ""
            || item.isMasterwork()
            || item.definition.hash === 4257549985 // asc shard
            || item.definition.hash === 4257549984 // enc prism
            || item.definition.hash === 3853748946 // enc core
            || item.definition.hash === 2979281381 // upg module
            || item.definition.hash === 353704689, // asc alloy
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/masterwork.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterMoment", ["require", "exports", "model/models/Manifest", "ui/destiny/filter/Filter", "ui/utility/DisplayProperties"], function (require, exports, Manifest_20, Filter_14, DisplayProperties_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_14.IFilter.async(async () => {
        const { DeepsightMomentDefinition: DeepsightSourceDefinition } = await Manifest_20.default.await();
        const sources = (await DeepsightSourceDefinition.all())
            .sort((a, b) => b.hash - a.hash);
        function momentMatches(moment, value) {
            moment.displayProperties.nameLowerCase ??= moment.displayProperties.name?.toLowerCase();
            return moment.displayProperties.nameLowerCase?.startsWith(value)
                || moment.id.startsWith(value);
        }
        function getAllMatches(value) {
            return sources.filter(source => momentMatches(source, value));
        }
        return {
            id: Filter_14.default.Moment,
            prefix: "moment:",
            colour: 0x3B3287,
            suggestedValueHint: "expansion, season, or event",
            suggestedValues: sources.map(source => DisplayProperties_12.default.name(source) ?? source.id),
            or: true,
            apply: (value, item) => !item.moment ? false : momentMatches(item.moment, value),
            maskIcon: value => {
                if (!value)
                    return undefined;
                const matches = getAllMatches(value.toLowerCase());
                if (matches.length !== 1)
                    return undefined;
                const icon = matches[0].iconWatermark;
                return `url("${icon?.startsWith("/") ? `https://www.bungie.net${icon}` : icon}")`;
            },
        };
    });
});
define("ui/destiny/filter/filters/FilterPattern", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_15.IFilter.create({
        id: Filter_15.default.Pattern,
        prefix: "pattern:",
        colour: 0xCC2222,
        suggestedValues: ["available", "incomplete", "complete", "harmonizing"],
        apply: (value, item) => value === ""
            || ("available".startsWith(value) && !item.bucket.isCollections() && item.hasPattern())
            || ("harmonizing".startsWith(value) && (item.bucket.isCollections() ? item.hasPattern() : !!item.deepsight?.pattern && !item.deepsight.pattern.progress?.complete && item.deepsight.activation))
            || ("incomplete".startsWith(value) && !!item.deepsight?.pattern && !item.deepsight.pattern.progress?.complete)
            || ("complete".startsWith(value) && !!item.deepsight?.pattern?.progress?.complete)
            || ("none".startsWith(value) && !item.deepsight?.pattern),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/shaped.svg\")",
    });
});
define("ui/destiny/tooltip/item/ItemClarity", ["require", "exports", "model/models/enum/EnumModelMap", "ui/component/Component", "ui/destiny/component/EnumIcon", "ui/utility/Classes", "utility/Env", "utility/Strings"], function (require, exports, EnumModelMap_2, Component_52, EnumIcon_8, Classes_15, Env_6, Strings_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemClarityDefinitions = exports.ItemClarityClasses = void 0;
    var ItemClarityClasses;
    (function (ItemClarityClasses) {
        ItemClarityClasses["Main"] = "item-plug-tooltip-clarity";
        ItemClarityClasses["Title"] = "item-plug-tooltip-clarity-title";
        ItemClarityClasses["TitleName"] = "item-plug-tooltip-clarity-title-name";
        ItemClarityClasses["Logo"] = "item-plug-tooltip-clarity-logo";
        ItemClarityClasses["Description"] = "item-plug-tooltip-clarity-description";
        ItemClarityClasses["Body"] = "item-plug-tooltip-clarity-body";
        ItemClarityClasses["Line"] = "item-plug-tooltip-clarity-line";
        ItemClarityClasses["ListItem"] = "item-plug-tooltip-clarity-list-item";
        ItemClarityClasses["Spacer"] = "item-plug-tooltip-clarity-spacer";
        ItemClarityClasses["Label"] = "item-plug-tooltip-clarity-label";
        ItemClarityClasses["LabelInline"] = "item-plug-tooltip-clarity-label-inline";
        ItemClarityClasses["Numeric"] = "item-plug-tooltip-clarity-numeric";
        ItemClarityClasses["NumericUnknown"] = "item-plug-tooltip-clarity-numeric-unknown";
        ItemClarityClasses["Estimate"] = "item-plug-tooltip-clarity-estimate";
        ItemClarityClasses["StackSizeSeparator"] = "item-plug-tooltip-clarity-stack-size-separator";
        ItemClarityClasses["EnhancedArrow"] = "item-plug-tooltip-clarity-enhanced-arrow";
        ItemClarityClasses["EnhancedLine"] = "item-plug-tooltip-clarity-enhanced-line";
        ItemClarityClasses["Table"] = "item-plug-tooltip-clarity-table";
        ItemClarityClasses["Table_IsFirstColumnAllLabels"] = "item-plug-tooltip-clarity-table_is-first-column-all-labels";
        ItemClarityClasses["TableRow"] = "item-plug-tooltip-clarity-table-row";
        ItemClarityClasses["TableCell"] = "item-plug-tooltip-clarity-table-cell";
        ItemClarityClasses["TableCellNumeric"] = "item-plug-tooltip-clarity-table-cell-numeric";
        ItemClarityClasses["TableCellText"] = "item-plug-tooltip-clarity-table-cell-text";
        ItemClarityClasses["PVE"] = "item-plug-tooltip-clarity-pve";
        ItemClarityClasses["PVP"] = "item-plug-tooltip-clarity-pvp";
        ItemClarityClasses["PVEVP"] = "item-plug-tooltip-clarity-pvevp";
        ItemClarityClasses["LabelPVEVP"] = "item-plug-tooltip-clarity-label-pvevp";
        ItemClarityClasses["LabelPVE"] = "item-plug-tooltip-clarity-label-pve";
        ItemClarityClasses["LabelPVP"] = "item-plug-tooltip-clarity-label-pvp";
        ItemClarityClasses["Definitions"] = "item-plug-tooltip-clarity-definitions";
        ItemClarityClasses["Definition"] = "item-plug-tooltip-clarity-definition";
        ItemClarityClasses["DefinitionName"] = "item-plug-tooltip-clarity-definition-name";
        ItemClarityClasses["DefinitionNameIndex"] = "item-plug-tooltip-clarity-definition-name-index";
    })(ItemClarityClasses || (exports.ItemClarityClasses = ItemClarityClasses = {}));
    class ItemClarity extends Component_52.default {
        get isPresent() {
            return !this.classes.has(Classes_15.Classes.Hidden);
        }
        onMake() {
            this.classes.add(ItemClarityClasses.Main);
            const title = Component_52.default.create()
                .classes.add(ItemClarityClasses.Title)
                .appendTo(this);
            Component_52.default.create("img")
                .classes.add(ItemClarityClasses.Logo)
                .attributes.set("src", "https://avatars.githubusercontent.com/u/117947315?s=48&v=4")
                .appendTo(title);
            Component_52.default.create("span")
                .classes.add(ItemClarityClasses.TitleName)
                .text.set("Clarity")
                .appendTo(title);
            title.text.add(" / Community Insights");
            this.description = Component_52.default.create()
                .classes.add(ItemClarityClasses.Body)
                .appendTo(this);
        }
        set(clarityDescription) {
            this.classes.add(Classes_15.Classes.Hidden);
            this.description.removeContents();
            if (!clarityDescription?.descriptions.en?.length)
                return false;
            this.classes.remove(Classes_15.Classes.Hidden);
            appendClarityDescriptionComponents(this.description, clarityDescription.descriptions.en, { index: 0 });
            return true;
        }
    }
    exports.default = ItemClarity;
    class ItemClarityDefinitions extends Component_52.default {
        get isPresent() {
            return !this.classes.has(Classes_15.Classes.Hidden);
        }
        onMake() {
            this.classes.add(ItemClarityClasses.Definitions);
        }
        set(clarityDescription) {
            this.classes.add(Classes_15.Classes.Hidden);
            this.removeContents();
            let definitions;
            // eslint-disable-next-line prefer-const
            definitions = extractDefinitions(clarityDescription?.descriptions.en);
            if (!definitions?.length)
                return false;
            // uncomment to test multiple definitions
            // definitions = [...definitions.slice(), ...definitions.slice()];
            this.classes.remove(Classes_15.Classes.Hidden);
            for (let i = 0; i < definitions.length; i++) {
                const definition = definitions[i];
                Component_52.default.create()
                    .classes.add(ItemClarityClasses.Definition)
                    .classes.add(...classNames(definition))
                    .append(Component_52.default.create("p")
                    .classes.add(ItemClarityClasses.DefinitionName)
                    .append(Component_52.default.create("sup")
                    .classes.add(ItemClarityClasses.DefinitionNameIndex)
                    .text.set(`${i + 1}`))
                    .text.add(definition.text ?? ""))
                    .tweak(appendClarityDescriptionComponents, definition.title, { index: 0 })
                    .appendTo(this);
            }
        }
    }
    exports.ItemClarityDefinitions = ItemClarityDefinitions;
    function appendClarityDescriptionComponents(parent, content, definitionIndex, parentClassNames) {
        if (typeof content === "string")
            content = [{ text: content }];
        for (let i = 0; i < content.length; i++) {
            let component = content[i];
            const singleChild = component.linesContent?.length === 1 ? component.linesContent?.[0] : undefined;
            if (component.formula || singleChild?.formula)
                // can't render formulas
                continue;
            const isLast = i >= content.length - 1 || content.slice(i + 1).every(component => component.classNames?.includes("spacer") || component.formula || (component.linesContent?.length === 1 && component.linesContent[0].formula));
            const isLine = !!component.linesContent?.length;
            const isLabel = isLine && extractText(component.linesContent[component.linesContent.length - 1]).trimEnd().endsWith(":");
            const isListItem = isLine && extractText(component.linesContent[0]).trimStart().startsWith(" ");
            const isLabelledLine = isLine && Strings_5.default.includesOnce(extractText(component), ": ");
            const isEnhancedEffect = isLine && isLast && extractText(component.linesContent[0]).trimStart().startsWith("");
            const isEnhancedArrow = component.classNames?.includes("enhancedArrow") ?? false;
            const isSpacer = component.classNames?.includes("spacer") ?? false;
            const isPVE = !parentClassNames?.includes("pve") && (component.classNames?.includes("pve") || singleChild?.classNames?.includes("pve") || false);
            const isPVP = !parentClassNames?.includes("pvp") && (component.classNames?.includes("pvp") || singleChild?.classNames?.includes("pvp") || false);
            const imageDef = component.classNames?.map(className => EnumModelMap_2.default[className]).find(def => def);
            if (imageDef) {
                EnumIcon_8.default.create(imageDef)
                    .appendTo(parent);
                continue;
            }
            if (isPVE || isPVP)
                component = trimTextMatchingFromStart(component, "[PVE] ", "[PVP] ", "[PVE]", "[PVP]", "[PvE] ", "[PvP] ", "[PvE]", "[PvP]");
            const element = Component_52.default.create(isLine ? "div" : isSpacer ? "br" : component.table?.length ? "div" : "span")
                .classes.toggle(isLine, ItemClarityClasses.Line)
                .classes.toggle(isListItem, ItemClarityClasses.ListItem)
                .classes.toggle(isSpacer, ItemClarityClasses.Spacer)
                .classes.toggle(isEnhancedEffect, ItemClarityClasses.EnhancedLine)
                .classes.toggle(isLabel, ItemClarityClasses.Label)
                .classes.toggle(isEnhancedArrow, ItemClarityClasses.EnhancedArrow)
                .classes.toggle(!!component.table?.length, ItemClarityClasses.Table)
                .classes.toggle(isPVE, ItemClarityClasses.PVE)
                .classes.toggle(isPVP, ItemClarityClasses.PVP)
                .classes.toggle(isPVE || isPVP, ItemClarityClasses.PVEVP)
                .classes.toggle(!!component.title, ItemClarityClasses.DefinitionName)
                .classes.add(...isLine ? [ItemClarityClasses.Line] : [], ...classNames(component))
                .append(!isPVE && !isPVP ? undefined : Component_52.default.create("span")
                .classes.add(ItemClarityClasses.LabelPVEVP, isPVE ? ItemClarityClasses.LabelPVE : ItemClarityClasses.LabelPVP)
                .text.set(isPVE ? "PVE" : "PVP"))
                .tweak(appendClarityText, isEnhancedArrow ? "" : component.text ?? "", component.classNames ?? [], isPVP || isPVE)
                .tweak(appendClarityDescriptionComponents, isLabelledLine ? [] : component.linesContent ?? [], definitionIndex, [...isPVE ? ["pve"] : [], ...isPVP ? ["pvp"] : [], ...isListItem ? ["list-item"] : []])
                .tweak(appendClarityTableRowComponents, component.table ?? [], definitionIndex)
                .tweak(appendClarityLabelledLineComponents, !isLabelledLine ? [] : component.linesContent, definitionIndex)
                .append(!component.title ? undefined : Component_52.default.create("sup")
                .classes.add(ItemClarityClasses.DefinitionNameIndex)
                .text.set(`${++definitionIndex.index}`));
            if (element.element.childNodes.length || element.element.classList.length)
                element.appendTo(parent);
        }
    }
    function appendClarityTableRowComponents(parent, rows, definitionIndex) {
        for (let c = 0; c < (rows[0]?.rowContent.length ?? 0); c++) {
            // delete columns where all rows (which aren't the first label row) are empty or a dash
            const shouldDeleteColumn = rows.every((row, i) => {
                const columnText = extractText(row.rowContent[c].cellContent).trim();
                return !columnText || columnText === "-" || (!i && !parseFloat(columnText));
            });
            if (shouldDeleteColumn) {
                rows = rows.map((row) => ({
                    ...row,
                    rowContent: row.rowContent.filter((cell, i) => i !== c),
                }));
            }
            if (!c && !shouldDeleteColumn) {
                // make a note of tables where the first column of every row is a label (or empty)
                const isFirstColumnAllLabels = rows.every((row, i) => {
                    const columnText = extractText(row.rowContent[c].cellContent).trim();
                    return !columnText || (!parseFloat(columnText) && !nonNumericNumberRegex.test(columnText));
                });
                parent.classes.toggle(isFirstColumnAllLabels, ItemClarityClasses.Table_IsFirstColumnAllLabels);
            }
        }
        for (const row of rows) {
            Component_52.default.create()
                .classes.add(ItemClarityClasses.TableRow, ...classNames(row))
                .tweak(appendClarityTableCellComponents, row.rowContent, definitionIndex)
                .appendTo(parent);
        }
    }
    const empy = [];
    function classNames(component) {
        return Env_6.default.DEEPSIGHT_ENVIRONMENT === "dev" ? component.classNames?.map(c => `-clarity-${c}`) ?? empy : empy;
    }
    function appendClarityTableCellComponents(parent, cells, definitionIndex) {
        for (const cell of cells) {
            const cellContent = extractText(cell.cellContent).trim();
            const isNumeric = !isNaN(parseFloat(cellContent)) || nonNumericNumberRegex.test(cellContent.replace(unknownValueBracketsRegex, "?"));
            Component_52.default.create()
                .classes.add(ItemClarityClasses.TableCell, ...classNames(cell))
                .classes.toggle(isNumeric, ItemClarityClasses.TableCellNumeric)
                .classes.toggle(!isNumeric, ItemClarityClasses.TableCellText)
                .tweak(appendClarityDescriptionComponents, cellContent === "-" ? [] : cell.cellContent, definitionIndex)
                .appendTo(parent);
        }
    }
    /**
     * Splits description content by `: `, wrapping the label section in an element to be styled.
     * This only detects `: ` instances in the `text` property in this level.
     * If no `: ` was detected all content is appended directly to the parent.
     */
    function appendClarityLabelledLineComponents(parent, content, definitionIndex) {
        const label = [];
        const value = [];
        let split = false;
        for (const component of content) {
            const sections = component.text?.split(": ");
            if (sections?.length === 2) {
                split = true;
                label.push({ ...component, text: sections[0] });
                value.push({ ...component, text: sections[1] });
            }
            else {
                (split ? value : label).push(component);
            }
        }
        if (!split) {
            appendClarityDescriptionComponents(parent, content, definitionIndex);
            return;
        }
        label.push({ text: ": " });
        Component_52.default.create("span")
            .classes.add(ItemClarityClasses.LabelInline)
            .tweak(appendClarityDescriptionComponents, label, definitionIndex)
            .appendTo(parent);
        appendClarityDescriptionComponents(parent, value, definitionIndex);
    }
    // use regular expressions to split out numbers, stack size separators `|`, and unknown values `(?)`
    const numericSplitNumericStart = /(?:(?<![\w\d.!+%-])|(?<=\d(?:st|nd|rd|th)-))(?=[x+-]?[.\d])/;
    const numericSplitUnknownStart = /(?<![\w\d.!+%-])(?=\?)/;
    const numericSplitNumericEnd = /(?<=[\d?][%x+]?\??)(?![\dx?%+.])/;
    const numericSplitRegex = Strings_5.default.mergeRegularExpressions("g", numericSplitNumericStart, numericSplitUnknownStart, numericSplitNumericEnd);
    const stackSizeSplitRegex = /(?=\|)|(?<=\|)/g;
    const unknownValueBracketsRegex = /\(\?\)|\[\?\]/g;
    const nonNumericNumberRegex = /^\?$|x[\d?]|[\d?](?:th|[%-])/;
    function appendClarityText(parent, text, classNames, isPVEVP) {
        text = Strings_5.default.trimTextMatchingFromStart(text, " ");
        if (isPVEVP)
            // pvp numeric values sometimes are wrapped in square brackets, we don't want them
            text = Strings_5.default.extractFromSquareBrackets(text);
        text = text.replace(unknownValueBracketsRegex, "?");
        const sections = text.split(numericSplitRegex);
        for (const section of sections) {
            if (!section)
                continue;
            const parsedFloat = !isNaN(parseFloat(Strings_5.default.trimTextMatchingFromStart(section, "x")));
            const nonNumericNumber = nonNumericNumberRegex.test(section);
            if (parsedFloat || nonNumericNumber) {
                Component_52.default.create("span")
                    .classes.add(ItemClarityClasses.Numeric)
                    .classes.toggle(nonNumericNumber, ItemClarityClasses.NumericUnknown)
                    .text.set(nonNumericNumber ? section
                    : Strings_5.default.trimTextMatchingFromEnd(section, "?"))
                    // sometimes numbers end in ? showing that it's an estimate, make that ? superscript
                    .append(nonNumericNumber || !section.endsWith("?") ? undefined
                    : Component_52.default.create("span")
                        .classes.add(ItemClarityClasses.Estimate)
                        .text.set("?"))
                    .appendTo(parent);
                continue;
            }
            const sections = section.split(stackSizeSplitRegex);
            for (const section of sections) {
                if (section.trim() === "|") {
                    Component_52.default.create("span")
                        .classes.add(ItemClarityClasses.StackSizeSeparator)
                        .text.set("/")
                        .appendTo(parent);
                    continue;
                }
                parent.text.add(section);
            }
        }
    }
    /**
     * Extracts text from description components.
     */
    function extractText(content) {
        content = typeof content === "string" ? [{ text: content }] : Array.isArray(content) ? content : [content];
        let result = "";
        for (const component of content) {
            result += component.text ?? "";
            if (component.linesContent?.length)
                result += extractText(component.linesContent);
        }
        return result;
    }
    function extractDefinitions(content) {
        if (Array.isArray(content))
            return content.flatMap(component => extractDefinitions(component.linesContent ?? component));
        return typeof content === "object" && content.text && content.title ? content : [];
    }
    function trimTextMatchingFromStart(content, ...matching) {
        if (!content)
            return undefined;
        if (typeof content === "string") {
            for (const text of matching)
                content = Strings_5.default.trimTextMatchingFromStart(content, text);
            return content;
        }
        if (Array.isArray(content)) {
            content = content.slice();
            content[0] = trimTextMatchingFromStart(content[0], ...matching);
            return content;
        }
        return {
            ...content,
            text: trimTextMatchingFromStart(content.text, ...matching),
            linesContent: trimTextMatchingFromStart(content.linesContent, ...matching),
        };
    }
});
define("ui/destiny/tooltip/ItemPlugTooltip", ["require", "exports", "model/models/enum/DamageTypes", "ui/component/Component", "ui/component/Hints", "ui/component/LoadedIcon", "ui/destiny/component/EnumIcon", "ui/destiny/tooltip/item/ItemClarity", "ui/utility/Classes", "ui/utility/DisplayProperties", "ui/utility/TooltipManager", "ui/utility/UiEventBus", "utility/Strings", "utility/decorator/Bound"], function (require, exports, DamageTypes_5, Component_53, Hints_3, LoadedIcon_5, EnumIcon_9, ItemClarity_1, Classes_16, DisplayProperties_13, TooltipManager_4, UiEventBus_6, Strings_6, Bound_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ItemPlugTooltipClasses;
    (function (ItemPlugTooltipClasses) {
        ItemPlugTooltipClasses["Main"] = "item-plug-tooltip";
        ItemPlugTooltipClasses["Content"] = "item-plug-tooltip-content";
        ItemPlugTooltipClasses["Image"] = "item-plug-tooltip-image";
        ItemPlugTooltipClasses["Description"] = "item-plug-tooltip-description";
        ItemPlugTooltipClasses["IsPerk"] = "item-plug-tooltip--perk";
        ItemPlugTooltipClasses["IsEnhanced"] = "item-plug-tooltip--enhanced";
        ItemPlugTooltipClasses["IsExotic"] = "item-plug-tooltip--exotic";
        ItemPlugTooltipClasses["IsDamageType"] = "item-plug-tooltip--damage-type";
        ItemPlugTooltipClasses["Perks"] = "item-plug-tooltip-perks";
        ItemPlugTooltipClasses["Perk"] = "item-plug-tooltip-perk";
        ItemPlugTooltipClasses["PerkIsDisabled"] = "item-plug-tooltip-perk--disabled";
        ItemPlugTooltipClasses["PerkIcon"] = "item-plug-tooltip-perk-icon";
        ItemPlugTooltipClasses["PerkIconIsStat"] = "item-plug-tooltip-perk-icon--stat";
        ItemPlugTooltipClasses["PerkDescription"] = "item-plug-tooltip-perk-description";
        ItemPlugTooltipClasses["Keyword"] = "item-plug-tooltip-keyword";
        ItemPlugTooltipClasses["Keywords"] = "item-plug-tooltip-keywords";
        ItemPlugTooltipClasses["KeywordIcon"] = "item-plug-tooltip-keyword-icon";
        ItemPlugTooltipClasses["KeywordName"] = "item-plug-tooltip-keyword-name";
        ItemPlugTooltipClasses["KeywordDescription"] = "item-plug-tooltip-keyword-description";
        ItemPlugTooltipClasses["ClarityURL"] = "item-plug-tooltip-clarity-url";
        ItemPlugTooltipClasses["Extra"] = "item-plug-tooltip-extra";
        ItemPlugTooltipClasses["ExtraHeader"] = "item-plug-tooltip-extra-header";
        ItemPlugTooltipClasses["ExtraContent"] = "item-plug-tooltip-extra-content";
    })(ItemPlugTooltipClasses || (ItemPlugTooltipClasses = {}));
    class ItemPlugTooltip extends TooltipManager_4.Tooltip {
        onMake() {
            this.classes.add(ItemPlugTooltipClasses.Main);
            this.content.classes.add(ItemPlugTooltipClasses.Content);
            this.image = LoadedIcon_5.default.create([])
                .classes.add(ItemPlugTooltipClasses.Image)
                .appendTo(this.content);
            this.description = Component_53.default.create()
                .classes.add(ItemPlugTooltipClasses.Description)
                .appendTo(this.content);
            this.perks = Component_53.default.create()
                .classes.add(ItemPlugTooltipClasses.Perks)
                .appendTo(this.content);
            this.clarity = ItemClarity_1.default.create()
                .insertToAfter(this, this.content);
            this.setScrollableComponent(this.clarity.description);
            this.hintShowDefinitions = Hints_3.Hint.create([Hints_3.IInput.get("KeyE")])
                .classes.add(Classes_16.Classes.ShowIfNotExtraInfo)
                .tweak(hint => hint.label.text.set("Show Definitions"))
                .appendTo(this.hints);
            Hints_3.Hint.create([Hints_3.IInput.get("MouseMiddle")])
                .tweak(hint => hint.label.text.add("Visit ")
                .append(Component_53.default.create("span")
                .classes.add(ItemPlugTooltipClasses.ClarityURL)
                .text.set("d2clarity.com")))
                .appendTo(this.hints);
            this.extra.classes.add(ItemPlugTooltipClasses.Extra);
            this.extra.header.classes.add(ItemPlugTooltipClasses.ExtraHeader);
            this.extra.content.classes.add(ItemPlugTooltipClasses.ExtraContent);
            this.keywords = ItemPlugKeywords.create()
                .appendTo(this.extra.content);
            this.clarityDefinitions = ItemClarity_1.ItemClarityDefinitions.create()
                .appendTo(this.extra.content);
            UiEventBus_6.default.subscribe("keyup", this.onGlobalKeyup);
        }
        set(plug, perk, item) {
            this.plug = plug;
            this.perk = perk;
            this.item = item;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.plug = plug;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.perk = perk;
            console.log(DisplayProperties_13.default.name(perk?.definition) ?? DisplayProperties_13.default.name(plug.definition), plug, perk);
            const damageType = plug.getCategorisationAs(4 /* DeepsightPlugCategory.Subclass */)?.damageType;
            this.classes.removeWhere(cls => cls.startsWith(ItemPlugTooltipClasses.IsDamageType))
                .classes.add(damageType && `${ItemPlugTooltipClasses.IsDamageType}-${DamageTypes_5.default.nameOf(damageType)}`);
            this.title.text.set(DisplayProperties_13.default.name(perk?.definition) ?? DisplayProperties_13.default.name(plug.definition));
            this.subtitle.removeContents();
            const keywords = [];
            const description = {
                character: item?.owner?.characterId,
            };
            this.subtitle.text.set(plug.is("=Masterwork/ExoticCatalyst") ? "Catalyst" : plug.definition?.itemTypeDisplayName ?? "Unknown");
            this.description.tweak(DisplayProperties_13.default.applyDescription, DisplayProperties_13.default.description(perk?.definition) ?? DisplayProperties_13.default.description(plug.definition), description);
            if (description.keywords)
                keywords.push(description.keywords);
            this.header.classes.toggle(plug.is("Perk"), ItemPlugTooltipClasses.IsPerk);
            this.header.classes.toggle(plug.is("=Masterwork/ExoticCatalyst") || plug.type.endsWith('Enhanced'), ItemPlugTooltipClasses.IsEnhanced);
            this.header.classes.toggle((plug.is("Intrinsic") || plug.is("=Masterwork/ExoticCatalyst")) && item?.definition.inventory?.tierTypeHash === 2759499571 /* ItemTierTypeHashes.Exotic */, ItemPlugTooltipClasses.IsExotic);
            this.image.classes.toggle(!plug.definition?.secondaryIcon, Classes_16.Classes.Hidden)
                .setPath(plug.definition?.secondaryIcon && `https://www.bungie.net${plug.definition.secondaryIcon}`);
            this.perks.removeContents();
            if (!perk) {
                for (const perk of plug.perks) {
                    if (perk.perkVisibility === 2 /* ItemPerkVisibility.Hidden */ || !perk.definition.displayProperties.description)
                        continue;
                    if (plug.definition?.displayProperties.description && (perk.definition.displayProperties.description === plug.definition.displayProperties.description || Strings_6.default.fuzzyMatches(perk.definition.displayProperties.description, plug.definition.displayProperties.description)))
                        continue;
                    const subclassCategorisation = (perk.definition.displayProperties.name === plug.definition?.displayProperties.name || perk.definition.displayProperties.icon === plug.definition?.displayProperties.icon)
                        && plug.getCategorisationAs(4 /* DeepsightPlugCategory.Subclass */);
                    const icon = subclassCategorisation && subclassCategorisation.damageType
                        ? EnumIcon_9.default.create([DamageTypes_5.default, subclassCategorisation.damageType])
                        : !perk.definition.displayProperties.icon ? undefined
                            : LoadedIcon_5.default.create([`https://www.bungie.net${perk.definition.displayProperties.icon}`])
                                .classes.toggle(perk.definition.displayProperties.name === "Stat Penalty" || perk.definition.displayProperties.name === "Stat Increase", ItemPlugTooltipClasses.PerkIconIsStat);
                    const description = {};
                    Component_53.default.create()
                        .classes.add(ItemPlugTooltipClasses.Perk)
                        .classes.toggle(perk.perkVisibility === 1 /* ItemPerkVisibility.Disabled */, ItemPlugTooltipClasses.PerkIsDisabled)
                        .append(icon?.classes.add(ItemPlugTooltipClasses.PerkIcon))
                        .append(Component_53.default.create()
                        .classes.add(ItemPlugTooltipClasses.PerkDescription)
                        .tweak(DisplayProperties_13.default.applyDescription, DisplayProperties_13.default.description(perk.definition), description))
                        .appendTo(this.perks);
                    if (description.keywords)
                        keywords.push(description.keywords);
                }
            }
            this.clarity.set(plug.clarity);
            this.clarityDefinitions.set(plug.clarity);
            this.footer.classes.toggle(!this.clarity.isPresent, Classes_16.Classes.Hidden);
            this.extra.classes.toggle(!this.clarityDefinitions.isPresent, Classes_16.Classes.Hidden);
            this.hintShowDefinitions.classes.toggle(!this.clarityDefinitions.isPresent, Classes_16.Classes.Hidden);
            void this.keywords.set(Promise.all(keywords).then(keywords => keywords.flat()).then(keywords => {
                if (this.plug === plug) {
                    const hasDefs = this.clarityDefinitions.isPresent || !!keywords.length;
                    this.footer.classes.toggle(!this.clarity.isPresent && !hasDefs, Classes_16.Classes.Hidden);
                    this.extra.classes.toggle(!hasDefs, Classes_16.Classes.Hidden);
                    this.hintShowDefinitions.classes.toggle(!hasDefs, Classes_16.Classes.Hidden);
                }
                return keywords;
            }));
        }
        onGlobalKeyup(event) {
            if (this.clarity.isPresent && event.hovering(".view-item-socket-plug") && event.use("MouseMiddle")) {
                window.open("https://www.d2clarity.com", "_blank");
            }
        }
    }
    __decorate([
        Bound_21.default
    ], ItemPlugTooltip.prototype, "onGlobalKeyup", null);
    let set = 0;
    class ItemPlugKeywords extends Component_53.default {
        constructor() {
            super(...arguments);
            this.setTime = 0;
        }
        onMake() {
            this.classes.add(ItemPlugTooltipClasses.Keywords);
        }
        async set(keywords) {
            this.removeContents();
            const time = this.setTime = set++;
            keywords = await keywords;
            if (this.setTime !== time)
                return;
            for (const keyword of new Set(keywords)) {
                Component_53.default.create()
                    .classes.add(ItemPlugTooltipClasses.Keyword)
                    .append(!keyword.displayProperties.icon ? undefined
                    : LoadedIcon_5.default.create([`https://www.bungie.net${keyword.displayProperties.icon}`])
                        .classes.add(ItemPlugTooltipClasses.KeywordIcon))
                    .append(Component_53.default.create()
                    .classes.add(ItemPlugTooltipClasses.KeywordName)
                    .text.set(DisplayProperties_13.default.name(keyword)))
                    .append(Component_53.default.create()
                    .classes.add(ItemPlugTooltipClasses.KeywordDescription)
                    .tweak(DisplayProperties_13.default.applyDescription, DisplayProperties_13.default.description(keyword)))
                    .appendTo(this);
            }
        }
    }
    exports.default = TooltipManager_4.default.create(tooltip => tooltip
        .make(ItemPlugTooltip));
});
define("ui/destiny/filter/filters/FilterPerk", ["require", "exports", "model/models/Inventory", "ui/destiny/filter/Filter", "ui/destiny/tooltip/ItemPlugTooltip", "ui/utility/DisplayProperties", "utility/Arrays"], function (require, exports, Inventory_2, Filter_16, ItemPlugTooltip_1, DisplayProperties_14, Arrays_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_16.IFilter.async(async () => {
        const inventory = await Inventory_2.default.await();
        const perks = Array.from(inventory.getItems()
            .flatMap(item => item.getSockets("Perk", "Intrinsic"))
            .flatMap(socket => socket.plugs)
            .map((plug) => !DisplayProperties_14.default.name(plug?.definition) ? undefined : {
            plug: plug,
            name: DisplayProperties_14.default.name(plug.definition),
            icon: DisplayProperties_14.default.icon(plug.definition),
        })
            .filter(Arrays_10.default.filterFalsy)
            .sort((a, b) => a.name.localeCompare(b.name))
            .toMap(plug => [plug.name, plug])
            .values());
        function getMatchingPerk(filterValue) {
            filterValue = filterValue.toLowerCase();
            let match;
            for (const perk of perks) {
                if (perk.name.toLowerCase().startsWith(filterValue)) {
                    if (match)
                        return undefined;
                    match = perk;
                }
            }
            return match;
        }
        return ({
            id: Filter_16.default.Perk,
            prefix: "perk:",
            colour: 0x4887ba,
            suggestedValueHint: "perk name",
            suggestedValues: perks,
            apply: (value, item) => {
                return item.sockets.some(socket => socket?.plugs?.some(plug => {
                    if (!plug.definition)
                        return false;
                    plug.definition.displayProperties.nameLowerCase ??= plug.definition.displayProperties.name.toLowerCase();
                    return plug.definition.displayProperties.nameLowerCase.startsWith(value);
                })) ?? false;
            },
            icon: filterValue => getMatchingPerk(filterValue)?.icon,
            tweakChip: (chip, filterValue) => {
                const perk = getMatchingPerk(filterValue);
                if (!perk?.plug)
                    return;
                chip.setTooltip(ItemPlugTooltip_1.default, {
                    initialise: tooltip => perk?.plug && tooltip.set(perk.plug),
                    differs: tooltip => tooltip.plug?.plugItemHash !== perk?.plug.plugItemHash,
                });
            },
        });
    });
});
define("ui/destiny/utility/Rarities", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Rarities;
    (function (Rarities) {
        Rarities.COLOURS = {
            [2166136261 /* ItemTierTypeHashes.Invalid */]: 0,
            [3772930460 /* ItemTierTypeHashes.BasicCurrency */]: 0xdddddd,
            [1801258597 /* ItemTierTypeHashes.BasicQuest */]: 0xdddddd,
            [3340296461 /* ItemTierTypeHashes.Common */]: 0xdddddd,
            [2395677314 /* ItemTierTypeHashes.Uncommon */]: 0x5fa16d,
            [2127292149 /* ItemTierTypeHashes.Rare */]: 0x7eaadf,
            [4008398120 /* ItemTierTypeHashes.Legendary */]: 0x774493,
            [2759499571 /* ItemTierTypeHashes.Exotic */]: 0xf5dc56,
        };
        function getColour(tier) {
            return Rarities.COLOURS[tier]
                ?.toString(16)
                .padStart(6, "0")
                .padStart(7, "#");
        }
        Rarities.getColour = getColour;
    })(Rarities || (Rarities = {}));
    exports.default = Rarities;
});
define("ui/destiny/filter/filters/FilterRarity", ["require", "exports", "model/models/Manifest", "ui/destiny/filter/Filter", "ui/destiny/utility/Rarities"], function (require, exports, Manifest_21, Filter_17, Rarities_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_17.IFilter.async(async () => {
        const { DeepsightTierTypeDefinition } = await Manifest_21.default.await();
        const tiers = (await DeepsightTierTypeDefinition.all())
            .sort((a, b) => b.tierType - a.tierType);
        function definition(value, item) {
            if (value === "")
                return null;
            const resultDamages = tiers.filter(element => element.displayProperties.name?.toLowerCase().startsWith(value)
                && (!item || element.hash === item.definition.inventory?.tierTypeHash));
            if (resultDamages.length === 1)
                return resultDamages[0];
            if (resultDamages.length > 1)
                return null;
            return undefined;
        }
        return {
            id: Filter_17.default.Rarity,
            prefix: "rarity:",
            suggestedValues: Array.from(new Set(tiers.map(element => element.displayProperties.name?.toLowerCase()).filter(v => v))),
            or: true,
            matches: value => tiers.some(element => element.displayProperties.name?.toLowerCase().startsWith(value)),
            apply: (value, item) => definition(value, item) !== undefined,
            colour: value => Rarities_1.default.getColour(definition(value)?.hash) ?? 0xdddddd,
            maskIcon: value => value === "" ? undefined
                : "url(\"https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/engram.svg\")",
        };
    });
});
define("ui/destiny/filter/filters/FilterShaped", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_18.IFilter.createBoolean({
        id: Filter_18.default.Shaped,
        colour: 0xff8d5c,
        suggestedValues: ["shaped"],
        matches: value => "shaped".startsWith(value),
        apply: (value, item) => value === "" || (item.bucket.isCollections() ? item.hasShapedCopy() : !!item.shaped),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/shaped.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterUnlevelled", ["require", "exports", "ui/destiny/filter/Filter"], function (require, exports, Filter_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_19.IFilter.createBoolean({
        id: Filter_19.default.Unlevelled,
        colour: 0x964A42,
        suggestedValues: ["unlevelled"],
        matches: value => "unlevelled".startsWith(value) || "unleveled".startsWith(value),
        apply: (value, item) => value === "" || (!!item.shaped && !item.isMasterwork() && (item.shaped.level?.progress.progress ?? 0) < 17),
        maskIcon: value => value === "" ? undefined
            : "url(\"./image/svg/shaped.svg\")",
    });
});
define("ui/destiny/filter/filters/FilterWeaponType", ["require", "exports", "model/models/Inventory", "model/models/enum/WeaponTypes", "ui/destiny/filter/Filter", "utility/Arrays"], function (require, exports, Inventory_3, WeaponTypes_2, Filter_20, Arrays_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Filter_20.IFilter.async(async () => {
        const inventory = await Inventory_3.default.await();
        return ({
            id: Filter_20.default.WeaponType,
            prefix: "type:",
            colour: 0x333333,
            suggestedValueHint: "weapon type name",
            suggestedValues: inventory.getItems()
                .filter(item => item.definition.itemType === 3 /* DestinyItemType.Weapon */)
                .map(item => item.definition.itemTypeDisplayName)
                .filter(Arrays_11.default.filterFalsy)
                .sort()
                .distinct(),
            or: true,
            apply: (value, item) => {
                item.definition.itemTypeDisplayNameLowerCase ??= (item.definition.itemTypeDisplayName ?? "Unknown").toLowerCase();
                return item.definition.itemTypeDisplayNameLowerCase.startsWith(value);
            },
            maskIcon: WeaponTypes_2.default,
        });
    });
});
define("ui/destiny/filter/FilterManager", ["require", "exports", "model/Model", "ui/destiny/filter/Filter", "ui/destiny/filter/filters/FilterAcquired", "ui/destiny/filter/filters/FilterAdept", "ui/destiny/filter/filters/FilterAmmo", "ui/destiny/filter/filters/FilterArtifice", "ui/destiny/filter/filters/FilterBreakerType", "ui/destiny/filter/filters/FilterCatalyst", "ui/destiny/filter/filters/FilterDuplicate", "ui/destiny/filter/filters/FilterElement", "ui/destiny/filter/filters/FilterEnhance", "ui/destiny/filter/filters/FilterFeatured", "ui/destiny/filter/filters/FilterLocked", "ui/destiny/filter/filters/FilterMasterwork", "ui/destiny/filter/filters/FilterMoment", "ui/destiny/filter/filters/FilterPattern", "ui/destiny/filter/filters/FilterPerk", "ui/destiny/filter/filters/FilterRarity", "ui/destiny/filter/filters/FilterShaped", "ui/destiny/filter/filters/FilterUnlevelled", "ui/destiny/filter/filters/FilterWeaponType", "utility/Arrays", "utility/Strings", "utility/decorator/Bound"], function (require, exports, Model_14, Filter_21, FilterAcquired_1, FilterAdept_1, FilterAmmo_1, FilterArtifice_1, FilterBreakerType_1, FilterCatalyst_1, FilterDuplicate_1, FilterElement_1, FilterEnhance_1, FilterFeatured_1, FilterLocked_1, FilterMasterwork_1, FilterMoment_1, FilterPattern_1, FilterPerk_1, FilterRarity_1, FilterShaped_1, FilterUnlevelled_1, FilterWeaponType_1, Arrays_12, Strings_7, Bound_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let filterMap;
    class FilterManager {
        constructor(configuration) {
            this.current = [];
            this.last = [];
            Object.assign(this, configuration);
        }
        static get initModel() {
            return Model_14.default.createTemporary(async (api) => {
                api.emitProgress(0, "Initialising filters");
                await FilterManager.init();
            });
        }
        static async init() {
            if (filterMap)
                return;
            const initialFilterMap = {
                [Filter_21.default.Ammo]: FilterAmmo_1.default,
                [Filter_21.default.Element]: await (0, FilterElement_1.default)(),
                [Filter_21.default.Enhancement]: FilterEnhance_1.default,
                [Filter_21.default.WeaponType]: await (0, FilterWeaponType_1.default)(),
                [Filter_21.default.Perk]: await (0, FilterPerk_1.default)(),
                [Filter_21.default.Moment]: await (0, FilterMoment_1.default)(),
                [Filter_21.default.Shaped]: FilterShaped_1.default,
                [Filter_21.default.Masterwork]: FilterMasterwork_1.default,
                [Filter_21.default.Unlevelled]: FilterUnlevelled_1.default,
                [Filter_21.default.Locked]: FilterLocked_1.default,
                [Filter_21.default.Rarity]: await (0, FilterRarity_1.default)(),
                [Filter_21.default.Adept]: FilterAdept_1.default,
                [Filter_21.default.Artifice]: FilterArtifice_1.default,
                [Filter_21.default.Pattern]: FilterPattern_1.default,
                [Filter_21.default.Duplicate]: FilterDuplicate_1.default,
                [Filter_21.default.BreakerType]: await (0, FilterBreakerType_1.default)(),
                [Filter_21.default.Acquired]: FilterAcquired_1.default,
                [Filter_21.default.Catalyst]: FilterCatalyst_1.default,
                [Filter_21.default.Featured]: FilterFeatured_1.default,
                [Filter_21.default.Raw]: {
                    id: Filter_21.default.Raw,
                    prefix: "",
                    colour: undefined,
                    apply: (value, item) => new RegExp(`(?<=^| )${value}`).test(item.definition?.displayProperties.name.toLowerCase() ?? ""),
                },
            };
            for (let [type, filterArr] of Object.entries(initialFilterMap)) {
                filterArr = Arrays_12.default.resolve(filterArr);
                for (let i = 0; i < filterArr.length; i++) {
                    const filter = filterArr[i];
                    if (+type !== filter.id)
                        throw new Error(`Filter ${Filter_21.default[+type]} implementation miscategorised`);
                    filter.internalName ??= Filter_21.default[filter.id].toLowerCase();
                    filter.id = (i ? `${filter.id}:${i}` : filter.id);
                    initialFilterMap[filter.id] = filter;
                }
            }
            filterMap = initialFilterMap;
        }
        isFiltered() {
            return this.current.length;
        }
        getApplicable() {
            return Object.values(filterMap)
                .filter(filter => !this.inapplicable.some(inapplicable => this.filterMainIdMatch(filter.id, inapplicable)))
                .sort((a, b) => parseInt(`${a.id}`) - parseInt(`${b.id}`));
        }
        getStateHash() {
            return this.current
                .map(filter => `${filter.filter}:${filter.value}`)
                .join(",");
        }
        filterMainIdMatch(id, inapplicable) {
            id = `${id}`;
            inapplicable = `${inapplicable}`;
            if (inapplicable.includes(":"))
                return id === inapplicable;
            return parseInt(id) === parseInt(inapplicable);
        }
        apply(item) {
            const orFilters = Array.from(new Set(this.current.map(filter => filter.filter)))
                .filter(filterId => filterMap[filterId].or)
                .map(filterId => this.current.filter(filter => filter.filter === filterId));
            const otherFilters = this.current.filter(filter => !filterMap[filter.filter].or);
            return otherFilters.every(filter => filterMap[filter.filter].apply(filter.value, item))
                && orFilters.every(instances => instances.some(filter => filterMap[filter.filter].apply(filter.value, item)));
        }
        add(token) {
            token = token.toLowerCase();
            for (const filter of this.getApplicable()) {
                if (!token.startsWith(filter.prefix))
                    continue;
                const value = Strings_7.default.extractFromQuotes(token.slice(filter.prefix.length));
                if (filter.matches?.(value) ?? true) {
                    this.current.push({
                        filter: filter.id,
                        value,
                    });
                    return filter;
                }
            }
            console.error(`Somehow, no filters matched the token "${token}" `);
        }
        reset() {
            this.current.splice(0, Infinity);
        }
        hasChanged() {
            const isIdentical = this.last.length === this.current.length
                && this.last.every((filter, i) => filter.filter === this.current[i].filter
                    && filter.value === this.current[i].value);
            // it's alright that it's the same filters, they get dumped from current rather than modified
            this.last = this.current.slice();
            return !isIdentical;
        }
        getFilterIds() {
            return this.current.map(filter => `${filterMap[filter.filter].prefix}${filter.value}`);
        }
    }
    __decorate([
        Bound_22.default
    ], FilterManager.prototype, "apply", null);
    exports.default = FilterManager;
});
define("ui/destiny/bucket/BucketComponent", ["require", "exports", "model/models/Characters", "model/models/items/Bucket", "ui/component/Card", "ui/destiny/component/IItemComponent", "ui/destiny/component/Slot"], function (require, exports, Characters_6, Bucket_4, Card_1, IItemComponent_3, Slot_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BucketClasses = void 0;
    const _ = undefined;
    var BucketClasses;
    (function (BucketClasses) {
        BucketClasses["Main"] = "bucket";
        BucketClasses["Header"] = "bucket-header";
        BucketClasses["Title"] = "bucket-title";
        BucketClasses["Icon"] = "bucket-icon";
        BucketClasses["Inventory"] = "bucket-inventory";
        BucketClasses["ItemList"] = "bucket-inventory-item-list";
        BucketClasses["ItemListMain"] = "bucket-inventory-item-list-main";
    })(BucketClasses || (exports.BucketClasses = BucketClasses = {}));
    class BucketComponent extends Card_1.default {
        get view() {
            return this._view?.deref();
        }
        getDropTargets() {
            return this.dropTargets ?? [{ component: this, equipped: false }];
        }
        get bucket() {
            return this.view?.inventory.getBucket(this.bucketId);
        }
        get owner() {
            const [, characterId] = Bucket_4.Bucket.parseId(this.bucketId);
            return Characters_6.default.getOrCurrent(characterId);
        }
        get character() {
            const [, characterId] = Bucket_4.Bucket.parseId(this.bucketId);
            return Characters_6.default.get(characterId);
        }
        get sorter() {
            return this._sort?.deref();
        }
        get filterer() {
            return this._filter?.deref();
        }
        get emptySlots() {
            return this.slots.filter(slot => slot.isEmpty());
        }
        onMake(view, bucketId) {
            super.onMake(view, bucketId);
            this.classes.add(BucketClasses.Main);
            this.header.classes.add(BucketClasses.Header);
            this.title.classes.add(BucketClasses.Title);
            this.icon.classes.add(BucketClasses.Icon);
            this.content.classes.add(BucketClasses.Inventory);
            this._view = new WeakRef(view);
            this.bucketId = bucketId;
            this.slots = [];
            this.itemComponents = [];
            this.items = [];
        }
        is(...hashes) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            return hashes.includes(this.bucket?.hash);
        }
        registerDropTarget(component, equipped) {
            this.dropTargets ??= [];
            this.dropTargets.push({ component, equipped: equipped ?? false });
        }
        setSortedAndFilteredBy(sort, filter) {
            this._sort = sort && new WeakRef(sort);
            this._filter = filter && new WeakRef(filter);
            this.update();
            return this;
        }
        update() {
            const updated = this.sort();
            if (updated) {
                this.render();
            }
            for (const item of this.itemComponents) {
                const filteredOut = !!item.item && !!this.filterer && !this.filterer.apply(item.item);
                item.classes.toggle(filteredOut, IItemComponent_3.ItemClasses._FilteredOut)
                    .attributes.toggle(filteredOut, "tabindex", "-1");
            }
            return updated;
        }
        shouldDisplayItem(item) {
            return true;
        }
        render(requiredSlots = 0) {
            const oldSlots = this.slots.splice(0, Infinity);
            const newItemComponents = [];
            let displayedItems = 0;
            for (const item of this.items) {
                if (item && !this.shouldDisplayItem(item))
                    continue;
                const itemComponent = this.getItemComponent(item);
                if (!itemComponent)
                    continue;
                displayedItems++;
                const slot = Slot_2.default.create()
                    .append(itemComponent)
                    .appendTo(this.content);
                newItemComponents.push(itemComponent);
                this.slots.push(slot);
            }
            for (let i = displayedItems; i < requiredSlots; i++) {
                const slot = this.createEmptySlot().appendTo(this.content);
                this.slots.push(slot);
            }
            for (const slot of oldSlots)
                slot.remove();
            this.itemComponents = newItemComponents;
        }
        createEmptySlot() {
            return Slot_2.default.create().setEmpty();
        }
        getSorter(item) {
            return this.sorter;
        }
        getItemComponent(item) {
            if (!item)
                return undefined;
            let component = this.itemComponents.find(c => c.item?.id === item.id);
            if (!component) {
                component = this.view?.createItemComponent(item)
                    ?.setSortedBy(this.getSorter(item));
                if (component)
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    this.itemComponents.push(component);
            }
            return component;
        }
        sort() {
            const sort = this.sorter;
            if (!this.bucket || !sort)
                return false;
            const items = this.bucket.items.slice().sort(sort.sort);
            const sortHash = items.map(item => `${item.id}:${+!!item.equipped}`).join(",");
            if (this.sortHash === sortHash)
                return false;
            this.sortHash = sortHash;
            this.bucket.fallbackRemovalItem = items[items.length - 1];
            const equippedItem = this.bucket?.equippedItem;
            if (equippedItem)
                equippedItem.fallbackItem = _
                    ?? items.find(item => item !== equippedItem
                        && (item.isTierLessThan(equippedItem.tier?.tierType, 5 /* TierType.Superior */)))
                    ?? this.view?.getVaultBucket(this.bucket?.characterId)?.items.find(item => item !== equippedItem
                        && this.bucket?.matches(item)
                        && item.isTierLessThan(equippedItem.tier?.tierType, 5 /* TierType.Superior */));
            this.items = items;
            return true;
        }
    }
    exports.default = BucketComponent;
});
define("ui/destiny/bucket/CharacterBucket", ["require", "exports", "ui/destiny/bucket/BucketComponent", "ui/destiny/component/Slot", "utility/Arrays"], function (require, exports, BucketComponent_1, Slot_3, Arrays_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CharacterBucketClasses = void 0;
    var CharacterBucketClasses;
    (function (CharacterBucketClasses) {
        CharacterBucketClasses["Main"] = "view-inventory-character-bucket";
        CharacterBucketClasses["Emblem"] = "view-inventory-character-bucket-emblem";
        CharacterBucketClasses["Equipped"] = "view-inventory-character-bucket-equipped";
        CharacterBucketClasses["Inventory"] = "view-inventory-character-bucket-inventory";
    })(CharacterBucketClasses || (exports.CharacterBucketClasses = CharacterBucketClasses = {}));
    class CharacterBucket extends BucketComponent_1.default {
        onMake(view, bucketId) {
            super.onMake(view, bucketId);
            this.classes.add(CharacterBucketClasses.Main);
            Slot_3.default.create()
                .classes.add(CharacterBucketClasses.Emblem)
                .appendTo(this.header);
            this.equippedSlot = Slot_3.default.create()
                .classes.add(CharacterBucketClasses.Equipped)
                .appendTo(this);
            this.content.classes.add(CharacterBucketClasses.Inventory);
            this.registerDropTarget(this.content);
            this.registerDropTarget(this.equippedSlot, true);
        }
        update() {
            const character = this.character;
            const className = character?.class?.displayProperties.name ?? "Unknown";
            this.icon.style.set("--icon", `url("https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/class_${className.toLowerCase()}.svg")`);
            this.title.text.set(className);
            this.style.set("--background", character && `url("https://www.bungie.net${character.emblem?.secondarySpecial ?? character.emblemBackgroundPath}")`)
                .style.set("--emblem", character && `url("https://www.bungie.net${character.emblem?.secondaryOverlay ?? character.emblemPath}")`);
            return super.update();
        }
        render(requiredSlots = 9) {
            const equippedItemComponent = this.getItemComponent(this.bucket?.equippedItem);
            super.render(requiredSlots);
            equippedItemComponent?.appendTo(this.equippedSlot);
            if (equippedItemComponent && !this.itemComponents.includes(equippedItemComponent))
                this.itemComponents.push(equippedItemComponent);
            if (equippedItemComponent !== this.equippedItem) {
                if (this.equippedSlot.contains(this.equippedItem?.element)) {
                    this.equippedItem?.remove();
                    Arrays_13.default.removeSwap(this.itemComponents, this.equippedItem);
                }
                this.equippedItem = equippedItemComponent;
            }
        }
        shouldDisplayItem(item) {
            return !item.equipped;
        }
    }
    exports.default = CharacterBucket;
});
define("ui/destiny/bucket/InventoryBucket", ["require", "exports", "ui/component/Card", "ui/destiny/bucket/BucketComponent"], function (require, exports, Card_2, BucketComponent_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventoryBucketClasses = void 0;
    var InventoryBucketClasses;
    (function (InventoryBucketClasses) {
        InventoryBucketClasses["Main"] = "view-inventory-inventory-bucket";
        InventoryBucketClasses["EmptySlot"] = "view-inventory-inventory-slot-character-bucket-empty-slot";
        InventoryBucketClasses["Content"] = "view-inventory-inventory-bucket-content";
    })(InventoryBucketClasses || (exports.InventoryBucketClasses = InventoryBucketClasses = {}));
    class InventoryBucket extends BucketComponent_2.default {
        onMake(view, bucketId) {
            super.onMake(view, bucketId);
            this.classes.add(InventoryBucketClasses.Main);
            this.content.classes.add(InventoryBucketClasses.Content);
            this.setDisplayMode(Card_2.CardClasses.DisplayModeSection);
        }
        render(requiredSlots = 50) {
            super.render(requiredSlots);
        }
    }
    exports.default = InventoryBucket;
});
define("ui/destiny/bucket/ConsumablesBucket", ["require", "exports", "model/models/items/Bucket", "ui/destiny/bucket/InventoryBucket"], function (require, exports, Bucket_5, InventoryBucket_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ConsumablesBucket extends InventoryBucket_1.default {
        onMake(view) {
            super.onMake(view, Bucket_5.Bucket.id(1469714392 /* InventoryBucketHashes.Consumables */));
            this.icon.style.set("--icon", "url(\"https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/consumables.svg\")");
            this.title.text.add("Consumables");
        }
    }
    exports.default = ConsumablesBucket;
});
define("ui/destiny/bucket/ModificationsBucket", ["require", "exports", "model/models/items/Bucket", "ui/destiny/bucket/InventoryBucket"], function (require, exports, Bucket_6, InventoryBucket_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventoryBucketClasses = void 0;
    exports.isLeftoverModificationsVaultItem = isLeftoverModificationsVaultItem;
    const handledBuckets = new Set([
        1498876634 /* InventoryBucketHashes.KineticWeapons */, 2465295065 /* InventoryBucketHashes.EnergyWeapons */, 953998645 /* InventoryBucketHashes.PowerWeapons */,
        3448274439 /* InventoryBucketHashes.Helmet */, 3551918588 /* InventoryBucketHashes.Gauntlets */, 14239492 /* InventoryBucketHashes.ChestArmor */, 20886954 /* InventoryBucketHashes.LegArmor */, 1585787867 /* InventoryBucketHashes.ClassArmor */,
        215593132 /* InventoryBucketHashes.LostItems */, 375726501 /* InventoryBucketHashes.Engrams */,
        1469714392 /* InventoryBucketHashes.Consumables */,
        4023194814 /* InventoryBucketHashes.Ghost */, 2025709351 /* InventoryBucketHashes.Vehicle */, 284967655 /* InventoryBucketHashes.Ships */,
    ]);
    function isLeftoverModificationsVaultItem(item) {
        return item.bucket.isVault()
            && (!item.definition.inventory?.bucketTypeHash
                || !handledBuckets.has(item.definition.inventory.bucketTypeHash));
    }
    var InventoryBucketClasses;
    (function (InventoryBucketClasses) {
        InventoryBucketClasses["Main"] = "view-inventory-inventory-bucket";
        InventoryBucketClasses["EmptySlot"] = "view-inventory-inventory-slot-character-bucket-empty-slot";
        InventoryBucketClasses["Content"] = "view-inventory-inventory-bucket-content";
    })(InventoryBucketClasses || (exports.InventoryBucketClasses = InventoryBucketClasses = {}));
    class ModificationsBucket extends InventoryBucket_2.default {
        onMake(view) {
            super.onMake(view, Bucket_6.Bucket.id(3313201758 /* InventoryBucketHashes.Modifications */));
            this.icon.style.set("--icon", "url(\"https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/modifications.svg\")");
            this.title.text.add("Modifications");
        }
    }
    exports.default = ModificationsBucket;
});
define("ui/destiny/bucket/PostmasterBucket", ["require", "exports", "model/models/items/Bucket", "ui/component/Card", "ui/component/Component", "ui/destiny/bucket/BucketComponent", "ui/utility/Classes", "ui/view/inventory/slot/IInventorySlotView"], function (require, exports, Bucket_7, Card_3, Component_54, BucketComponent_3, Classes_17, IInventorySlotView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostmasterBucketClasses = void 0;
    var PostmasterBucketClasses;
    (function (PostmasterBucketClasses) {
        PostmasterBucketClasses["Main"] = "view-inventory-postmaster-bucket";
        PostmasterBucketClasses["Engrams"] = "view-inventory-postmaster-bucket-engrams";
        PostmasterBucketClasses["Warning"] = "view-inventory-postmaster-bucket-warning";
        PostmasterBucketClasses["Class"] = "view-inventory-postmaster-bucket-class";
    })(PostmasterBucketClasses || (exports.PostmasterBucketClasses = PostmasterBucketClasses = {}));
    class PostmasterBucket extends BucketComponent_3.default {
        onMake(view, bucketId) {
            super.onMake(view, bucketId);
            this.classes.add(PostmasterBucketClasses.Main);
            this.setDisplayMode(Card_3.CardClasses.DisplayModeSection);
            this.engrams = EngramsBucket.create([view, Bucket_7.Bucket.id(375726501 /* InventoryBucketHashes.Engrams */, this.character?.characterId)])
                .classes.add(PostmasterBucketClasses.Engrams)
                .tweak(bucket => bucket.header.remove())
                .insertToBefore(this, this.contentWrapper);
            this.icon.style.set("--icon", "url(\"./image/svg/postmaster.svg\")");
            this.title.text.set("Postmaster");
            this.className = Component_54.default.create()
                .classes.add(PostmasterBucketClasses.Class, Classes_17.Classes.Hidden)
                .appendTo(this.title);
        }
        setSortedAndFilteredBy(sort, filter) {
            this.engrams.setSortedAndFilteredBy(sort, filter);
            return super.setSortedAndFilteredBy(sort, filter);
        }
        update() {
            const character = this.character;
            const className = character?.class?.displayProperties.name;
            if (className)
                this.className.classes.remove(Classes_17.Classes.Hidden)
                    .text.set(`\xa0 / \xa0${className}`);
            const updated = super.update();
            const engramsUpdated = this.engrams.update();
            if (!updated && !engramsUpdated)
                return false;
            const items = this.itemComponents.length;
            const engrams = this.engrams.itemComponents.length;
            this.classes.toggle(!items && !engrams, Classes_17.Classes.Hidden)
                .classes.toggle(items > 15, PostmasterBucketClasses.Warning);
            return true;
        }
        render(requiredSlots = 21) {
            super.render(requiredSlots);
        }
        createEmptySlot() {
            return super.createEmptySlot().setSimple();
        }
        getSorter(item) {
            return IInventorySlotView_1.InventorySlotViewHandler.getSorter(item);
        }
    }
    exports.default = PostmasterBucket;
    class EngramsBucket extends BucketComponent_3.default {
        onMake(view, bucketId) {
            super.onMake(view, bucketId);
        }
        render(requiredSlots = 10) {
            super.render(requiredSlots);
        }
        createEmptySlot() {
            return super.createEmptySlot().setSimple();
        }
    }
});
define("ui/destiny/bucket/VaultBucket", ["require", "exports", "model/models/items/Bucket", "ui/component/Card", "ui/component/Component", "ui/destiny/bucket/BucketComponent", "ui/utility/Classes"], function (require, exports, Bucket_8, Card_4, Component_55, BucketComponent_4, Classes_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VaultBucketClasses = void 0;
    var VaultBucketClasses;
    (function (VaultBucketClasses) {
        VaultBucketClasses["Main"] = "view-inventory-vault-bucket";
        VaultBucketClasses["Class"] = "view-inventory-vault-bucket-class";
        VaultBucketClasses["Quantity"] = "view-inventory-vault-bucket-quantity";
    })(VaultBucketClasses || (exports.VaultBucketClasses = VaultBucketClasses = {}));
    class VaultBucket extends BucketComponent_4.default {
        onMake(view, bucketId) {
            super.onMake(view, bucketId ?? Bucket_8.Bucket.id(138197802 /* InventoryBucketHashes.General */));
            this.classes.add(VaultBucketClasses.Main);
            this.setDisplayMode(Card_4.CardClasses.DisplayModeSection);
            this.icon.style.set("--icon", "url(\"https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/vault2.svg\")");
            this.title.text.add("Vault");
            this.classLabel = Component_55.default.create()
                .classes.add(VaultBucketClasses.Class)
                .appendTo(this.title);
            this.quantityLabel = Component_55.default.create()
                .classes.add(VaultBucketClasses.Quantity)
                .appendTo(this.title);
        }
        update() {
            const className = this.character?.class?.displayProperties.name;
            this.classLabel?.classes.toggle(!className, Classes_18.Classes.Hidden)
                .text.set(`\xa0 / \xa0${className}`);
            const updated = super.update();
            if (!updated)
                return false;
            const vaultBucket = this.view?.inventory.getBucket(138197802 /* InventoryBucketHashes.General */);
            const vaultItemCount = this.bucket?.items.length ?? 0;
            const vaultCapacity = this.bucket?.capacity;
            this.quantityLabel.classes.toggle(!vaultCapacity, Classes_18.Classes.Hidden);
            this.quantityLabel.text.set(`${(vaultItemCount)} / ${vaultBucket?.items.length ?? 0} // ${vaultCapacity}`);
            return true;
        }
    }
    exports.default = VaultBucket;
});
define("ui/destiny/bucket/BucketComponents", ["require", "exports", "model/models/items/Bucket", "ui/destiny/bucket/CharacterBucket", "ui/destiny/bucket/ConsumablesBucket", "ui/destiny/bucket/ModificationsBucket", "ui/destiny/bucket/PostmasterBucket", "ui/destiny/bucket/VaultBucket"], function (require, exports, Bucket_9, CharacterBucket_1, ConsumablesBucket_1, ModificationsBucket_1, PostmasterBucket_1, VaultBucket_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BucketComponents;
    (function (BucketComponents) {
        function create(id, view) {
            return createInternal(id, view);
        }
        BucketComponents.create = create;
        function createInternal(id, view) {
            const [hash] = Bucket_9.Bucket.parseId(id);
            switch (hash) {
                case 138197802 /* InventoryBucketHashes.General */:
                    return VaultBucket_1.default.create([view, id]);
                case 215593132 /* InventoryBucketHashes.LostItems */:
                    return PostmasterBucket_1.default.create([view, id]);
                case 3313201758 /* InventoryBucketHashes.Modifications */:
                    return ModificationsBucket_1.default.create([view, id]);
                case 1469714392 /* InventoryBucketHashes.Consumables */:
                    return ConsumablesBucket_1.default.create([view, id]);
                default:
                    return CharacterBucket_1.default.create([view, id]);
            }
        }
    })(BucketComponents || (BucketComponents = {}));
    exports.default = BucketComponents;
});
define("ui/destiny/component/DraggableItemComponent", ["require", "exports", "ui/component/Component", "ui/component/utility/Draggable", "ui/destiny/component/ItemComponent", "ui/destiny/tooltip/ItemTooltip"], function (require, exports, Component_56, Draggable_2, ItemComponent_2, ItemTooltip_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DraggableItemClasses = void 0;
    var DraggableItemClasses;
    (function (DraggableItemClasses) {
        DraggableItemClasses["Moving"] = "item-moving";
        DraggableItemClasses["Placeholder"] = "item-moving-placeholder";
        DraggableItemClasses["PlaceholderWrapper"] = "item-moving-placeholder-wrapper";
    })(DraggableItemClasses || (exports.DraggableItemClasses = DraggableItemClasses = {}));
    class DraggableItem extends ItemComponent_2.default {
        async onMake(item, inventory, handler) {
            await super.onMake(item, inventory, handler);
            new Draggable_2.default(this.element);
            let movingPlaceholderWrapper;
            let movingPlaceholder;
            this.event.subscribe("moveStart", event => {
                handler.moveStart(event);
                if (event.defaultPrevented)
                    return;
                this.classes.add(DraggableItemClasses.Moving);
                movingPlaceholderWrapper = Component_56.default.create("span")
                    .classes.add(DraggableItemClasses.PlaceholderWrapper)
                    .setTooltip(ItemTooltip_2.default, {
                    initialise: tooltip => item && tooltip.setPadding(20)
                        .setItem(item, this.inventory),
                    differs: tooltip => tooltip.item?.reference.itemInstanceId !== item?.reference.itemInstanceId,
                });
                movingPlaceholder = ItemComponent_2.default.create([item, inventory])
                    .classes.add(DraggableItemClasses.Placeholder)
                    .clearTooltip()
                    .appendTo(movingPlaceholderWrapper);
                handler.createItemPlaceholder(movingPlaceholder, movingPlaceholderWrapper);
            });
            this.event.subscribe("move", event => {
                movingPlaceholderWrapper?.style.set("--transform", `translate(${event.mouse.x}px, ${event.mouse.y}px)`);
                handler.move(event);
            });
            this.event.subscribe("moveEnd", event => {
                if (movingPlaceholder) {
                    movingPlaceholder.event.emit("mouseout", new MouseEvent("mouseout"));
                    movingPlaceholder.remove();
                    handler.disposeItemPlaceholder(movingPlaceholder, movingPlaceholderWrapper);
                }
                movingPlaceholderWrapper?.remove();
                this.classes.remove(DraggableItemClasses.Moving);
                handler.moveEnd(event);
            });
        }
    }
    exports.default = DraggableItem;
});
define("ui/destiny/component/HintsDrawer", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/component/Drawer", "ui/component/Hints", "ui/view/View"], function (require, exports, Button_14, Component_57, Drawer_3, Hints_4, View_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HintsDrawerClasses = void 0;
    var HintsDrawerClasses;
    (function (HintsDrawerClasses) {
        HintsDrawerClasses["Main"] = "hints-drawer-wrapper";
        HintsDrawerClasses["Button"] = "hints-drawer-button";
        HintsDrawerClasses["ButtonLabel"] = "hints-drawer-button-label";
        HintsDrawerClasses["ButtonText"] = "hints-drawer-button-text";
        HintsDrawerClasses["Drawer"] = "hints-drawer";
        HintsDrawerClasses["Hint"] = "hints-drawer-hint";
        HintsDrawerClasses["HintIcon"] = "hints-drawer-hint-icon";
    })(HintsDrawerClasses || (exports.HintsDrawerClasses = HintsDrawerClasses = {}));
    class HintsDrawer extends Component_57.default {
        onMake() {
            this.classes.add(HintsDrawerClasses.Main);
            this.button = Button_14.default.create()
                .classes.add(HintsDrawerClasses.Button)
                .addIcon(icon => icon.classes.add(HintsDrawerClasses.HintIcon))
                .tweak(button => button.innerIcon?.classes.add(View_1.default.Classes.FooterButtonIcon))
                .append(this.buttonLabel = Component_57.default.create()
                .classes.add(HintsDrawerClasses.ButtonLabel)
                .text.set("Help"))
                .append(this.buttonText = Component_57.default.create()
                .classes.add(HintsDrawerClasses.ButtonText)
                .text.set("Keybinds & more"))
                .event.subscribe("click", () => this.drawer.toggle("click"))
                .appendTo(this);
            this.drawer = Drawer_3.default.create()
                .classes.add(HintsDrawerClasses.Drawer)
                .appendTo(this);
            this.drawer.createPanel()
                .append(Component_57.default.create("p")
                .classes.add(HintsDrawerClasses.Hint)
                .append(Hints_4.Hint.create([Hints_4.IInput.get("KeyF1")]))
                .text.add("\xa0 Player overview"))
                .append(Component_57.default.create("p")
                .classes.add(HintsDrawerClasses.Hint)
                .append(Hints_4.Hint.create([Hints_4.IInput.get("KeyE")]))
                .text.add("\xa0 More information"))
                .append(Component_57.default.create("p")
                .classes.add(HintsDrawerClasses.Hint)
                .append(Hints_4.Hint.create([Hints_4.IInput.get("KeyS", "Ctrl")]))
                .text.add("\xa0 Configure sort"))
                .append(Component_57.default.create("p")
                .classes.add(HintsDrawerClasses.Hint)
                .append(Hints_4.Hint.create([Hints_4.IInput.get("KeyF", "Ctrl")]))
                .text.add("\xa0 Configure filter"));
            this.event.subscribe("mouseenter", () => this.drawer.open("mouse"));
            this.event.subscribe("mouseleave", () => this.drawer.close("mouse"));
        }
    }
    exports.default = HintsDrawer;
});
define("ui/view/inventory/InventoryView", ["require", "exports", "model/models/Characters", "model/models/items/Bucket", "model/models/items/Item", "ui/component/Component", "ui/destiny/bucket/BucketComponents", "ui/destiny/component/DraggableItemComponent", "ui/destiny/component/HintsDrawer", "ui/destiny/component/IItemComponent", "ui/destiny/component/ItemComponent", "ui/destiny/filter/FilterManager", "ui/destiny/filter/ItemFilter", "ui/destiny/sort/ItemSort", "ui/utility/Classes", "ui/utility/UiEventBus", "ui/view/View", "utility/Arrays", "utility/decorator/Bound"], function (require, exports, Characters_7, Bucket_10, Item_5, Component_58, BucketComponents_1, DraggableItemComponent_1, HintsDrawer_1, IItemComponent_4, ItemComponent_3, FilterManager_1, ItemFilter_1, ItemSort_1, Classes_19, UiEventBus_7, View_2, Arrays_14, Bound_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventoryViewClasses = void 0;
    var InventoryViewClasses;
    (function (InventoryViewClasses) {
        InventoryViewClasses["Main"] = "view-inventory";
        InventoryViewClasses["Content"] = "view-inventory-content";
        InventoryViewClasses["Footer"] = "view-inventory-footer";
        InventoryViewClasses["SlotPendingRemoval"] = "view-inventory-pending-removal";
        InventoryViewClasses["HighestPower"] = "view-inventory-highest-power";
        InventoryViewClasses["ItemMoving"] = "view-inventory-item-moving";
        InventoryViewClasses["ItemMovingOriginal"] = "view-inventory-item-moving-original";
        InventoryViewClasses["BucketDropTarget"] = "view-inventory-bucket-drop-target";
        InventoryViewClasses["BucketMovingFrom"] = "view-inventory-bucket-moving-from";
        InventoryViewClasses["ItemFilteredOut"] = "view-inventory-item-filtered-out";
        InventoryViewClasses["LayoutColumns"] = "view-inventory-layout-columns";
        InventoryViewClasses["LayoutRows"] = "view-inventory-layout-rows";
        InventoryViewClasses["LayoutBucket"] = "view-inventory-layout-bucket";
    })(InventoryViewClasses || (exports.InventoryViewClasses = InventoryViewClasses = {}));
    class InventoryViewWrapper extends View_2.default.WrapperComponent {
    }
    class InventoryView extends Component_58.default.makeable().of(InventoryViewWrapper) {
        async onMake(inventory) {
            InventoryView.hasExisted = true;
            InventoryView.current = this;
            this.inventory = inventory;
            this.classes.add(InventoryViewClasses.Main);
            this.super.content.classes.add(InventoryViewClasses.Content);
            if (!Characters_7.default.hasAny()) {
                this.super.setTitle(title => title.text.set("No Guardians Were Found..."));
                this.super.setSubtitle("small", subtitle => subtitle.text.set("Your ghost continues its search..."));
                return;
            }
            this.bucketComponents = {};
            this.equipped = {};
            this.super.definition.layout?.(this);
            inventory.event.subscribe("update", this.update);
            this.event.subscribe("hide", () => {
                inventory.event.unsubscribe("update", this.update);
                if (InventoryView.current === this)
                    delete InventoryView.current;
            });
            this.preUpdateInit();
            this.update();
            this.super.footer.classes.add(InventoryViewClasses.Footer);
            await FilterManager_1.default.init();
            this.initSortAndFilter();
            this.hints = HintsDrawer_1.default.create()
                .tweak(hints => View_2.default.registerFooterButton(hints.button))
                .tweak(hints => hints.buttonLabel.classes.add(View_2.default.Classes.FooterButtonLabel))
                .tweak(hints => hints.buttonText.classes.add(View_2.default.Classes.FooterButtonText))
                .appendTo(this.super.footer);
            UiEventBus_7.default.subscribe("keydown", this.onGlobalKeydown);
        }
        addBuckets(bucketIds, initialiser) {
            for (const bucketId of Arrays_14.default.resolve(bucketIds))
                this.bucketComponents[bucketId] = BucketComponents_1.default.create(bucketId, this)
                    .setSortedAndFilteredBy(this.super.definition.sort, this.super.definition.filter)
                    .tweak(initialiser)
                    .appendTo(this.super.content);
            return this;
        }
        addBucketsTo(component, bucketIds, initialiser) {
            for (const bucketId of Arrays_14.default.resolve(bucketIds))
                this.bucketComponents[bucketId] = BucketComponents_1.default.create(bucketId, this)
                    .setSortedAndFilteredBy(this.super.definition.sort, this.super.definition.filter)
                    .tweak(initialiser)
                    .appendTo(component);
            return this;
        }
        getBuckets() {
            return Object.values(this.bucketComponents ?? {});
        }
        getBucket(value) {
            if (!value)
                return undefined;
            const bucket = this.bucketComponents[typeof value === "string" ? value : value instanceof Bucket_10.Bucket ? value.id : value.bucket.id];
            if (bucket)
                return bucket;
            return !(value instanceof Item_5.default) ? undefined
                : Object.values(this.bucketComponents)
                    .find(bucket => bucket?.items.includes(value));
        }
        getVaultBucket(character) {
            return (character && this.bucketComponents[Bucket_10.Bucket.id(138197802 /* InventoryBucketHashes.General */, character)])
                ?? this.bucketComponents[Bucket_10.Bucket.id(138197802 /* InventoryBucketHashes.General */)];
        }
        getPostmasterBucket(character) {
            return character && this.bucketComponents[Bucket_10.Bucket.id(215593132 /* InventoryBucketHashes.LostItems */, character)];
        }
        preUpdateInit() { }
        initSortAndFilter() {
            this.sorter = ItemSort_1.default.create([this.super.definition.sort])
                .event.subscribe("sort", this.update)
                .tweak(itemSort => View_2.default.registerFooterButton(itemSort.button))
                .tweak(itemSort => itemSort.label.classes.add(View_2.default.Classes.FooterButtonLabel))
                .tweak(itemSort => itemSort.sortText.classes.add(View_2.default.Classes.FooterButtonText))
                .appendTo(this.super.footer);
            this.filterer = ItemFilter_1.default.getFor(this.super.definition.filter)
                .event.subscribe("filter", this.update)
                .event.subscribe("submit", () => document.querySelector(`.${IItemComponent_4.ItemClasses.Main}:not([tabindex="-1"])`)?.focus())
                .tweak(itemFilter => View_2.default.registerFooterButton(itemFilter.button))
                .tweak(itemFilter => itemFilter.label.classes.add(View_2.default.Classes.FooterButtonLabel))
                .tweak(itemFilter => itemFilter.input.classes.add(View_2.default.Classes.FooterButtonText))
                .appendTo(this.super.footer);
            this.update();
        }
        update() {
            for (const bucket of Object.values(this.bucketComponents)) {
                bucket?.update();
            }
        }
        onGlobalKeydown(event) {
            if (!document.contains(this.element)) {
                UiEventBus_7.default.unsubscribe("keydown", this.onGlobalKeydown);
                return;
            }
            if (this.hints.drawer.isOpen() && event.useOverInput("Escape")) {
                this.hints.drawer.close(true);
            }
            if (this.filterer.isFiltered() && event.use("Escape")) {
                this.filterer.reset();
            }
        }
        onItemMoveStart(item, event) {
            this.super.definition.onItemMoveStart?.(this, this.super, item, event);
        }
        createItemComponent(item) {
            if (!item.canTransfer())
                return ItemComponent_3.default.create([item, this.inventory]);
            return DraggableItemComponent_1.default.create([item, this.inventory, {
                    createItemPlaceholder: (item, wrapper) => {
                        this.itemMoving?.remove();
                        this.itemMoving = item;
                        (wrapper ?? item).appendTo(this);
                    },
                    disposeItemPlaceholder: item => {
                        if (this.itemMoving === item)
                            delete this.itemMoving;
                    },
                    moveStart: event => {
                        if (Component_58.default.window.width <= 800)
                            return event.preventDefault();
                        this.getBucket(item)
                            ?.classes.add(InventoryViewClasses.BucketMovingFrom);
                        this.onItemMoveStart(item, event);
                    },
                    move: event => {
                        for (const bucket of this.getBuckets()) {
                            if (!bucket || bucket.is(1469714392 /* InventoryBucketHashes.Consumables */, 3313201758 /* InventoryBucketHashes.Modifications */, 215593132 /* InventoryBucketHashes.LostItems */))
                                continue;
                            for (const { component } of bucket.getDropTargets())
                                component.classes.toggle(component.intersects(event.mouse, true) && !component.element.matches(`.${Classes_19.Classes.Hidden} *`), InventoryViewClasses.BucketDropTarget);
                        }
                    },
                    moveEnd: async (event) => {
                        this.getBucket(item)
                            ?.classes.remove(InventoryViewClasses.BucketMovingFrom);
                        let dropBucket;
                        let dropEquipped = false;
                        for (const bucket of this.getBuckets()) {
                            if (!bucket || bucket.is(1469714392 /* InventoryBucketHashes.Consumables */, 3313201758 /* InventoryBucketHashes.Modifications */, 215593132 /* InventoryBucketHashes.LostItems */, 3284755031 /* InventoryBucketHashes.Subclass */))
                                continue;
                            let intersections = false;
                            for (const { component, equipped } of bucket.getDropTargets()) {
                                component.classes.remove(InventoryViewClasses.BucketDropTarget);
                                if (!intersections && !dropBucket && component.intersects(event.mouse, true) && !component.element.matches(`.${Classes_19.Classes.Hidden} *`)) {
                                    intersections = true;
                                    dropEquipped = equipped;
                                }
                            }
                            if (!intersections || dropBucket)
                                continue;
                            dropBucket = bucket;
                        }
                        if (!dropBucket?.bucket)
                            return;
                        if (item.bucket.id === dropBucket.bucket.id && item.equipped === dropEquipped)
                            return;
                        if (dropBucket.bucket.isCharacter()) {
                            if (dropEquipped)
                                return item.equip(dropBucket.bucket.characterId);
                            else if (item.equipped && item.bucket.id === dropBucket.bucket.id)
                                return item.unequip();
                        }
                        await item.transferToBucket(dropBucket.bucket);
                    },
                }]);
        }
    }
    exports.default = InventoryView;
    __decorate([
        Bound_23.default
    ], InventoryView.prototype, "addBuckets", null);
    __decorate([
        Bound_23.default
    ], InventoryView.prototype, "addBucketsTo", null);
    __decorate([
        Bound_23.default
    ], InventoryView.prototype, "update", null);
    __decorate([
        Bound_23.default
    ], InventoryView.prototype, "onGlobalKeydown", null);
});
define("utility/Tuples", ["require", "exports", "utility/Arrays"], function (require, exports, Arrays_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Tuples;
    (function (Tuples) {
        function make(...values) {
            return values;
        }
        Tuples.make = make;
        const nullishFilters = Object.fromEntries(Arrays_15.default.range(6)
            .map(index => make(index, (value) => value[index] !== undefined && value[index] !== null)));
        function filterNullish(index) {
            return nullishFilters[index];
        }
        Tuples.filterNullish = filterNullish;
        const falsyFilters = Object.fromEntries(Arrays_15.default.range(6)
            .map(index => make(index, (value) => value[index])));
        function filterFalsy(index) {
            return falsyFilters[index];
        }
        Tuples.filterFalsy = filterFalsy;
        function getter(index) {
            return tuple => tuple[index];
        }
        Tuples.getter = getter;
        function filter(index, predicate) {
            return (tuple, i) => predicate(tuple[index], i);
        }
        Tuples.filter = filter;
    })(Tuples || (Tuples = {}));
    exports.default = Tuples;
});
define("ui/view/inventory/slot/IInventorySlotView", ["require", "exports", "utility/Tuples"], function (require, exports, Tuples_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventorySlotViewHandler = exports.IInventorySlotViewDefinition = void 0;
    var IInventorySlotViewDefinition;
    (function (IInventorySlotViewDefinition) {
        function is(definition) {
            return definition !== undefined && "slot" in definition && typeof definition.slot === "number";
        }
        IInventorySlotViewDefinition.is = is;
        function as(definition) {
            return is(definition) ? definition : undefined;
        }
        IInventorySlotViewDefinition.as = as;
    })(IInventorySlotViewDefinition || (exports.IInventorySlotViewDefinition = IInventorySlotViewDefinition = {}));
    var InventorySlotViewHandler;
    (function (InventorySlotViewHandler) {
        function getSorter(item) {
            return Object.values(viewManager.registry)
                .map(view => Tuples_1.default.make(view, IInventorySlotViewDefinition.is(view.definition) ? view.definition.slot : undefined))
                .findMap(Tuples_1.default.filter(1, slot => slot === item.definition.inventory?.bucketTypeHash), ([view]) => IInventorySlotViewDefinition.as(view.definition)?.sort);
        }
        InventorySlotViewHandler.getSorter = getSorter;
    })(InventorySlotViewHandler || (exports.InventorySlotViewHandler = InventorySlotViewHandler = {}));
});
define("ui/view/inventory/slot/InventorySlotView", ["require", "exports", "model/models/Characters", "model/models/Inventory", "model/models/items/Bucket", "ui/component/Component", "ui/view/View", "ui/view/inventory/InventoryView"], function (require, exports, Characters_8, Inventory_4, Bucket_11, Component_59, View_3, InventoryView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventorySlotViewClasses = void 0;
    var InventorySlotViewClasses;
    (function (InventorySlotViewClasses) {
        InventorySlotViewClasses["Column"] = "view-inventory-slot-column";
        InventorySlotViewClasses["CharacterBuckets"] = "view-inventory-slot-character-buckets";
        InventorySlotViewClasses["CharacterBucket"] = "view-inventory-slot-character-bucket";
        InventorySlotViewClasses["VaultBucket"] = "view-inventory-slot-vault-bucket";
        InventorySlotViewClasses["VaultBuckets"] = "view-inventory-slot-vault-buckets";
        InventorySlotViewClasses["VaultBucketMerged"] = "view-inventory-slot-vault-bucket-merged";
        InventorySlotViewClasses["PostmasterBucket"] = "view-inventory-slot-postmaster-bucket";
        InventorySlotViewClasses["PostmasterBuckets"] = "view-inventory-slot-postmaster-buckets";
    })(InventorySlotViewClasses || (exports.InventorySlotViewClasses = InventorySlotViewClasses = {}));
    exports.default = new View_3.default.Factory()
        .using(Inventory_4.default.createModel())
        .define()
        .initialise((view, model) => view.make(InventoryView_1.default, model))
        .wrapper()
        .configure(definition => ({
        layout: view => {
            const charactersColumn = Component_59.default.create()
                .classes.add(InventorySlotViewClasses.CharacterBuckets, InventorySlotViewClasses.Column)
                .appendTo(view.super.content);
            Characters_8.default.getSorted()
                .map(character => Bucket_11.Bucket.id(definition.slot, character.characterId))
                .collect(bucketIds => view.addBucketsTo(charactersColumn, bucketIds, bucket => bucket
                .classes.add(InventorySlotViewClasses.CharacterBucket)));
            const vaultsColumn = Component_59.default.create()
                .classes.add(InventorySlotViewClasses.VaultBuckets, InventorySlotViewClasses.Column)
                .appendTo(view.super.content);
            if (definition.mergedVaults)
                view.addBucketsTo(vaultsColumn, Bucket_11.Bucket.id(138197802 /* InventoryBucketHashes.General */, undefined, definition.slot), bucket => bucket
                    .classes.add(InventorySlotViewClasses.VaultBucket, InventorySlotViewClasses.VaultBucketMerged));
            else
                Characters_8.default.getSorted()
                    .map(character => Bucket_11.Bucket.id(138197802 /* InventoryBucketHashes.General */, character.characterId, definition.slot))
                    .collect(bucketIds => view.addBucketsTo(vaultsColumn, bucketIds, bucket => bucket
                    .classes.add(InventorySlotViewClasses.VaultBucket)));
            Component_59.default.create()
                .classes.add(InventorySlotViewClasses.PostmasterBuckets, InventorySlotViewClasses.Column)
                .appendTo(view.super.content)
                .tweak(column => Characters_8.default.getSorted()
                .map(character => Bucket_11.Bucket.id(215593132 /* InventoryBucketHashes.LostItems */, character.characterId))
                .collect(bucketIds => view.addBucketsTo(column, bucketIds, bucket => bucket
                .classes.add(InventorySlotViewClasses.PostmasterBucket))));
        },
    }));
});
define("ui/view/inventory/slot/InventoryArmourSlotView", ["require", "exports", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager", "ui/view/inventory/slot/InventorySlotView"], function (require, exports, Filter_22, FilterManager_2, Sort_27, SortManager_2, InventorySlotView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FILTER_MANAGER_ARMOUR_DEFINITION = exports.SORT_MANAGER_ARMOUR_DEFINITION = exports.VIEW_NAME_ARMOUR = exports.VIEW_ID_ARMOUR = exports.FILTERS_INAPPLICABLE_ARMOUR = exports.SORTS_INAPPLICABLE_ARMOUR = exports.SORTS_DEFAULT_ARMOUR = void 0;
    exports.SORTS_DEFAULT_ARMOUR = [
        Sort_27.default.Exotic,
        Sort_27.default.Rarity,
        Sort_27.default.StatDistribution,
        Sort_27.default.StatLegacyDistribution,
        Sort_27.default.Masterwork,
        Sort_27.default.Power,
        Sort_27.default.Energy,
    ];
    exports.SORTS_INAPPLICABLE_ARMOUR = [
        Sort_27.default.Pattern,
        Sort_27.default.AmmoType,
        Sort_27.default.Shaped,
        Sort_27.default.WeaponType,
        Sort_27.default.Quantity,
        Sort_27.default.DamageType,
        Sort_27.default.Harmonizable,
        Sort_27.default.CanShape,
        Sort_27.default.Acquired,
    ];
    exports.FILTERS_INAPPLICABLE_ARMOUR = [
        Filter_22.default.Ammo,
        Filter_22.default.WeaponType,
        Filter_22.default.Perk,
        Filter_22.default.Shaped,
        Filter_22.default.Element,
        Filter_22.default.Enhancement,
        Filter_22.default.Unlevelled,
        Filter_22.default.Adept,
        Filter_22.default.Catalyst,
        Filter_22.default.Pattern,
        Filter_22.default.Acquired,
    ];
    exports.VIEW_ID_ARMOUR = "armour";
    exports.VIEW_NAME_ARMOUR = "Armour";
    exports.SORT_MANAGER_ARMOUR_DEFINITION = {
        id: exports.VIEW_ID_ARMOUR,
        name: exports.VIEW_NAME_ARMOUR,
        default: exports.SORTS_DEFAULT_ARMOUR,
        inapplicable: exports.SORTS_INAPPLICABLE_ARMOUR,
    };
    exports.FILTER_MANAGER_ARMOUR_DEFINITION = {
        id: exports.VIEW_ID_ARMOUR,
        name: exports.VIEW_NAME_ARMOUR,
        inapplicable: exports.FILTERS_INAPPLICABLE_ARMOUR,
    };
    exports.default = InventorySlotView_1.default.clone().configure({
        sort: new SortManager_2.default(exports.SORT_MANAGER_ARMOUR_DEFINITION),
        filter: new FilterManager_2.default(exports.FILTER_MANAGER_ARMOUR_DEFINITION),
        separateVaults: true,
        navGroupViewId: exports.VIEW_ID_ARMOUR,
    });
});
define("ui/view/inventory/slot/InventoryArmsView", ["require", "exports", "ui/view/inventory/slot/InventoryArmourSlotView"], function (require, exports, InventoryArmourSlotView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryArmourSlotView_1.default.create({
        id: "arms",
        name: "Arms",
        slot: 3551918588 /* InventoryBucketHashes.Gauntlets */,
    });
});
define("ui/view/inventory/slot/InventoryChestView", ["require", "exports", "ui/view/inventory/slot/InventoryArmourSlotView"], function (require, exports, InventoryArmourSlotView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryArmourSlotView_2.default.create({
        id: "chest",
        name: "Chest",
        slot: 14239492 /* InventoryBucketHashes.ChestArmor */,
    });
});
define("ui/view/inventory/slot/InventoryClassItemView", ["require", "exports", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager", "ui/view/inventory/slot/InventoryArmourSlotView"], function (require, exports, Sort_28, SortManager_3, InventoryArmourSlotView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryArmourSlotView_3.default.create({
        id: "class-item",
        name: "Class Item",
        slot: 1585787867 /* InventoryBucketHashes.ClassArmor */,
        sort: new SortManager_3.default({
            id: "class-items",
            name: "Class Items",
            default: InventoryArmourSlotView_3.SORTS_DEFAULT_ARMOUR,
            inapplicable: [...InventoryArmourSlotView_3.SORTS_INAPPLICABLE_ARMOUR, Sort_28.default.Exotic, Sort_28.default.StatDistribution, Sort_28.default.StatLegacyDistribution, Sort_28.default.StatTotal, "stat-.*"],
        }),
    });
});
define("ui/view/inventory/slot/InventoryWeaponSlotView", ["require", "exports", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager", "ui/view/inventory/slot/InventorySlotView"], function (require, exports, Filter_23, FilterManager_3, Sort_29, SortManager_4, InventorySlotView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FILTER_MANAGER_WEAPONS_DEFINITION = exports.SORT_MANAGER_WEAPONS_DEFINITION = exports.VIEW_NAME_WEAPONS = exports.VIEW_ID_WEAPONS = exports.FILTERS_INAPPLICABLE_WEAPONS = exports.SORTS_INAPPLICABLE_WEAPONS = exports.SORTS_DEFAULT_WEAPONS = void 0;
    exports.SORTS_DEFAULT_WEAPONS = [
        Sort_29.default.Pattern,
        Sort_29.default.Rarity,
        Sort_29.default.Masterwork,
        Sort_29.default.Power,
        Sort_29.default.DamageType,
        Sort_29.default.AmmoType,
    ];
    exports.SORTS_INAPPLICABLE_WEAPONS = [
        Sort_29.default.Energy,
        Sort_29.default.StatTotal,
        Sort_29.default.StatDistribution,
        Sort_29.default.StatLegacyDistribution,
        Sort_29.default.Quantity,
        Sort_29.default.CanShape,
        Sort_29.default.Acquired,
        "stat-.*",
    ];
    exports.FILTERS_INAPPLICABLE_WEAPONS = [
        Filter_23.default.Artifice,
        Filter_23.default.Acquired,
    ];
    exports.VIEW_ID_WEAPONS = "weapons";
    exports.VIEW_NAME_WEAPONS = "Weapons";
    exports.SORT_MANAGER_WEAPONS_DEFINITION = {
        id: exports.VIEW_ID_WEAPONS,
        name: exports.VIEW_NAME_WEAPONS,
        default: exports.SORTS_DEFAULT_WEAPONS,
        inapplicable: exports.SORTS_INAPPLICABLE_WEAPONS,
    };
    exports.FILTER_MANAGER_WEAPONS_DEFINITION = {
        id: exports.VIEW_ID_WEAPONS,
        name: exports.VIEW_NAME_WEAPONS,
        inapplicable: exports.FILTERS_INAPPLICABLE_WEAPONS,
    };
    exports.default = InventorySlotView_2.default.clone().configure({
        sort: new SortManager_4.default(exports.SORT_MANAGER_WEAPONS_DEFINITION),
        filter: new FilterManager_3.default(exports.FILTER_MANAGER_WEAPONS_DEFINITION),
        navGroupViewId: exports.VIEW_ID_WEAPONS,
        mergedVaults: true,
    });
});
define("ui/view/inventory/slot/InventoryEnergyView", ["require", "exports", "ui/view/inventory/slot/InventoryWeaponSlotView"], function (require, exports, InventoryWeaponSlotView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryWeaponSlotView_1.default.create({
        id: "energy",
        name: "Energy",
        slot: 2465295065 /* InventoryBucketHashes.EnergyWeapons */,
    });
});
define("ui/view/inventory/slot/InventoryHelmetView", ["require", "exports", "ui/view/inventory/slot/InventoryArmourSlotView"], function (require, exports, InventoryArmourSlotView_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryArmourSlotView_4.default.create({
        id: "helmet",
        name: "Helmet",
        slot: 3448274439 /* InventoryBucketHashes.Helmet */,
    });
});
define("ui/view/inventory/slot/InventoryKineticView", ["require", "exports", "ui/view/inventory/slot/InventoryWeaponSlotView"], function (require, exports, InventoryWeaponSlotView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryWeaponSlotView_2.default.create({
        id: "kinetic",
        name: "Kinetic",
        slot: 1498876634 /* InventoryBucketHashes.KineticWeapons */,
    });
});
define("ui/view/inventory/slot/InventoryLegsView", ["require", "exports", "ui/view/inventory/slot/InventoryArmourSlotView"], function (require, exports, InventoryArmourSlotView_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryArmourSlotView_5.default.create({
        id: "legs",
        name: "Legs",
        slot: 20886954 /* InventoryBucketHashes.LegArmor */,
    });
});
define("ui/view/inventory/slot/InventoryPowerView", ["require", "exports", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/view/inventory/slot/InventoryWeaponSlotView"], function (require, exports, Filter_24, FilterManager_4, InventoryWeaponSlotView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryWeaponSlotView_3.default.create({
        id: "power",
        name: "Power",
        slot: 953998645 /* InventoryBucketHashes.PowerWeapons */,
        filter: new FilterManager_4.default({
            id: "heavyWeapons",
            name: "Heavy Weapons",
            inapplicable: [...InventoryWeaponSlotView_3.FILTERS_INAPPLICABLE_WEAPONS, Filter_24.default.Ammo],
        }),
    });
});
define("ui/destiny/playeroverview/PlayerOverviewCharacterPanel", ["require", "exports", "ui/component/Component", "ui/component/InfoBlock", "ui/destiny/component/ClassPicker", "ui/destiny/component/ItemComponent", "ui/destiny/component/ItemPowerLevel", "ui/destiny/component/Slot", "ui/destiny/playeroverview/LoadoutsComponent", "ui/destiny/playeroverview/StatsOverview", "ui/destiny/tooltip/ItemSubclassTooltip", "ui/utility/Classes", "ui/view/inventory/slot/IInventorySlotView", "ui/view/inventory/slot/InventoryArmsView", "ui/view/inventory/slot/InventoryChestView", "ui/view/inventory/slot/InventoryClassItemView", "ui/view/inventory/slot/InventoryEnergyView", "ui/view/inventory/slot/InventoryHelmetView", "ui/view/inventory/slot/InventoryKineticView", "ui/view/inventory/slot/InventoryLegsView", "ui/view/inventory/slot/InventoryPowerView", "utility/ProfileManager", "utility/maths/Maths"], function (require, exports, Component_60, InfoBlock_1, ClassPicker_1, ItemComponent_4, ItemPowerLevel_2, Slot_4, LoadoutsComponent_1, StatsOverview_1, ItemSubclassTooltip_1, Classes_20, IInventorySlotView_2, InventoryArmsView_1, InventoryChestView_1, InventoryClassItemView_1, InventoryEnergyView_1, InventoryHelmetView_1, InventoryKineticView_1, InventoryLegsView_1, InventoryPowerView_1, ProfileManager_11, Maths_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlayerOverviewCharacterPanelClasses = void 0;
    var PlayerOverviewCharacterPanelClasses;
    (function (PlayerOverviewCharacterPanelClasses) {
        PlayerOverviewCharacterPanelClasses["Main"] = "player-overview-drawer-panel";
        PlayerOverviewCharacterPanelClasses["CharacterSettings"] = "player-overview-character-settings";
        PlayerOverviewCharacterPanelClasses["CharacterWrapper"] = "player-overview-character-wrapper";
        PlayerOverviewCharacterPanelClasses["SubclassPicker"] = "player-overview-subclass-picker";
        PlayerOverviewCharacterPanelClasses["SlotGroup"] = "player-overview-slot-group";
        PlayerOverviewCharacterPanelClasses["Slot"] = "player-overview-slot";
        PlayerOverviewCharacterPanelClasses["SlotOption"] = "player-overview-slot-option";
        PlayerOverviewCharacterPanelClasses["SlotOptionEquipped"] = "player-overview-slot-option-equipped";
        PlayerOverviewCharacterPanelClasses["SlotOptionHighestPower"] = "player-overview-slot-option-highest-power";
        PlayerOverviewCharacterPanelClasses["OverviewSlot"] = "player-overview-slot-overview";
        PlayerOverviewCharacterPanelClasses["Item"] = "player-overview-item";
        PlayerOverviewCharacterPanelClasses["ItemEquipped"] = "player-overview-item-equipped";
        PlayerOverviewCharacterPanelClasses["ItemHighestPower"] = "player-overview-item-highest-power";
        PlayerOverviewCharacterPanelClasses["ItemSame"] = "player-overview-item-same";
        PlayerOverviewCharacterPanelClasses["Power"] = "player-overview-power";
        PlayerOverviewCharacterPanelClasses["PowerTotal"] = "player-overview-power-total";
        PlayerOverviewCharacterPanelClasses["PowerEquipped"] = "player-overview-power-equipped";
        PlayerOverviewCharacterPanelClasses["PowerHighestPower"] = "player-overview-power-highest-power";
        PlayerOverviewCharacterPanelClasses["PowerTotalLabel"] = "player-overview-power-total-label";
        PlayerOverviewCharacterPanelClasses["PowerTotalLabelEquipped"] = "player-overview-power-total-label-equipped";
        PlayerOverviewCharacterPanelClasses["PowerTotalLabelHighestPower"] = "player-overview-power-total-label-highest-power";
        PlayerOverviewCharacterPanelClasses["LoadoutsButton"] = "player-overview-loadouts-button";
        PlayerOverviewCharacterPanelClasses["LoadoutsButtonIcon"] = "player-overview-loadouts-button-icon";
        PlayerOverviewCharacterPanelClasses["LoadoutsButtonIcon1"] = "player-overview-loadouts-button-icon-1";
        PlayerOverviewCharacterPanelClasses["LoadoutsButtonIcon2"] = "player-overview-loadouts-button-icon-2";
        PlayerOverviewCharacterPanelClasses["LoadoutsButtonIcon3"] = "player-overview-loadouts-button-icon-3";
        PlayerOverviewCharacterPanelClasses["ArtifactSlot"] = "player-overview-artifact-slot";
        PlayerOverviewCharacterPanelClasses["Artifact"] = "player-overview-artifact";
        PlayerOverviewCharacterPanelClasses["StatsOverviewBlock"] = "player-overview-stats-overview-block";
        PlayerOverviewCharacterPanelClasses["_LoadoutsVisible"] = "player-overview-drawer-panel--loadouts-visible";
        PlayerOverviewCharacterPanelClasses["SubclassPrismatic"] = "player-overview-subclass-prismatic";
    })(PlayerOverviewCharacterPanelClasses || (exports.PlayerOverviewCharacterPanelClasses = PlayerOverviewCharacterPanelClasses = {}));
    const slotViews = [
        [
            InventoryKineticView_1.default,
            InventoryEnergyView_1.default,
            InventoryPowerView_1.default,
        ],
        [
            InventoryHelmetView_1.default,
            InventoryArmsView_1.default,
            InventoryChestView_1.default,
            InventoryLegsView_1.default,
            InventoryClassItemView_1.default,
        ],
    ];
    class PlayerOverviewCharacterPanel extends Component_60.default {
        onMake() {
            this.classes.add(PlayerOverviewCharacterPanelClasses.Main);
            const wrapper = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.CharacterWrapper)
                .appendTo(this);
            const characterSettings = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.CharacterSettings)
                .appendTo(wrapper);
            this.subclassPicker = ClassPicker_1.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.SubclassPicker)
                .setDisabled(!ProfileManager_11.default.isAuthenticated())
                .event.subscribe("selectClass", event => {
                if (event.item?.character)
                    event.setPromise(event.item.equip(event.item.character.characterId));
            })
                .appendTo(characterSettings);
            const checkboxId = `checkbox-${Math.random().toString().slice(2)}`;
            this.loadoutsCheckboxInternal = Component_60.default.create("input")
                .attributes.set("type", "checkbox")
                .attributes.set("id", checkboxId)
                .classes.add(Classes_20.Classes.Hidden)
                .event.subscribe("change", _ => this.event.emit("toggleLoadouts", { visible: this.loadoutsCheckboxInternal.element.checked }))
                .appendTo(characterSettings);
            this.loadoutsButton = Component_60.default.create("label")
                .attributes.set("for", checkboxId)
                .classes.add(PlayerOverviewCharacterPanelClasses.LoadoutsButton)
                .append(Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.LoadoutsButtonIcon, PlayerOverviewCharacterPanelClasses.LoadoutsButtonIcon1))
                .append(Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.LoadoutsButtonIcon, PlayerOverviewCharacterPanelClasses.LoadoutsButtonIcon2))
                .append(Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.LoadoutsButtonIcon, PlayerOverviewCharacterPanelClasses.LoadoutsButtonIcon3))
                .appendTo(characterSettings);
            this.artifactSlot = Slot_4.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.ArtifactSlot)
                .appendTo(characterSettings);
            this.artifact = ItemComponent_4.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Artifact, Classes_20.Classes.Hidden)
                .appendTo(this.artifactSlot);
            this.loadouts = LoadoutsComponent_1.default.create()
                .appendTo(wrapper);
            const slotComponent = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.Slot, PlayerOverviewCharacterPanelClasses.OverviewSlot)
                .appendTo(wrapper);
            const slotOptionHighestPower = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.SlotOption, PlayerOverviewCharacterPanelClasses.SlotOptionHighestPower)
                .appendTo(slotComponent);
            const slotOptionEquipped = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.SlotOption, PlayerOverviewCharacterPanelClasses.SlotOptionEquipped)
                .appendTo(slotComponent);
            Component_60.default.create()
                .text.add("Equipped")
                .classes.add(PlayerOverviewCharacterPanelClasses.PowerTotalLabel, PlayerOverviewCharacterPanelClasses.PowerTotalLabelEquipped)
                .appendTo(slotOptionEquipped);
            this.powerTotalEquipped = ItemPowerLevel_2.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Power, PlayerOverviewCharacterPanelClasses.PowerTotal, PlayerOverviewCharacterPanelClasses.PowerEquipped)
                .appendTo(slotOptionEquipped);
            Component_60.default.create()
                .text.add("Max")
                .classes.add(PlayerOverviewCharacterPanelClasses.PowerTotalLabel, PlayerOverviewCharacterPanelClasses.PowerTotalLabelHighestPower)
                .appendTo(slotOptionHighestPower);
            this.powerTotalHighest = ItemPowerLevel_2.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Power, PlayerOverviewCharacterPanelClasses.PowerTotal, PlayerOverviewCharacterPanelClasses.PowerHighestPower)
                .appendTo(slotOptionHighestPower);
            this.slotComponents = {};
            for (let groupIndex = 0; groupIndex < slotViews.length; groupIndex++) {
                const viewGroup = slotViews[groupIndex];
                const groupColumn = Component_60.default.create()
                    .classes.add(PlayerOverviewCharacterPanelClasses.SlotGroup)
                    .appendTo(wrapper);
                for (const view of viewGroup) {
                    this.slotComponents[view.definition.slot] = SlotComponent.create([groupIndex])
                        .classes.add(PlayerOverviewCharacterPanelClasses.Slot)
                        .appendTo(groupColumn);
                }
            }
            InfoBlock_1.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.StatsOverviewBlock)
                .append(this.statsOverview = StatsOverview_1.default.create())
                .appendTo(this);
        }
        set(inventory, character, buckets) {
            const seasonalArtifact = buckets.find(bucket => bucket.is(1506418338 /* InventoryBucketHashes.SeasonalArtifact */));
            void this.artifact.setItem(seasonalArtifact?.equippedItem);
            this.artifact.classes.toggle(!seasonalArtifact?.equippedItem, Classes_20.Classes.Hidden);
            this.loadouts.set(inventory, character);
            this.statsOverview.set(character, buckets);
            for (const subclass of inventory.getBucket(3284755031 /* InventoryBucketHashes.Subclass */, character.characterId)?.items ?? []) {
                this.subclassPicker.addOption({
                    id: subclass.definition.hash,
                    background: `https://www.bungie.net${subclass.definition.displayProperties.icon}`,
                    item: subclass,
                    initialise: button => button
                        .classes.toggle(subclass.definition.traitHashes.includes(3820193993 /* TraitHashes.ItemSubclassPrism */), PlayerOverviewCharacterPanelClasses.SubclassPrismatic)
                        .setTooltip(ItemSubclassTooltip_1.default, {
                        initialise: tooltip => tooltip.set(subclass),
                        differs: tooltip => tooltip.item?.id !== subclass.id,
                    }),
                });
                if (subclass.equipped)
                    void this.subclassPicker.setCurrent(subclass.definition.hash, true);
            }
            const equippedItems = {};
            const highestPowerItems = {};
            for (const item of buckets.flatMap(bucket => bucket.items)) {
                const view = slotViews.flat().find(view => item.definition.inventory?.bucketTypeHash === view.definition.slot);
                if (!view)
                    continue;
                const slot = view.definition.slot;
                if (item.equipped)
                    equippedItems[slot] = item;
                const highestPower = highestPowerItems[slot]?.instance?.primaryStat?.value ?? 0;
                const itemPower = item.instance?.primaryStat?.value ?? 0;
                if (itemPower > highestPower || (itemPower === highestPower && item.equipped))
                    highestPowerItems[slot] = item;
            }
            const currentPower = Maths_8.default.average(...Object.values(equippedItems)
                .map(item => item?.instance?.primaryStat?.value ?? 0));
            const maximisedPower = Maths_8.default.average(...Object.values(highestPowerItems)
                .map(item => item?.instance?.primaryStat?.value ?? 0));
            this.powerTotalEquipped.setPower(currentPower);
            this.powerTotalHighest.setPower(maximisedPower);
            const equippedLog = [];
            const highestPowerLog = [];
            const previous = this.previousItemInstanceIds ??= [];
            let i = 0;
            for (let groupIndex = 0; groupIndex < slotViews.length; groupIndex++) {
                const viewGroup = slotViews[groupIndex];
                for (const view of viewGroup) {
                    const slot = view.definition.slot;
                    let name = view.definition.name ?? "Unknown View";
                    if (typeof name === "function")
                        name = name();
                    const equippedItem = equippedItems[slot];
                    if (!equippedItem) {
                        console.warn(`No equipped item for slot ${name}`);
                        continue;
                    }
                    const slotComponent = this.slotComponents[slot]
                        .attributes.set("data-name", name);
                    if (previous[i++] !== equippedItem.reference.itemInstanceId) {
                        equippedLog.push(`\n    ${name}:`, equippedItem?.definition.displayProperties.name, equippedItem);
                        previous[i - 1] = equippedItem.reference.itemInstanceId;
                    }
                    const highestPowerItem = highestPowerItems[slot];
                    if (!highestPowerItem)
                        console.warn(`No highest power item for slot ${name}`);
                    else {
                        if (previous[i++] !== highestPowerItem.reference.itemInstanceId) {
                            highestPowerLog.push(`\n    ${name}:`, highestPowerItem?.definition.displayProperties.name, highestPowerItem);
                            previous[i - 1] = highestPowerItem.reference.itemInstanceId;
                        }
                    }
                    slotComponent.set(inventory, equippedItem, highestPowerItem, maximisedPower);
                }
            }
            if (equippedLog.length || highestPowerLog.length)
                console.log(character.class.displayProperties.name, 
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment
                ...!equippedLog.length ? [] : [`\n  Equipped Items - ${Math.floor(currentPower)}${currentPower % 1 ? ` ${(currentPower % 1) * 8}/8` : ""}`, ...equippedLog], 
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment
                ...!highestPowerLog.length ? [] : [`\n\n  Highest Power Items - ${Math.floor(maximisedPower)}${maximisedPower % 1 ? ` ${(maximisedPower % 1) * 8}/8` : ""}`, ...highestPowerLog]);
        }
    }
    exports.default = PlayerOverviewCharacterPanel;
    class SlotComponent extends Component_60.default {
        onMake(type) {
            const slotOptionEquipped = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.SlotOption, PlayerOverviewCharacterPanelClasses.SlotOptionEquipped);
            const slotOptionHighestPower = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.SlotOption, PlayerOverviewCharacterPanelClasses.SlotOptionHighestPower);
            if (type === 0)
                this.append(slotOptionHighestPower, slotOptionEquipped);
            else
                this.append(slotOptionEquipped, slotOptionHighestPower);
            this.itemEquipped = ItemComponent_4.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Item, PlayerOverviewCharacterPanelClasses.ItemEquipped)
                .appendTo(slotOptionEquipped);
            this.powerLevelEquipped = ItemPowerLevel_2.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Power, PlayerOverviewCharacterPanelClasses.PowerEquipped)
                .appendTo(slotOptionEquipped);
            this.itemHighestPowerIsSame = Component_60.default.create()
                .classes.add(PlayerOverviewCharacterPanelClasses.Item, PlayerOverviewCharacterPanelClasses.ItemHighestPower, PlayerOverviewCharacterPanelClasses.ItemSame)
                .appendTo(slotOptionHighestPower);
            this.itemHighestPower = ItemComponent_4.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Item, PlayerOverviewCharacterPanelClasses.ItemHighestPower)
                .appendTo(slotOptionHighestPower);
            this.powerLevelHighest = ItemPowerLevel_2.default.create([])
                .classes.add(PlayerOverviewCharacterPanelClasses.Power, PlayerOverviewCharacterPanelClasses.PowerHighestPower)
                .appendTo(slotOptionHighestPower);
        }
        set(inventory, equippedItem, highestPowerItem, maximisedTotalPower) {
            void this.itemEquipped.setSortedBy(IInventorySlotView_2.InventorySlotViewHandler.getSorter(equippedItem))
                .setItem(equippedItem, inventory);
            const equippedPower = equippedItem.instance?.primaryStat?.value ?? 0;
            this.powerLevelEquipped.setPower(equippedPower, equippedPower - Math.floor(maximisedTotalPower));
            if (!highestPowerItem || highestPowerItem === equippedItem) {
                this.itemHighestPowerIsSame.classes.remove(Classes_20.Classes.Hidden);
                this.itemHighestPower.classes.add(Classes_20.Classes.Hidden);
                return;
            }
            this.itemHighestPowerIsSame.classes.add(Classes_20.Classes.Hidden);
            this.itemHighestPower.classes.remove(Classes_20.Classes.Hidden);
            void this.itemHighestPower.setSortedBy(IInventorySlotView_2.InventorySlotViewHandler.getSorter(highestPowerItem))
                .setItem(highestPowerItem, inventory);
            const highestPowerPower = highestPowerItem.instance?.primaryStat?.value ?? 0;
            this.powerLevelHighest.setPower(highestPowerPower, highestPowerPower - Math.floor(maximisedTotalPower));
        }
    }
});
define("ui/destiny/playeroverview/PlayerOverviewIdentity", ["require", "exports", "ui/component/Button", "ui/component/Component", "ui/utility/Classes", "utility/ProfileManager", "utility/Store", "utility/decorator/Bound"], function (require, exports, Button_15, Component_61, Classes_21, ProfileManager_12, Store_15, Bound_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlayerOverviewIdentityClasses = void 0;
    var PlayerOverviewIdentityClasses;
    (function (PlayerOverviewIdentityClasses) {
        PlayerOverviewIdentityClasses["Main"] = "player-overview-identity";
        PlayerOverviewIdentityClasses["Pretty"] = "player-overview-identity-pretty";
        PlayerOverviewIdentityClasses["PrettyId"] = "player-overview-identity-pretty-id";
        PlayerOverviewIdentityClasses["Username"] = "player-overview-identity-username";
        PlayerOverviewIdentityClasses["Code"] = "player-overview-identity-code";
        PlayerOverviewIdentityClasses["Override"] = "player-overview-identity-override";
        PlayerOverviewIdentityClasses["None"] = "player-overview-identity-none";
        PlayerOverviewIdentityClasses["Switch"] = "player-overview-identity-switch";
        // Input = "player-overview-identity-input",
    })(PlayerOverviewIdentityClasses || (exports.PlayerOverviewIdentityClasses = PlayerOverviewIdentityClasses = {}));
    class PlayerOverviewIdentity extends Component_61.default {
        onMake() {
            this.classes.add(PlayerOverviewIdentityClasses.Main);
            this.pretty = Button_15.default.create()
                .classes.add(PlayerOverviewIdentityClasses.Pretty)
                .append(this.prettyOverride = Component_61.default.create("span")
                .classes.add(PlayerOverviewIdentityClasses.Override)
                .text.set("spying on..."))
                .append(this.prettyId = Component_61.default.create("span")
                .classes.add(PlayerOverviewIdentityClasses.PrettyId)
                .append(this.prettyUsername = Component_61.default.create("span")
                .classes.add(PlayerOverviewIdentityClasses.Username)
                .text.set(this.displayName))
                .append(this.prettyCode = Component_61.default.create("span")
                .classes.add(PlayerOverviewIdentityClasses.Code)
                .text.set(`#${this.code}`)))
                .append(this.switchProfile = Component_61.default.create("span")
                .classes.add(PlayerOverviewIdentityClasses.Switch))
                .appendTo(this);
            Store_15.default.event.subscribe(["setDestinyMembershipOverride", "deleteDestinyMembershipOverride"], this.update);
            this.update();
        }
        update() {
            const profile = ProfileManager_12.default.get();
            this.displayName = profile?.id.name;
            this.code = !profile ? undefined : profile.id.code.toString().padStart(4, "0");
            this.prettyUsername.text.set(this.displayName);
            this.prettyCode.text.set(`#${this.code}`);
            this.prettyOverride.classes.toggle(!profile || !!profile?.data?.accessToken, Classes_21.Classes.Hidden);
            this.prettyId.classes.toggle(profile === undefined, Classes_21.Classes.Hidden);
            this.switchProfile.text.set(profile === undefined ? "Select Profile" : "Switch Profile")
                .classes.toggle(profile !== undefined, Classes_21.Classes.Hidden);
            this.prettyUsername.classes.toggle(!profile, PlayerOverviewIdentityClasses.None);
        }
    }
    exports.default = PlayerOverviewIdentity;
    __decorate([
        Bound_24.default
    ], PlayerOverviewIdentity.prototype, "update", null);
});
define("ui/PlayerOverview", ["require", "exports", "model/models/Characters", "model/models/Inventory", "model/models/enum/EnumModel", "ui/component/Component", "ui/component/Drawer", "ui/component/InfoBlock", "ui/destiny/SwitchProfile", "ui/destiny/component/ClassPicker", "ui/destiny/playeroverview/PlayerOverviewCharacterPanel", "ui/destiny/playeroverview/PlayerOverviewIdentity", "ui/destiny/sort/SortManager", "ui/utility/Classes", "ui/utility/UiEventBus", "utility/Async", "utility/ProfileManager", "utility/decorator/Bound"], function (require, exports, Characters_9, Inventory_5, EnumModel_8, Component_62, Drawer_4, InfoBlock_2, SwitchProfile_1, ClassPicker_2, PlayerOverviewCharacterPanel_1, PlayerOverviewIdentity_1, SortManager_5, Classes_22, UiEventBus_8, Async_7, ProfileManager_13, Bound_25) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SwitchProfileClasses = exports.PlayerOverviewClasses = void 0;
    var PlayerOverviewClasses;
    (function (PlayerOverviewClasses) {
        PlayerOverviewClasses["Main"] = "player-overview";
        PlayerOverviewClasses["Container"] = "player-overview-container";
        PlayerOverviewClasses["Drawer"] = "player-overview-drawer";
        PlayerOverviewClasses["ClassSelection"] = "player-overview-class-selection";
        PlayerOverviewClasses["CharacterPicker"] = "player-overview-character-picker";
        PlayerOverviewClasses["CharacterPickerButton"] = "player-overview-character-picker-button";
        PlayerOverviewClasses["WIP"] = "player-overview-wip";
        PlayerOverviewClasses["_LoadoutsVisible"] = "player-overview--loadouts-visible";
    })(PlayerOverviewClasses || (exports.PlayerOverviewClasses = PlayerOverviewClasses = {}));
    var SwitchProfileClasses;
    (function (SwitchProfileClasses) {
        SwitchProfileClasses["Main"] = "player-overview";
        SwitchProfileClasses["Container"] = "player-overview-container";
        SwitchProfileClasses["Drawer"] = "player-overview-drawer";
        SwitchProfileClasses["ClassSelection"] = "player-overview-class-selection";
        SwitchProfileClasses["CharacterPicker"] = "player-overview-character-picker";
        SwitchProfileClasses["CharacterPickerButton"] = "player-overview-character-picker-button";
        SwitchProfileClasses["WIP"] = "player-overview-wip";
        SwitchProfileClasses["_LoadoutsVisible"] = "player-overview--loadouts-visible";
        SwitchProfileClasses["SwitchProfile"] = "switch-profile";
        SwitchProfileClasses["SwitchProfileList"] = "switch-profile-list";
    })(SwitchProfileClasses || (exports.SwitchProfileClasses = SwitchProfileClasses = {}));
    class PlayerOverview extends Component_62.default {
        async onMake() {
            this.classes.add(PlayerOverviewClasses.Main);
            this.dialog = SwitchProfile_1.default.create()
                .appendTo(document.body);
            this.identity = PlayerOverviewIdentity_1.default.create()
                .event.subscribe("click", () => {
                this.dialog.open();
                this.drawer.close(true);
            })
                .appendTo(this);
            this.drawer = Drawer_4.default.create()
                .classes.add(PlayerOverviewClasses.Drawer)
                .event.subscribe("closeDrawer", _ => this.toggleLoadoutsVisible({ visible: false }))
                .appendTo(this);
            this.currencyOverview = InfoBlock_2.default.create()
                .append(Component_62.default.create()
                .classes.add(PlayerOverviewClasses.WIP))
                .appendTo(this.drawer);
            this.classSelection = Component_62.default.create()
                .classes.add(PlayerOverviewClasses.ClassSelection)
                .appendTo(this.drawer);
            this.characterPicker = ClassPicker_2.default.create([])
                .classes.add(PlayerOverviewClasses.CharacterPicker)
                .event.subscribe("selectClass", event => {
                const panel = this.panels[event.option];
                if (!panel) {
                    console.error(`Selected unknown option '${event.option}'`);
                    return;
                }
                this.drawer.showPanel(this.panels[event.option]);
            })
                .appendTo(this.classSelection);
            this.panels = {};
            await EnumModel_8.default.awaitAll();
            await SortManager_5.default.init();
            this.event.subscribe("mouseenter", this.onMouseEnter);
            this.event.subscribe("mouseleave", event => {
                if (this.contains(document.elementFromPoint(event.clientX, event.clientY)))
                    return;
                this.drawer.close("mouseenter");
            });
            document.body.addEventListener("click", this.onClick);
            UiEventBus_8.default.subscribe("keydown", this.onKeydown);
            UiEventBus_8.default.subscribe("keyup", this.onKeyup);
            viewManager.event.subscribe("show", () => Async_7.default.schedule(10, this.showIfHash));
            viewManager.event.subscribe("initialise", this.showIfHash);
            this.drawer.event.subscribe("openDrawer", () => {
                const currentCharacterId = Characters_9.default.getCurrent()?.characterId;
                if (currentCharacterId)
                    void this.characterPicker.setCurrent(currentCharacterId, true);
            });
            this.inventory = await Inventory_5.default.await();
            this.inventory.event.subscribe("update", this.update);
            this.inventory.event.subscribe("itemUpdate", this.update);
            this.update();
        }
        update() {
            this.updateCharacters();
            this.drawer.enable();
        }
        updateCharacters() {
            const characters = Characters_9.default.getSorted()
                .slice()
                // sort characters by active option so that the active option stays the visible panel
                .sort((a, b) => a.characterId === this.characterPicker.currentOption ? -1 : b.characterId === this.characterPicker.currentOption ? 1 : 0);
            if (!characters.length) {
                console.warn("No characters found");
                this.drawer.removePanels();
                this.panels = {};
                this.drawer.disable();
                return;
            }
            for (const character of characters) {
                const bucket = this.inventory?.getCharacterBuckets(character.characterId);
                if (!bucket) {
                    console.warn(`No bucket found for the character ${character.characterId}`);
                    this.drawer.removePanel(this.panels[character.characterId]);
                    continue;
                }
                const panel = this.panels[character.characterId] ??= this.drawer.createPanel().make(PlayerOverviewCharacterPanel_1.default)
                    .event.subscribe("toggleLoadouts", this.toggleLoadoutsVisible);
                panel.set(this.inventory, character, bucket);
                const className = character.class?.displayProperties.name ?? "Unknown";
                const background = character.emblem?.secondarySpecial ?? character.emblemBackgroundPath;
                this.characterPicker.addOption({
                    id: character.characterId,
                    background: background && `https://www.bungie.net${background}`,
                    icon: `https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/general/class_${className.toLowerCase()}.svg`,
                });
            }
            // remove deleted characters
            for (const option of [...this.characterPicker.options])
                if (!characters.some(character => character.characterId === option.id))
                    this.characterPicker.removeOption(option.id);
        }
        onMouseEnter() {
            if (!ProfileManager_13.default.get())
                return;
            this.drawer.open("mouseenter");
        }
        onClick(event) {
            if (!this.exists())
                return document.body.removeEventListener("click", this.onClick);
            if (event.target.closest(`.${PlayerOverviewClasses.Main}`))
                return;
            this.drawer.close(true);
        }
        onKeydown(event) {
            if (!document.contains(this.element)) {
                UiEventBus_8.default.unsubscribe("keydown", this.onKeydown);
                return;
            }
            if ((event.use("c") || event.use("p") || event.use("o") || event.use("F1")) && ProfileManager_13.default.get() && this.drawer.toggle("key"))
                this.drawer.element.focus();
            if (this.drawer.isOpen() && event.useOverInput("Escape"))
                this.drawer.close(true);
        }
        onKeyup(event) {
            if (!document.contains(this.element)) {
                UiEventBus_8.default.unsubscribe("keyup", this.onKeyup);
                return;
            }
            if (!this.element.contains(document.activeElement) && !event.matches("e"))
                this.drawer.close(true);
        }
        showIfHash() {
            if (!ProfileManager_13.default.get())
                return;
            if (location.hash === "#overview")
                this.drawer.open("hash");
            else
                this.drawer.close(true);
        }
        toggleLoadoutsVisible({ visible }) {
            for (const panel of Object.values(this.panels)) {
                this.classes.toggle(visible, PlayerOverviewClasses._LoadoutsVisible);
                panel.classes.toggle(visible, PlayerOverviewCharacterPanel_1.PlayerOverviewCharacterPanelClasses._LoadoutsVisible);
                panel.loadouts.classes.toggle(!visible, Classes_22.Classes.Hidden);
                panel.loadoutsCheckboxInternal.element.checked = visible;
            }
        }
    }
    exports.default = PlayerOverview;
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "update", null);
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "onMouseEnter", null);
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "onClick", null);
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "onKeydown", null);
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "onKeyup", null);
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "showIfHash", null);
    __decorate([
        Bound_25.default
    ], PlayerOverview.prototype, "toggleLoadoutsVisible", null);
});
define("ui/component/List", ["require", "exports", "ui/component/Component"], function (require, exports, Component_63) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var List;
    (function (List_1) {
        class List extends Component_63.default {
            addItem(initialiser) {
                Component_63.default.create("li")
                    .tweak(initialiser)
                    .appendTo(this);
                return this;
            }
        }
        class Unordered extends List {
        }
        Unordered.defaultType = "ul";
        List_1.Unordered = Unordered;
        class Ordered extends List {
        }
        Ordered.defaultType = "ol";
        List_1.Ordered = Ordered;
    })(List || (List = {}));
    exports.default = List;
});
define("ui/view/documentation/DocumentationCard", ["require", "exports", "ui/component/Component", "ui/component/List"], function (require, exports, Component_64, List_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentationCardClasses = void 0;
    var DocumentationCardClasses;
    (function (DocumentationCardClasses) {
        DocumentationCardClasses["Main"] = "documentation-card";
        DocumentationCardClasses["Heading"] = "documentation-card-heading";
        DocumentationCardClasses["Content"] = "documentation-card-content";
        DocumentationCardClasses["Image"] = "documentation-card-image";
        DocumentationCardClasses["Imagery"] = "documentation-card-imagery";
        DocumentationCardClasses["ContentParagraph"] = "documentation-card-content-paragraph";
        DocumentationCardClasses["List"] = "documentation-card-content-list";
    })(DocumentationCardClasses || (exports.DocumentationCardClasses = DocumentationCardClasses = {}));
    class DocumentationCard extends Component_64.default {
        onMake() {
            this.classes.add(DocumentationCardClasses.Main);
            this.heading = Component_64.default.create("h3")
                .classes.add(DocumentationCardClasses.Heading)
                .appendTo(this);
            this.content = Component_64.default.create()
                .classes.add(DocumentationCardClasses.Content)
                .appendTo(this);
        }
        setTitle(title) {
            this.heading.text.set(title);
            return this;
        }
        addImage(image) {
            this.imagery ??= Component_64.default.create()
                .classes.add(DocumentationCardClasses.Imagery)
                .appendTo(this);
            Component_64.default.create("img")
                .classes.add(DocumentationCardClasses.Image)
                .attributes.set("src", image)
                // .attributes.set("loading", "lazy")
                .appendTo(this.imagery);
            return this;
        }
        addParagraph(content) {
            Component_64.default.create("p")
                .classes.add(DocumentationCardClasses.ContentParagraph)
                .text.set(content)
                .appendTo(this.content);
            return this;
        }
        addList(initialiser) {
            List_2.default.Unordered.create()
                .classes.add(DocumentationCardClasses.List)
                .tweak(initialiser)
                .appendTo(this.content);
            return this;
        }
    }
    exports.default = DocumentationCard;
});
define("ui/view/documentation/DocumentationSection", ["require", "exports", "ui/component/Component", "ui/view/documentation/DocumentationCard"], function (require, exports, Component_65, DocumentationCard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentationSectionClasses = void 0;
    var DocumentationSectionClasses;
    (function (DocumentationSectionClasses) {
        DocumentationSectionClasses["Main"] = "documentation-section";
        DocumentationSectionClasses["Heading"] = "documentation-section-heading";
    })(DocumentationSectionClasses || (exports.DocumentationSectionClasses = DocumentationSectionClasses = {}));
    class DocumentationSection extends Component_65.default {
        onMake() {
            this.classes.add(DocumentationSectionClasses.Main);
            this.content = [];
        }
        setTitle(title) {
            this.title = title;
            Component_65.default.create("h2")
                .classes.add(DocumentationSectionClasses.Heading)
                .text.set(title)
                .prependTo(this);
            return this;
        }
        addSection(initialiser) {
            this.content.push(DocumentationSection.create()
                .tweak(initialiser)
                .appendTo(this));
            return this;
        }
        addCard(initialiser) {
            this.content.push(DocumentationCard_1.default.create()
                .tweak(initialiser)
                .appendTo(this));
            return this;
        }
    }
    exports.default = DocumentationSection;
});
define("ui/view/documentation/DocumentationPage", ["require", "exports", "ui/component/Component", "ui/view/documentation/DocumentationSection"], function (require, exports, Component_66, DocumentationSection_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentationPageClasses = void 0;
    var DocumentationPageClasses;
    (function (DocumentationPageClasses) {
        DocumentationPageClasses["Main"] = "documentation-page";
        DocumentationPageClasses["Nav"] = "documentation-page-nav";
        DocumentationPageClasses["NavHeading"] = "documentation-page-nav-heading";
        DocumentationPageClasses["NavLink"] = "documentation-page-nav-link";
    })(DocumentationPageClasses || (exports.DocumentationPageClasses = DocumentationPageClasses = {}));
    class DocumentationPage extends DocumentationSection_1.default {
        onMake() {
            this.classes.add(DocumentationPageClasses.Main);
            this.nav = Component_66.default.create("nav")
                .classes.add(DocumentationPageClasses.Nav)
                .appendTo(this);
            super.onMake();
        }
        regenerateNav() {
            this.nav.removeContents();
            this.generateSectionNav(this, this.nav);
        }
        generateSectionNav(section, into) {
            for (const content of section.content) {
                if (content instanceof DocumentationSection_1.default) {
                    const thisContentInto = !content.title ? into : Component_66.default.create("nav")
                        .classes.add(DocumentationPageClasses.Nav)
                        .append(Component_66.default.create("h3")
                        .classes.add(DocumentationPageClasses.NavHeading)
                        .text.set(content.title))
                        .appendTo(into);
                    this.generateSectionNav(content, thisContentInto);
                }
                else {
                    Component_66.default.create("button")
                        .classes.add(DocumentationPageClasses.NavLink)
                        .text.set(content.heading.text.get() ?? undefined)
                        .appendTo(into);
                }
            }
        }
    }
    exports.default = DocumentationPage;
});
define("ui/view/AboutView", ["require", "exports", "ui/component/Component", "ui/view/View", "ui/view/documentation/DocumentationPage"], function (require, exports, Component_67, View_4, DocumentationPage_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AboutViewClasses = void 0;
    var AboutViewClasses;
    (function (AboutViewClasses) {
        AboutViewClasses["Details"] = "view-about-details";
        AboutViewClasses["DetailsSummary"] = "view-about-details-summary";
    })(AboutViewClasses || (exports.AboutViewClasses = AboutViewClasses = {}));
    exports.default = View_4.default.create({
        id: "about",
        name: "About",
        noDestinationButton: true,
        initialise: view => view
            .setTitle(title => title.text.set("deepsight.gg"))
            .tweak(view => view.content
            .append(DocumentationPage_1.default.create()
            .addSection(section => section
            .setTitle("A New Destiny 2 Item Manager Approaches...")
            .addCard(card => card
            .addParagraph("deepsight.gg is an item manager for Destiny 2, made to look and feel like the in-game UI, providing functionality not before seen in other item managers. Using deepsight.gg, you can sort armour by your own customisable targeted stat distributions, you can easily add any number of wishlists for specific rolls of weapons, and more!")))
            .addSection(section => section
            .setTitle("Features")
            .addCard(card => card
            .setTitle("Slot Views")
            .addParagraph("One view per slot  Kinetic, Energy, Power, Helmet, Arms, Chest, Legs, Class Item. This results in more items being displayable at one time, at a larger size, and allows quickly transferring them between characters and the vault.")
            .addParagraph("All views display the postmaster for each character.")
            .addParagraph("The highest power 1 or 2 item(s) in each slot displays with a special animation. Never dismantle these ones except for infusion, or you'll lower your drop power!")
            .addImage("./image/about/slot-views.png"))
            .addCard(card => card
            .setTitle("Persistent, highly-customisable sort/filter")
            .addParagraph("Views each have a persistent, configurable sort  weapon views share one, armour views share one, and the class item view has one.")
            .addParagraph("You can configure the order that sorts are applied, or if they're applied at all.")
            .addParagraph("Weapon Sorts")
            .addList(list => list
            .addItem(item => item.text.set("Power"))
            .addItem(item => item.text.set("Name"))
            .addItem(item => item.text.set("Ammo Type"))
            .addItem(item => item.text.set("Masterwork"))
            .addItem(item => item.text.set("Rarity"))
            .addItem(item => item.text.set("Shaped"))
            .addItem(item => item.text.set("Moment (ie the little watermark icon on all items)"))
            .addItem(item => item.text.set("Gives Pattern Progress")))
            .addImage("./image/about/weapon-sorts.png")
            .addParagraph("Armour Sorts")
            .addList(list => list
            .addItem(item => item.text.set("Power"))
            .addItem(item => item.text.set("Name"))
            .addItem(item => item.text.set("Energy"))
            .addItem(item => item.text.set("Masterwork"))
            .addItem(item => item.text.set("Rarity"))
            .addItem(item => item.text.set("Shaped"))
            .addItem(item => item.text.set("Moment"))
            .addItem(item => item.text.set("Stat Total"))
            .addItem(item => item.text.set("Stat Distribution (Customisable, targeted distribution per-class. See below.)")))
            .addImage("./image/about/armour-sorts.png"))
            .addCard(card => card
            .tweak(card => card.heading
            .text.add("Press ")
            .append(Component_67.default.create("kbd")
            .text.set("E"))
            .text.add(" to show details on items"))
            .tweak(card => card.content.append(Component_67.default.create("p")
            .text.add("Just like in-game, you can hold ")
            .append(Component_67.default.create("kbd")
            .text.set("E"))
            .text.add(" to show extra details on items. If you'd like this to be a toggle instead, it can be changed in Settings.")))
            .addParagraph("The details that appear on items is based on the highest active sorts.")
            .addImage("./image/about/extra-details-on-armour-items.png"))
            .addCard(card => card
            .setTitle("Stat Distribution Sort")
            .addParagraph("Ideal armour is a high stat total in specific stats, and it changes based on build and class. When armour has low stat totals, it's easy to see that they should be dismantled. When they're high... it's a bit harder. To more easily determine at a glance which armour is good, deepsight.gg supports the Stat Distribution sort.")
            .addParagraph("To set custom targeted stat distributions, click the gear on the Stat Distribution sort, then the class you want to set a targeted distribution for.")
            .addParagraph("Stats in Destiny are split into two groups  group 1 is Mobility, Resilience, and Recovery, and group 2 is Discipline, Intellect, and Strength.Except for rare exceptions, each group can only roll a stat total of, at maximum, 34. Therefore, the ideal roll is 34 total in each group, distributed as you prefer.")
            .addParagraph("When a stat type is enabled, ie, the checkbox is checked, the quality of an armour roll will be based on how close that stat is to the exact value you select.")
            .addParagraph("When a stat type is disabled, ie, the checkbox is unchecked, the quality of an armour roll will be based on whether that stat, and any other unchecked stats, add up to the maximum roll of 34 for the group.")
            .addImage("./image/about/stat-distribution-1.png"))
            .addCard(card => card
            .setTitle("Examples")
            .addParagraph("I want hunter armour that is mostly in mobility and resilience for PvE. I uncheck mobility and resilience, and check recovery and set it to 2, the minimum value for a stat to be. That means that my Mob/Res/Rec group's distribution quality will be 100% if recovery is 2, and mobility and resilience add up to 32  a perfect roll.")
            .addImage("./image/about/stat-distribution-2.png")
            .addParagraph("I want warlock armour that is at minimum mobility, and maximum discipline. I uncheck resilience and recovery, and check mobility and set it to 2, the minimum value. I uncheck intellect and strength, and then check the discipline box and set it to the maximum of 30.")
            .addImage("./image/about/stat-distribution-3.png"))
            .addCard(card => card
            .setTitle("Player Overview")
            .addParagraph("Hovering over your bungie display name and code displays a player overview, including all characters' equipped items, and their average power. It also displays all characters' highest power items  this is the average that drops will be based around.")
            .addImage("./image/about/player-overview.png"))
            .addCard(card => card
            .setTitle("Details View")
            .addParagraph("Right clicking on weapons displays the perks and stats of weapons, just like in-game.")
            .addImage("./image/about/details-view.png"))
            .addCard(card => card
            .setTitle("Collections")
            .addParagraph("View a list of all weapons and armour from a particular moment  seasons, expansions, events, etc  and the possible rolls of each.")
            .addParagraph("When an event is active, it goes to the top.")
            .addParagraph("The shaped weapon icon means different things depending on the colour. Orange means the pattern is unlocked, but you haven't shaped that weapon yet. White means a pattern exists for the weapon, but you haven't completed it yet. Black means you've shaped the weapon, so it's irrelevant.")
            .addImage("./image/about/collections-view.png"))
            .addCard(card => card
            .setTitle("Details in collections item tooltips")
            .addParagraph("To see a quick preview of the perks that can roll on a weapon, simpy mouse over the item in collections, and it'll list the whole perk pool. Right clicking gives a more detailed view.")
            .addParagraph("The tooltip also displays any pattern progress.")
            .addImage("./image/about/pattern-progress.png"))
            .addCard(card => card
            .setTitle("Perk Wishlisting")
            .addParagraph("When inspecting a weapon in collections, you can add wishlisted rolls. If an item doesn't match your wishlist, it's displayed with a lime border and icon to show that it should be dismantled.")
            .addParagraph("When creating a wishlist, you can select any number of perks in each column.")
            .addList(list => list
            .addItem(item => item.text.set("If no perks are selected in a column, that means a weapon will match your wishlist no matter the perks it has in that column."))
            .addItem(item => item.text.set("If one perk is selected in a column, that means a weapon will match your wishlist only if it has that exact perk in that column."))
            .addItem(item => item.text.set("If more than one perk is selected in a column, that means a weapon will match your wishlist only if it has one or more of the perks you've selected in that column.")))
            .addImage("./image/about/perk-wishlisting.png")))
            .addSection(section => section
            .setTitle("FAQ")
            .addCard(card => card
            .setTitle("Will you ever add a view displaying everything, like DIM?")
            .addParagraph("Probably not, mostly because it's not really possible to display that many items all at one time without a cost to ease of use and aesthetics. I'm not really interested in sacrificing deepsight.gg's quality and performance just so that more items can be displayed in a long list you have to scroll through anyway."))
            .addCard(card => card
            .setTitle("Will you ever add support for loadouts, like DIM?")
            .addParagraph("Coming soon... hopefully."))
            .addCard(card => card
            .setTitle("Why can't I...")
            .addParagraph("deepsight.gg is made by Chiri Vulpes, a hobby project by a single developer, and it was primarily made for her own use cases  sorting her vault in a specific way, and wishlisting weapon rolls. She  or, well, I  would like to help a lot of other people get what they want out of an item manager, too, but it takes a while to do this stuff, so you'll have to be patient!")))
            .addSection(section => section)
            .addSection(section => section
            .setTitle("About")
            .addCard(card => card
            .style.set("margin-right", "0")
            .style.set("align-self", "flex-start")
            .addParagraph("deepsight.gg is a hobby project by a single developer, Chiri Vulpes. The greatest struggle she has is knowing whether she likes UI/UX work more or less than Destiny itself.")
            .tweak(card => card.content.append(Component_67.default.create("p")
            .text.add("This is an open source project, which means that the code is available for viewing, using, and contributing on ")
            .append(Component_67.default.create("a")
            .attributes.set("href", "https://github.com/ChiriVulpes/deepsight.gg")
            .attributes.set("target", "_blank")
            .text.set("GitHub"))
            .text.add(".")))
            .tweak(card => card.content.append(Component_67.default.create("p")
            .text.add("If you'd like to request a feature, report a bug, or even just chat, consider stopping by the ")
            .append(Component_67.default.create("a")
            .attributes.set("href", "https://discord.gg/dMFRMXZZnY")
            .attributes.set("target", "_blank")
            .text.set("Discord"))
            .text.add("!"))))
            .addCard(card => card
            .setTitle("Notes & Credits")
            .tweak(card => card.content.append(Component_67.default.create("p")
            .text.add("deepsight.gg would not exist without the prior art of other community-made Destiny apps (mainly ")
            .append(Component_67.default.create("a")
            .attributes.set("href", "https://app.destinyitemmanager.com/")
            .attributes.set("target", "_blank")
            .text.set("Destiny Item Manager"))
            .text.add(" and ")
            .append(Component_67.default.create("a")
            .attributes.set("href", "https://bray.tech/")
            .attributes.set("target", "_blank")
            .text.set("Braytech"))
            .text.add(") and the amazing resources that are: ")))
            .addList(list => list
            .addItem(item => item.append(Component_67.default.create("a")
            .attributes.set("href", "https://github.com/DestinyItemManager/bungie-api-ts")
            .attributes.set("target", "_blank")
            .text.set("Bungie API TypeScript support")))
            .addItem(item => item.append(Component_67.default.create("a")
            .attributes.set("href", "https://github.com/DestinyItemManager/d2-additional-info")
            .attributes.set("target", "_blank")
            .text.set("d2-additional-info")))
            .addItem(item => item.append(Component_67.default.create("a")
            .attributes.set("href", "https://github.com/justrealmilk/destiny-icons")
            .attributes.set("target", "_blank")
            .text.set("Destiny Icons"))))
            .tweak(card => card.content.append(Component_67.default.create("p")
            .text.add("Some (rare) parts of deepsight.gg are ported straight from DIM, such as ")
            .append(Component_67.default.create("a")
            .attributes.set("href", "https://github.com/ChiriVulpes/deepsight.gg/blob/main/src/ui/inventory/tooltip/stats/RecoilDirection.ts")
            .attributes.set("target", "_blank")
            .text.set("RecoilDirection.ts"))
            .text.add(". There is basically zero chance I would've been smart enough to do that, given that I'm primarily a UI/UX developer.")))
            .addParagraph("deepsight.gg takes heavy hints from both Destiny 2 and Braytech. There is nothing that I love more than making UI look pretty and be easy to use, and the UIs in Braytech especially have been a huge inspiration."))))),
    });
});
define("ui/TextLogo", ["require", "exports", "ui/component/Component", "utility/Env"], function (require, exports, Component_68, Env_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextLogoClasses;
    (function (TextLogoClasses) {
        TextLogoClasses["Main"] = "text-logo";
        TextLogoClasses["Deep"] = "text-logo-deep";
        TextLogoClasses["Sight"] = "text-logo-sight";
        TextLogoClasses["Dot"] = "text-logo-dot";
        TextLogoClasses["Gg"] = "text-logo-gg";
        TextLogoClasses["NonProd"] = "text-logo-nonprod";
    })(TextLogoClasses || (TextLogoClasses = {}));
    class TextLogo extends Component_68.default {
        onMake() {
            this.classes.add(TextLogoClasses.Main)
                .append(Component_68.default.create("span")
                .classes.add(TextLogoClasses.Deep)
                .text.set("deep")
                .append(Env_7.default.DEEPSIGHT_ENVIRONMENT === "prod" ? undefined : Component_68.default.create("span")
                .classes.add(TextLogoClasses.NonProd)
                .text.set(Env_7.default.DEEPSIGHT_ENVIRONMENT === "dev" ? "est" : "er")))
                .append(Component_68.default.create("span")
                .classes.add(TextLogoClasses.Sight)
                .text.set("sight"))
                .append(Component_68.default.create("span")
                .classes.add(TextLogoClasses.Dot)
                .text.set("."))
                .append(Component_68.default.create("span")
                .classes.add(TextLogoClasses.Gg)
                .text.set("gg"));
        }
    }
    exports.default = TextLogo;
});
define("ui/component/Label", ["require", "exports", "ui/component/Component"], function (require, exports, Component_69) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LabelClasses = void 0;
    var LabelClasses;
    (function (LabelClasses) {
        LabelClasses["Main"] = "label-wrapper";
        LabelClasses["Label"] = "label";
        LabelClasses["Content"] = "label-content";
    })(LabelClasses || (exports.LabelClasses = LabelClasses = {}));
    class Label extends Component_69.default {
        onMake() {
            this.classes.add(LabelClasses.Main);
            this.label = Component_69.default.create()
                .classes.add(LabelClasses.Label)
                .appendTo(this);
            this.content = Component_69.default.create()
                .classes.add(LabelClasses.Content)
                .appendTo(this);
        }
    }
    exports.default = Label;
});
define("ui/view/AuthView", ["require", "exports", "ui/TextLogo", "ui/component/Button", "ui/component/Component", "ui/component/Label", "ui/utility/Classes", "ui/view/AboutView", "ui/view/View", "utility/Async", "utility/Env", "utility/endpoint/bungie/Bungie"], function (require, exports, TextLogo_1, Button_16, Component_70, Label_1, Classes_23, AboutView_1, View_5, Async_8, Env_8, Bungie_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthViewClasses = void 0;
    var AuthViewClasses;
    (function (AuthViewClasses) {
        AuthViewClasses["Logo"] = "view-auth-logo";
        AuthViewClasses["Header"] = "view-auth-header";
        AuthViewClasses["Title"] = "view-auth-title";
        AuthViewClasses["State"] = "view-auth-state";
        AuthViewClasses["AuthButton"] = "view-auth-button-auth";
        AuthViewClasses["Nav"] = "view-auth-nav";
        AuthViewClasses["Splash"] = "view-auth-splash";
        AuthViewClasses["About"] = "view-auth-about";
        AuthViewClasses["ScrollDownHint"] = "view-auth-scroll-down-hint";
    })(AuthViewClasses || (exports.AuthViewClasses = AuthViewClasses = {}));
    exports.default = View_5.default.create({
        id: "auth",
        hash: null,
        name: "Authenticate",
        auth: "none",
        noDestinationButton: true,
        noProfileInURL: true,
        initialise: view => {
            if (Bungie_6.default.authenticated && Env_8.default.DEEPSIGHT_ENVIRONMENT !== "dev")
                return Async_8.default.sleep(1).then(() => viewManager.showDefaultView());
            view.content
                .append(Component_70.default.create()
                .classes.add(AuthViewClasses.Splash)
                .append(Component_70.default.create()
                .classes.add(AuthViewClasses.Header)
                .append(Component_70.default.create()
                .classes.add(AuthViewClasses.Logo, Classes_23.Classes.Logo))
                .append(TextLogo_1.default.create()
                .classes.add(AuthViewClasses.Title)))
                .append(Label_1.default.create()
                .classes.add(AuthViewClasses.State)
                .tweak(_ => _.label.text.set("Account"))
                .tweak(_ => _.content.text.set("Not Authenticated")))
                .append(Button_16.default.create()
                .classes.add(AuthViewClasses.AuthButton)
                .setPrimary()
                .setAttention()
                .setLaserFocus()
                .text.set("Authenticate")
                .event.subscribe("click", () => void Bungie_6.default.authenticate("start").catch(err => console.error(err)))));
            const scrollDownHint = Component_70.default.create()
                .classes.add(AuthViewClasses.ScrollDownHint)
                .text.set("Not convinced? Scroll down!")
                .appendTo(view.content);
            view.content.append(Component_70.default.create()
                .classes.add(AuthViewClasses.About)
                .append(View_5.default.WrapperComponent.create([AboutView_1.default])
                .classes.add(View_5.default.Classes.Subview)));
            view.content.event.subscribe("scroll", () => {
                scrollDownHint.classes.toggle(view.content.element.scrollTop > 0, Classes_23.Classes.Hidden);
            });
        },
    });
});
define("ui/view/ErrorView", ["require", "exports", "ui/component/Button", "ui/view/View", "utility/endpoint/bungie/Bungie"], function (require, exports, Button_17, View_6, Bungie_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ErrorViewClasses;
    (function (ErrorViewClasses) {
        ErrorViewClasses["Button"] = "view-error-button";
    })(ErrorViewClasses || (ErrorViewClasses = {}));
    exports.default = View_6.default.create({
        id: "error",
        name: "Error",
        redirectOnLoad: true,
        noDestinationButton: true,
        noHashChange: true,
        initialise: view => {
            let [_, code, definition] = view._args;
            if (!definition) {
                if (Bungie_7.default.apiDown)
                    definition = {
                        title: "Error: Weasel",
                        subtitle: "Could not connect to Destiny 2 servers...",
                        buttonText: "Bungie Help Twitter",
                        buttonClick: () => window.open("https://twitter.com/BungieHelp", "_blank")?.focus(),
                    };
                else if (code === 404)
                    definition = {
                        title: "Error: Not Found",
                        subtitle: "You are forever lost in the dark corners of time...",
                        buttonText: "Return to Orbit",
                        buttonClick: () => viewManager.showDefaultView(),
                    };
                else
                    definition = {
                        title: "Your Light Fades Away...",
                        subtitle: "Restarting From Last Checkpoint...",
                        buttonText: "Reload App",
                        buttonClick: () => location.reload(),
                    };
            }
            view.setTitle(title => title.text.set(definition.title));
            view.setSubtitle("small", subtitle => subtitle.text.set(definition.subtitle));
            Button_17.default.create()
                .classes.add(ErrorViewClasses.Button)
                .setPrimary()
                .setAttention()
                .text.set(definition.buttonText)
                .event.subscribe("click", definition.buttonClick)
                .appendTo(view.content);
        },
    });
});
define("model/models/Moments", ["require", "exports", "model/Model", "model/models/Manifest", "model/models/ProfileBatch"], function (require, exports, Model_15, Manifest_22, ProfileBatch_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Model_15.default.createDynamic("Daily", async (api) => {
        const { DeepsightMomentDefinition, DestinyEventCardDefinition } = await api.subscribeProgressAndWait(Manifest_22.default, 1 / 3);
        const profile = ProfileBatch_9.default.latest ?? await api.subscribeProgressAndWait(ProfileBatch_9.default, 1 / 3, 1 / 3);
        api.emitProgress(2 / 3, "Loading moments");
        const moments = await DeepsightMomentDefinition.all();
        const result = [];
        for (let moment of moments) {
            if (typeof moment.event === "number") {
                const eventCard = await DestinyEventCardDefinition.get(moment.event);
                if (eventCard)
                    moment = { ...moment, eventCard };
            }
            result.push(moment);
        }
        result.sort((a, b) => getSortIndex(profile, b) - getSortIndex(profile, a));
        return result;
    });
    function getSortIndex(profile, moment) {
        if (profile?.profile?.data?.activeEventCardHash !== moment.eventCard?.hash)
            return moment.hash;
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        const eventCardEndTime = +moment.eventCard?.endTime;
        if (eventCardEndTime && eventCardEndTime * 1000 > Date.now())
            return Infinity; // current event gets sorted highest
        return moment.hash;
    }
});
define("ui/component/Timestamp", ["require", "exports", "ui/component/Component", "ui/utility/Classes", "utility/Time", "utility/decorator/Bound"], function (require, exports, Component_71, Classes_24, Time_7, Bound_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimestampClasses = void 0;
    var TimestampClasses;
    (function (TimestampClasses) {
        TimestampClasses["Main"] = "timestamp";
    })(TimestampClasses || (exports.TimestampClasses = TimestampClasses = {}));
    // note: these components persist in memory forever
    class Timestamp extends Component_71.default {
        constructor() {
            super(...arguments);
            this.rendering = false;
        }
        onMake(time, format = "relative", options) {
            this.classes.add(TimestampClasses.Main);
            this.setTime(time);
            this.setDisplayMode(format, options);
        }
        setDisplayMode(mode, options) {
            this.mode = mode;
            this.options = options;
            if (!this.rendering)
                this.render();
            return this;
        }
        setTime(time) {
            this.time = time;
            this.classes.toggle(time === undefined, Classes_24.Classes.Hidden);
            if (time === undefined)
                return this.text.set("");
            if (!this.rendering)
                this.render();
            return this;
        }
        render() {
            this.rendering = true;
            const time = this.time ?? 0;
            this.text.set(time - Date.now() < 0 ? "expired" : Time_7.default[this.mode]?.(this.time ?? 0, this.options));
            if (this.mode === "relative")
                window.setTimeout(this.render, 900); // less than 1 second so that we never miss a second
            else
                this.rendering = false;
        }
    }
    Timestamp.defaultType = "span";
    exports.default = Timestamp;
    __decorate([
        Bound_26.default
    ], Timestamp.prototype, "render", null);
});
define("ui/view/collections/ExoticArmourRewardComponent", ["require", "exports", "ui/destiny/component/ItemComponent", "utility/Env"], function (require, exports, ItemComponent_5, Env_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExoticArmourRewardComponentClasses = void 0;
    var ExoticArmourRewardComponentClasses;
    (function (ExoticArmourRewardComponentClasses) {
        ExoticArmourRewardComponentClasses["Main"] = "item-exotic-armour-reward";
    })(ExoticArmourRewardComponentClasses || (exports.ExoticArmourRewardComponentClasses = ExoticArmourRewardComponentClasses = {}));
    const paths = {
        [176055472 /* InventoryItemHashes.IfSoloExoticChestArmorRareDummy */]: "image/png/item/chest.png",
        [1387420892 /* InventoryItemHashes.IfSoloExoticHeadArmorRareDummy */]: "image/png/item/head.png",
        [2850782006 /* InventoryItemHashes.IfSoloExoticLegsArmorRareDummy */]: "image/png/item/legs.png",
        [1572351682 /* InventoryItemHashes.IfSoloExoticArmsArmorRareDummy */]: "image/png/item/arms.png",
    };
    class ExoticArmourRewardComponent extends ItemComponent_5.default {
        static is(item) {
            return item.definition.hash in paths;
        }
        async onMake(item, inventory) {
            item.reference.state = 4 /* ItemState.Masterwork */;
            await super.onMake(item, inventory);
            this.classes.add(ExoticArmourRewardComponentClasses.Main);
            this.clearTooltip();
        }
        initialiseIcon(icon) {
            const path = paths[this.item?.definition.hash];
            if (path) {
                icon.setPath(Env_9.default.path(path));
            }
        }
    }
    exports.default = ExoticArmourRewardComponent;
});
define("ui/view/collections/ICollectionsView", ["require", "exports", "ui/destiny/component/ItemComponent", "ui/destiny/component/Slot", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager", "ui/utility/DisplayProperties", "ui/view/collections/ExoticArmourRewardComponent"], function (require, exports, ItemComponent_6, Slot_5, Filter_25, FilterManager_5, Sort_30, SortManager_6, DisplayProperties_15, ExoticArmourRewardComponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FILTER_MANAGER_COLLECTIONS = exports.SORT_MANAGER_COLLECTIONS = exports.FILTER_MANAGER_COLLECTIONS_DEFINITION = exports.SORT_MANAGER_COLLECTIONS_DEFINITION = exports.VIEW_NAME_COLLECTIONS = exports.VIEW_ID_COLLECTIONS = exports.FILTERS_INAPPLICABLE_COLLECTIONS = exports.SORTS_INAPPLICABLE_COLLECTIONS = exports.SORTS_DEFAULT_COLLECTIONS = void 0;
    exports.SORTS_DEFAULT_COLLECTIONS = [
        Sort_30.default.Exotic,
        Sort_30.default.Rarity,
        { reverse: Sort_30.default.Shaped },
        { reverse: Sort_30.default.CanShape },
        Sort_30.default.Pattern,
    ];
    exports.SORTS_INAPPLICABLE_COLLECTIONS = [
        Sort_30.default.Quantity,
        Sort_30.default.Harmonizable,
        Sort_30.default.Locked,
        Sort_30.default.Power,
        Sort_30.default.StatTotal,
        Sort_30.default.StatDistribution,
        Sort_30.default.StatLegacyDistribution,
        Sort_30.default.Masterwork,
        Sort_30.default.Energy,
    ];
    exports.FILTERS_INAPPLICABLE_COLLECTIONS = [
        Filter_25.default.Locked,
        Filter_25.default.Masterwork,
        Filter_25.default.Unlevelled,
    ];
    exports.VIEW_ID_COLLECTIONS = "collections";
    exports.VIEW_NAME_COLLECTIONS = "Collections";
    exports.SORT_MANAGER_COLLECTIONS_DEFINITION = {
        id: exports.VIEW_ID_COLLECTIONS,
        name: exports.VIEW_NAME_COLLECTIONS,
        default: exports.SORTS_DEFAULT_COLLECTIONS,
        inapplicable: exports.SORTS_INAPPLICABLE_COLLECTIONS,
    };
    exports.FILTER_MANAGER_COLLECTIONS_DEFINITION = {
        id: exports.VIEW_ID_COLLECTIONS,
        name: exports.VIEW_NAME_COLLECTIONS,
        inapplicable: exports.FILTERS_INAPPLICABLE_COLLECTIONS,
    };
    exports.SORT_MANAGER_COLLECTIONS = new SortManager_6.default(exports.SORT_MANAGER_COLLECTIONS_DEFINITION);
    exports.FILTER_MANAGER_COLLECTIONS = new FilterManager_5.default(exports.FILTER_MANAGER_COLLECTIONS_DEFINITION);
    var ICollectionsView;
    (function (ICollectionsView) {
        const bucketOrder = [
            1498876634 /* InventoryBucketHashes.KineticWeapons */,
            2465295065 /* InventoryBucketHashes.EnergyWeapons */,
            953998645 /* InventoryBucketHashes.PowerWeapons */,
            3448274439 /* InventoryBucketHashes.Helmet */,
            3551918588 /* InventoryBucketHashes.Gauntlets */,
            14239492 /* InventoryBucketHashes.ChestArmor */,
            20886954 /* InventoryBucketHashes.LegArmor */,
            1585787867 /* InventoryBucketHashes.ClassArmor */,
        ];
        function sortItems(items, inventory, sorter) {
            return items.sort(!sorter ? undefined : (a, b) => sorter.sort(a, b, false), item => item.definition.inventory?.tierType ?? 0 /* TierType.Unknown */, item => item.isWeapon() ? 1 : 0, item => item.deepsight?.pattern ? inventory?.isCrafted(item.definition.hash) ? 0 : item.deepsight.pattern.progress?.complete ? 1 : 3 : 2, item => item.isAdept() ? 1 : 0, item => item.definition.classType ?? 3 /* DestinyClass.Unknown */, (a, b) => (a.collectible?.sourceHash ?? -1) - (b.collectible?.sourceHash ?? -1), 
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            item => 999 - (bucketOrder.indexOf(item.definition.inventory?.bucketTypeHash) + 1), (a, b) => (a.collectible?.index ?? 0) - (b.collectible?.index ?? 0), (a, b) => (DisplayProperties_15.default.name(a.definition) ?? "").localeCompare(DisplayProperties_15.default.name(b.definition) ?? ""));
        }
        ICollectionsView.sortItems = sortItems;
        function addItems(component, items, inventory, sorter, result) {
            component.append(...sortItems(items, inventory, sorter)
                .map(item => {
                const component = ExoticArmourRewardComponent_1.default.is(item) ? ExoticArmourRewardComponent_1.default.create([item, inventory])
                    : ItemComponent_6.default.create([item, inventory])
                        .setSortedBy(sorter);
                result?.push(component);
                return Slot_5.default.create().append(component);
            }));
        }
        ICollectionsView.addItems = addItems;
    })(ICollectionsView || (ICollectionsView = {}));
    exports.default = ICollectionsView;
});
define("ui/view/collections/CollectionsCurrentlyAvailableActivity", ["require", "exports", "model/models/Characters", "model/models/items/Source", "ui/component/Card", "ui/component/Component", "ui/component/Timestamp", "ui/utility/DisplayProperties", "ui/view/collections/ICollectionsView"], function (require, exports, Characters_10, Source_2, Card_5, Component_72, Timestamp_1, DisplayProperties_16, ICollectionsView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionsCurrentlyAvailableActivity = exports.CollectionsCurrentlyAvailableActivityClasses = void 0;
    const _ = undefined;
    const moreInfoLinks = {
        'nightfall': 'https://bray.tech/weeklies#nightfall',
        'lost-sector': 'https://bray.tech/weeklies#lost-sector',
        'dungeon': 'https://bray.tech/weeklies#dungeon',
        'raid': 'https://bray.tech/weeklies#raid',
    };
    const rotationLinks = {
        'nightfall': 'https://bray.tech/weeklies/rotations#nightfall',
        'lost-sector': 'https://bray.tech/weeklies/rotations#lost-sector',
        'dungeon': 'https://bray.tech/weeklies/rotations#dungeon',
        'raid': 'https://bray.tech/weeklies/rotations#raid',
        'exotic-mission': 'https://bray.tech/weeklies/rotations#exotic-mission',
    };
    var CollectionsCurrentlyAvailableActivityClasses;
    (function (CollectionsCurrentlyAvailableActivityClasses) {
        CollectionsCurrentlyAvailableActivityClasses["Activity"] = "view-collections-currently-available-activity";
        CollectionsCurrentlyAvailableActivityClasses["ActivityIcon"] = "view-collections-currently-available-activity-icon";
        CollectionsCurrentlyAvailableActivityClasses["ActivityIconContainer"] = "view-collections-currently-available-activity-icon-container";
        CollectionsCurrentlyAvailableActivityClasses["ActivityTitle"] = "view-collections-currently-available-activity-title";
        CollectionsCurrentlyAvailableActivityClasses["ActivityDescription"] = "view-collections-currently-available-activity-description";
        CollectionsCurrentlyAvailableActivityClasses["ActivityRewards"] = "view-collections-currently-available-activity-rewards";
        CollectionsCurrentlyAvailableActivityClasses["ActivityRewardsLong"] = "view-collections-currently-available-activity-rewards-long";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeader"] = "view-collections-currently-available-activity-header";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeaderBookmark"] = "view-collections-currently-available-activity-header-bookmark";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeaderBookmarkIcon"] = "view-collections-currently-available-activity-header-bookmark-icon";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeaderSubtitle"] = "view-collections-currently-available-activity-header-subtitle";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeaderSubtitleNote"] = "view-collections-currently-available-activity-header-subtitle-note";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeaderSubtitleExpiry"] = "view-collections-currently-available-activity-header-subtitle-expiry";
        CollectionsCurrentlyAvailableActivityClasses["ActivityHeaderSubtitleExpiryLink"] = "view-collections-currently-available-activity-header-subtitle-expiry-link";
    })(CollectionsCurrentlyAvailableActivityClasses || (exports.CollectionsCurrentlyAvailableActivityClasses = CollectionsCurrentlyAvailableActivityClasses = {}));
    class CollectionsCurrentlyAvailableActivity extends Card_5.default {
        onMake(activity, source, activityType, items, inventory) {
            super.onMake(activity, source, activityType, items, inventory);
            this.source = source;
            this.setDisplayMode(Card_5.CardClasses.DisplayModeCard);
            this.classes.add(CollectionsCurrentlyAvailableActivityClasses.Activity);
            this.attributes.set('tabindex', '0');
            const icon = source?.dropTable.displayProperties?.icon;
            // wrap the icon in a container so we can make it really big and use overflow hidden on it 
            Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityIconContainer)
                .append(this.icon.classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityIcon)
                .style.set('--icon', DisplayProperties_16.default.icon(icon) ?? DisplayProperties_16.default.icon(activity) ?? DisplayProperties_16.default.icon(source.dropTable.typeDisplayProperties)))
                .prependTo(this);
            this.background.attributes.set('src', `https://www.bungie.net${source?.dropTable.pgcrImage ?? activity.pgcrImage}`);
            // ensure fake card header (which contains the card hover sheen and the box shadow contrast reducer border) 
            // is after the icon & background
            this.header.appendTo(this);
            // overwrite header with the real one
            this.header = Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeader)
                .insertToBefore(this, this.contentWrapper);
            Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeaderBookmark)
                .style.set('--background', `var(--background-${source.dropTable.type})`)
                .append(Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeaderBookmarkIcon)
                .style.set('--icon', DisplayProperties_16.default.icon(source.dropTable.typeDisplayProperties) ?? DisplayProperties_16.default.icon(icon) ?? DisplayProperties_16.default.icon(activity)))
                .appendTo(this.header);
            const note = source.type === Source_2.SourceType.Rotator ? 'Rotator'
                : source.type === Source_2.SourceType.Repeatable ? 'Repeatable'
                    : source.type === Source_2.SourceType.New ? 'Recent'
                        : undefined;
            let expiryWrapper;
            Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeaderSubtitle)
                .text.add(DisplayProperties_16.default.name(source.dropTable.typeDisplayProperties) ?? 'Unknown')
                .append(note && Component_72.default.create('span')
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeaderSubtitleNote)
                .text.add(' \xa0 // \xa0 ')
                .text.add(note))
                .append(!source.endTime ? undefined : expiryWrapper = Component_72.default.create('span')
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeaderSubtitleExpiry)
                .text.add(' \xa0 / \xa0 '))
                .appendTo(this.header);
            const timestamp = expiryWrapper && Timestamp_1.default.create([source.endTime, 'relative', { components: 2, label: false }])
                .appendTo(expiryWrapper);
            const rotationLink = expiryWrapper && rotationLinks[source.dropTable.type];
            if (rotationLink)
                Component_72.default.create('a')
                    .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityHeaderSubtitleExpiryLink)
                    .attributes.set('href', rotationLink)
                    .attributes.set('target', '_blank')
                    .append(timestamp)
                    .appendTo(expiryWrapper);
            const moreInfoLink = moreInfoLinks[source.dropTable.type];
            if (moreInfoLink)
                this.event.subscribe('contextmenu', () => window.open(moreInfoLink, '_blank'));
            this.title.classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityTitle)
                .text.set(_
                ?? DisplayProperties_16.default.name(source.dropTable.displayProperties)
                ?? DisplayProperties_16.default.name(activity))
                .appendTo(this.content); // the title should be part of the content instead of part of the header
            Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityDescription)
                .tweak(DisplayProperties_16.default.applyDescription, (_
                ?? DisplayProperties_16.default.description(source.dropTable.displayProperties)
                ?? DisplayProperties_16.default.description(activity)), {
                character: Characters_10.default.getCurrent()?.characterId,
                singleLine: true,
            })
                .appendTo(this.content);
            const rewards = Component_72.default.create()
                .classes.add(CollectionsCurrentlyAvailableActivityClasses.ActivityRewards)
                .classes.toggle(items.length > 10, CollectionsCurrentlyAvailableActivityClasses.ActivityRewardsLong)
                .style.set('--length', `${items.length > 10 ? 8 : items.length}`)
                .appendTo(this.content);
            ICollectionsView_1.default.addItems(rewards, items, inventory);
        }
    }
    exports.CollectionsCurrentlyAvailableActivity = CollectionsCurrentlyAvailableActivity;
});
define("ui/view/collections/CollectionsMoment", ["require", "exports", "model/Model", "model/models/Characters", "model/models/Manifest", "model/models/items/Bucket", "ui/component/Component", "ui/component/Details", "ui/component/Loadable", "ui/destiny/component/Slot", "ui/view/collections/ICollectionsView"], function (require, exports, Model_16, Characters_11, Manifest_23, Bucket_12, Component_73, Details_2, Loadable_5, Slot_6, ICollectionsView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionsMomentClasses = void 0;
    var CollectionsMomentClasses;
    (function (CollectionsMomentClasses) {
        CollectionsMomentClasses["Moment"] = "view-collections-moment";
        CollectionsMomentClasses["MomentContent"] = "view-collections-moment-content";
        CollectionsMomentClasses["Bucket"] = "view-collections-bucket";
        CollectionsMomentClasses["BucketTitle"] = "view-collections-bucket-title";
        CollectionsMomentClasses["FilteredOut"] = "view-collections-filtered-out";
    })(CollectionsMomentClasses || (exports.CollectionsMomentClasses = CollectionsMomentClasses = {}));
    class CollectionsMoment extends Details_2.default {
        constructor() {
            super(...arguments);
            this.forcedOpen = false;
        }
        onMake(moment, inventory, defaultOpen = false) {
            super.onMake(moment, inventory);
            this.inventory = inventory;
            this.event.subscribe("toggle", () => this.forcedOpen = false);
            this.classes.add(CollectionsMomentClasses.Moment)
                .toggle(defaultOpen)
                .tweak(details => details.summary.text.set(moment.displayProperties.name));
            Loadable_5.default.create(Model_16.default.createTemporary(async () => {
                // if (!defaultOpen)
                // 	await this.event.waitFor("toggle");
                const { DeepsightCollectionsDefinition } = await Manifest_23.default.await();
                const collection = await DeepsightCollectionsDefinition.get(moment.hash);
                return Bucket_12.Bucket.COLLECTIONS.items
                    .filter(item => Object.values(collection?.buckets ?? {})
                    .some(hashes => hashes.includes(item.definition.hash)));
            }))
                .onReady(items => {
                const weapons = [];
                const classItems = {};
                for (const item of items) {
                    if (item.isWeapon()) {
                        weapons.push(item);
                        continue;
                    }
                    (classItems[item.definition.classType] ??= [])
                        .push(item);
                }
                const wrapper = Component_73.default.create()
                    .classes.add(CollectionsMomentClasses.MomentContent);
                if (weapons.length) {
                    this.weaponsBucket = Component_73.default.create()
                        .classes.add(CollectionsMomentClasses.Bucket)
                        .append(Component_73.default.create()
                        .classes.add(CollectionsMomentClasses.BucketTitle)
                        .text.set("Weapons"))
                        .tweak(ICollectionsView_2.default.addItems, weapons, inventory, ICollectionsView_2.SORT_MANAGER_COLLECTIONS, this.weaponComponents ??= [])
                        .appendTo(wrapper);
                }
                const classes = Characters_11.default.getSortedClasses()
                    .concat(0 /* DestinyClass.Titan */, 1 /* DestinyClass.Hunter */, 2 /* DestinyClass.Warlock */)
                    .distinct();
                for (const cls of classes) {
                    const items = classItems[cls];
                    if (!items?.length)
                        continue;
                    (this.armourBuckets ??= {})[cls] = Component_73.default.create()
                        .classes.add(CollectionsMomentClasses.Bucket)
                        .append(Component_73.default.create()
                        .classes.add(CollectionsMomentClasses.BucketTitle)
                        .text.set(cls === 0 /* DestinyClass.Titan */ ? "Titan" : cls === 1 /* DestinyClass.Hunter */ ? "Hunter" : "Warlock")
                        .text.add(" Armor"))
                        .tweak(ICollectionsView_2.default.addItems, items, inventory, ICollectionsView_2.SORT_MANAGER_COLLECTIONS, (this.armourComponents ??= {})[cls] ??= [])
                        .appendTo(wrapper);
                }
                this.filter();
                return wrapper;
            })
                .setSimple()
                .appendTo(this);
            inventory?.event.subscribe("update", () => {
                this.sort();
                this.filter();
            });
        }
        sort() {
            // mark old slots for removal
            const buckets = [this.weaponsBucket, ...Object.values(this.armourBuckets ??= {})];
            for (const bucket of buckets)
                for (const slot of bucket?.element.getElementsByClassName(Slot_6.SlotClasses.Main) ?? [])
                    slot.classList.add("pending-removal");
            // sort
            const components = [this.weaponComponents, ...Object.values(this.armourComponents ??= {})];
            for (const componentList of components) {
                if (!componentList)
                    continue;
                const sortedItems = ICollectionsView_2.default.sortItems(componentList.map(component => component.item), this.inventory, ICollectionsView_2.SORT_MANAGER_COLLECTIONS);
                componentList.sort((a, b) => sortedItems.indexOf(a.item) - sortedItems.indexOf(b.item));
            }
            // append
            for (const weaponComponent of this.weaponComponents ?? [])
                weaponComponent.appendTo(Slot_6.default.create().appendTo(this.weaponsBucket));
            for (const cls of Object.keys(this.armourBuckets).map(k => +k))
                for (const armourComponent of this.armourComponents[cls] ?? [])
                    armourComponent.appendTo(Slot_6.default.create().appendTo(this.armourBuckets[cls]));
            // remove old slots
            for (const bucket of buckets)
                for (const slot of [...bucket?.element.getElementsByClassName("pending-removal") ?? []])
                    slot.remove();
            this.filter();
        }
        filter() {
            const components = [this.weaponComponents, ...Object.values(this.armourComponents ??= {})];
            for (const componentList of components) {
                for (const component of componentList ?? []) {
                    const filteredOut = !ICollectionsView_2.FILTER_MANAGER_COLLECTIONS.apply(component.item);
                    component.element.parentElement?.classList.toggle(CollectionsMomentClasses.FilteredOut, filteredOut);
                }
            }
            const buckets = [this.weaponsBucket, ...Object.values(this.armourBuckets ??= {})];
            for (const bucket of buckets)
                bucket?.classes.toggle(!bucket?.element.querySelector(`.${Slot_6.SlotClasses.Main}:not(.${CollectionsMomentClasses.FilteredOut})`), CollectionsMomentClasses.FilteredOut);
            const hidden = buckets.every(bucket => bucket?.classes.has(CollectionsMomentClasses.FilteredOut));
            this.classes.toggle(hidden, CollectionsMomentClasses.FilteredOut);
            if (this.forcedOpen && (hidden || !ICollectionsView_2.FILTER_MANAGER_COLLECTIONS.isFiltered())) {
                this.close();
                this.forcedOpen = false;
            }
            else if (ICollectionsView_2.FILTER_MANAGER_COLLECTIONS.isFiltered() && !hidden && !this.isOpen()) {
                this.open();
                this.forcedOpen = true;
            }
        }
    }
    exports.default = CollectionsMoment;
});
define("ui/view/collections/CollectionsCurrentlyAvailable", ["require", "exports", "model/models/items/Item", "ui/component/Component", "ui/component/Details", "ui/component/Paginator", "ui/view/collections/CollectionsCurrentlyAvailableActivity", "ui/view/collections/CollectionsMoment", "utility/Arrays", "utility/Objects"], function (require, exports, Item_6, Component_74, Details_3, Paginator_2, CollectionsCurrentlyAvailableActivity_1, CollectionsMoment_1, Arrays_16, Objects_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionsCurrentlyAvailableClasses = void 0;
    var CollectionsCurrentlyAvailableClasses;
    (function (CollectionsCurrentlyAvailableClasses) {
        CollectionsCurrentlyAvailableClasses["Main"] = "view-collections-currently-available";
        CollectionsCurrentlyAvailableClasses["Heading"] = "view-collections-currently-available-heading";
        CollectionsCurrentlyAvailableClasses["ActivityWrapperPaginator"] = "view-collections-currently-available-activity-wrapper-paginator";
        CollectionsCurrentlyAvailableClasses["ActivityWrapperPaginatorButton"] = "view-collections-currently-available-activity-wrapper-paginator-button";
        CollectionsCurrentlyAvailableClasses["ActivityWrapper"] = "view-collections-currently-available-activity-wrapper";
        CollectionsCurrentlyAvailableClasses["ActivityWrapperPage"] = "view-collections-currently-available-activity-wrapper-page";
    })(CollectionsCurrentlyAvailableClasses || (exports.CollectionsCurrentlyAvailableClasses = CollectionsCurrentlyAvailableClasses = {}));
    const activityOrder = Object.keys({
        'trials': true,
        'lost-sector': true,
        'nightfall': true,
        'raid': true,
        'dungeon': true,
        'exotic-mission': true,
        'bonus-focus': true,
    });
    const availabilityOrder = ['rotator', 'new', 'repeatable', undefined];
    class CollectionsCurrentlyAvailable extends Details_3.default {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        async onMake(manifest, profile, inventory) {
            super.onMake(manifest, profile, inventory);
            this.classes.add(CollectionsCurrentlyAvailableClasses.Main, CollectionsMoment_1.CollectionsMomentClasses.Moment);
            this.summary.text.set('Currently Available');
            this.open();
            const items = await this.discoverItems(manifest, profile);
            const sources = items.flatMap(item => item.sources ?? Arrays_16.default.EMPTY)
                .map(source => source.masterActivityDefinition && (source.isActiveMasterDrop || source.masterActivityDefinition?.activityModeTypes?.includes(46 /* DestinyActivityModeType.ScoredNightfall */))
                ? Arrays_16.default.tuple(source.dropTable.hash, source.masterActivityDefinition, source)
                : Arrays_16.default.tuple(source.dropTable.hash, source.activityDefinition, source))
                .sort(([, , a], [, , b]) => a.type - b.type);
            // .filter((source): source is [number, DestinyActivityDefinition, ISource] => !!source);
            const activityWrapper = Paginator_2.default.create()
                .classes.add(CollectionsCurrentlyAvailableClasses.ActivityWrapperPaginator)
                .appendTo(this);
            activityWrapper.pageWrapper.classes.add(CollectionsCurrentlyAvailableClasses.ActivityWrapper);
            activityWrapper.buttonNext.classes.add(CollectionsCurrentlyAvailableClasses.ActivityWrapperPaginatorButton);
            activityWrapper.buttonPrev.classes.add(CollectionsCurrentlyAvailableClasses.ActivityWrapperPaginatorButton);
            const activityFiller = activityWrapper.filler(Component_74.default.window.width < 1200 ? 3 : 4, page => page
                .classes.add(CollectionsCurrentlyAvailableClasses.ActivityWrapperPage));
            const { DestinyActivityTypeDefinition, DestinyActivityModeDefinition } = manifest;
            const added = new Set();
            const activityCards = [];
            for (const [hash, activity, source] of sources) {
                if (added.has(hash))
                    continue;
                if (source.endTime && new Date(source.endTime).getTime() < Date.now())
                    continue;
                added.add(hash);
                const sourceItems = items.filter(item => item.sources?.some(source => source.dropTable.hash === hash && (false
                    || item.definition.hash in (source.dropTable.dropTable ?? Objects_5.default.EMPTY)
                    || source.dropTable.encounters?.some(encounter => item.definition.hash in (encounter.dropTable ?? Objects_5.default.EMPTY))
                    || source.isActiveDrop
                    || source.isActiveMasterDrop)));
                if (!sourceItems.length)
                    continue;
                // eslint-disable-next-line no-constant-condition
                const activityType = false ? undefined
                    // dungeon type doesn't have icon, use mode instead
                    : activity.activityTypeHash === 608898761 /* ActivityTypeHashes.Dungeon */ ? await DestinyActivityModeDefinition.get(608898761 /* ActivityModeHashes.Dungeon */)
                        // trials type doesn't have icon, use mode instead
                        : activity.activityTypeHash === 2112637710 /* ActivityTypeHashes.TrialsOfOsiris */ ? await DestinyActivityModeDefinition.get(1673724806 /* ActivityModeHashes.TrialsOfOsiris */)
                            // lost sector type doesn't have icon, use mode instead
                            : activity.activityTypeHash === 103143560 /* ActivityTypeHashes.LostSector */ ? await DestinyActivityModeDefinition.get(103143560 /* ActivityModeHashes.LostSector */)
                                : await DestinyActivityTypeDefinition.get(activity.activityTypeHash);
                activityCards.push(CollectionsCurrentlyAvailableActivity_1.CollectionsCurrentlyAvailableActivity.create([activity, source, activityType, sourceItems, inventory])
                    .event.subscribe('mouseenter', () => console.log(activity?.displayProperties?.name, activity, source)));
            }
            activityCards
                .sort((a, b) => activityOrder.indexOf(a.source.dropTable.type) - activityOrder.indexOf(b.source.dropTable.type))
                .sort((a, b) => availabilityOrder.indexOf(a.source.dropTable.availability) - availabilityOrder.indexOf(b.source.dropTable.availability))
                .forEach(card => card.appendTo(activityFiller.increment()));
        }
        async discoverItems(manifest, profile) {
            const itemHashes = new Set();
            const { DeepsightDropTableDefinition, DestinyInventoryItemDefinition, DestinyActivityDefinition } = manifest;
            const bonusFocusHashes = new Set();
            const dropTables = await DeepsightDropTableDefinition.all();
            for (const source of dropTables) {
                const masterActivityDefinition = await DestinyActivityDefinition.get(source.master?.activityHash);
                const intervals = source.rotations?.current ?? 0;
                if (source.availability) {
                    for (const dropHash of Object.keys(source.dropTable ?? Objects_5.default.EMPTY)) {
                        if (source.type === 'bonus-focus')
                            bonusFocusHashes.add(+dropHash);
                        itemHashes.add(+dropHash);
                    }
                    for (const encounter of source.encounters ?? [])
                        for (const dropHash of Object.keys(encounter.dropTable ?? Objects_5.default.EMPTY))
                            itemHashes.add(+dropHash);
                    if (source.rotations) {
                        const drop = resolveRotation(source.rotations.drops, intervals);
                        if (typeof drop === 'number')
                            itemHashes.add(drop);
                        else if (typeof drop === 'object')
                            for (const id of Object.keys(drop))
                                itemHashes.add(+id);
                    }
                }
                if (masterActivityDefinition) {
                    if (source.rotations) {
                        const masterDrop = resolveRotation(source.rotations.masterDrops, intervals);
                        if (typeof masterDrop === 'number')
                            itemHashes.add(masterDrop);
                        else if (typeof masterDrop === 'object')
                            for (const id of Object.keys(masterDrop))
                                itemHashes.add(+id);
                    }
                    for (const dropHash of Object.keys(source.master?.dropTable ?? Objects_5.default.EMPTY))
                        itemHashes.add(+dropHash);
                }
            }
            // let start = Date.now();
            const defs = await Promise.all(Array.from(itemHashes).map(hash => DestinyInventoryItemDefinition.get(hash)));
            // console.log("defs", Date.now() - start);
            // start = Date.now();
            const items = await Promise.all(defs.map(def => def && Item_6.default.createFake(manifest, profile ?? {}, def)));
            // console.log("fake items", Date.now() - start);
            return items.filter((item) => !!item && (bonusFocusHashes.has(item.definition.hash) || item.isWeapon() || item.isExotic()));
        }
    }
    exports.default = CollectionsCurrentlyAvailable;
    function resolveRotation(rotation, interval) {
        return !rotation?.length ? undefined : rotation?.[interval % rotation.length];
    }
});
define("ui/view/collections/CollectionsView", ["require", "exports", "model/Model", "model/models/Inventory", "model/models/Manifest", "model/models/Moments", "model/models/ProfileBatch", "ui/destiny/component/HintsDrawer", "ui/destiny/component/IItemComponent", "ui/destiny/filter/FilterManager", "ui/destiny/filter/ItemFilter", "ui/destiny/sort/ItemSort", "ui/utility/UiEventBus", "ui/view/View", "ui/view/collections/CollectionsCurrentlyAvailable", "ui/view/collections/CollectionsMoment", "ui/view/collections/ICollectionsView"], function (require, exports, Model_17, Inventory_6, Manifest_24, Moments_1, ProfileBatch_10, HintsDrawer_2, IItemComponent_5, FilterManager_6, ItemFilter_2, ItemSort_2, UiEventBus_9, View_7, CollectionsCurrentlyAvailable_1, CollectionsMoment_2, ICollectionsView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const CollectionsViewModel = Model_17.default.createTemporary(async (api) => {
        api.emitProgress(0, "Loading collections");
        const profile = ProfileBatch_10.default.latest ?? await api.subscribeProgressAndWait(ProfileBatch_10.default, 0.5);
        const inventory = await api.subscribeProgressAndWait(Inventory_6.default.createModel(), 0.5, 0.5);
        return [profile, inventory];
    });
    exports.default = View_7.default.create({
        models: [Manifest_24.default, Moments_1.default, CollectionsViewModel],
        id: ICollectionsView_3.VIEW_ID_COLLECTIONS,
        name: ICollectionsView_3.VIEW_NAME_COLLECTIONS,
        auth: "optional",
        initialise: async (view, manifest, moments, [profile, inventory]) => {
            view.setTitle(title => title.text.set("Collections"));
            await FilterManager_6.default.init();
            CollectionsCurrentlyAvailable_1.default.create([manifest, profile, inventory])
                .appendTo(view.content);
            const momentWrappers = [];
            let shownExpansion = false;
            let shownSeason = false;
            for (const moment of moments) {
                let defaultOpen = false;
                if (!shownExpansion && moment.expansion) {
                    defaultOpen = true;
                    shownExpansion = true;
                }
                if (!shownSeason && moment.season) {
                    defaultOpen = true;
                    shownSeason = true;
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                if (profile?.profile?.data?.activeEventCardHash === moment.eventCard?.hash && (+moment.eventCard?.endTime || 0) * 1000 > Date.now())
                    defaultOpen = true;
                const wrapper = CollectionsMoment_2.default.create([moment, inventory, defaultOpen])
                    .appendTo(view.content);
                momentWrappers.push(wrapper);
            }
            ItemSort_2.default.create([ICollectionsView_3.SORT_MANAGER_COLLECTIONS])
                .event.subscribe("sort", () => momentWrappers.forEach(wrapper => wrapper.sort()))
                .tweak(itemSort => View_7.default.registerFooterButton(itemSort.button))
                .tweak(itemSort => itemSort.label.classes.add(View_7.default.Classes.FooterButtonLabel))
                .tweak(itemSort => itemSort.sortText.classes.add(View_7.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const filterer = ItemFilter_2.default.getFor(ICollectionsView_3.FILTER_MANAGER_COLLECTIONS)
                .event.subscribe("filter", () => momentWrappers.forEach(wrapper => wrapper.filter()))
                .event.subscribe("submit", () => document.querySelector(`.${IItemComponent_5.ItemClasses.Main}:not([tabindex="-1"])`)?.focus())
                .tweak(itemFilter => View_7.default.registerFooterButton(itemFilter.button))
                .tweak(itemFilter => itemFilter.label.classes.add(View_7.default.Classes.FooterButtonLabel))
                .tweak(itemFilter => itemFilter.input.classes.add(View_7.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const hints = HintsDrawer_2.default.create()
                .tweak(hints => View_7.default.registerFooterButton(hints.button))
                .tweak(hints => hints.buttonLabel.classes.add(View_7.default.Classes.FooterButtonLabel))
                .tweak(hints => hints.buttonText.classes.add(View_7.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const onGlobalKeydown = (event) => {
                if (!document.contains(view.element)) {
                    UiEventBus_9.default.unsubscribe("keydown", onGlobalKeydown);
                    return;
                }
                if (hints.drawer.isOpen() && event.useOverInput("Escape")) {
                    hints.drawer.close(true);
                }
                if (filterer.isFiltered() && event.use("Escape")) {
                    filterer.reset();
                }
            };
            UiEventBus_9.default.subscribe("keydown", onGlobalKeydown);
        },
    });
});
define("ui/view/collections/IEmblemsView", ["require", "exports", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager"], function (require, exports, Filter_26, FilterManager_7, Sort_31, SortManager_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FILTER_MANAGER_EMBLEMS = exports.SORT_MANAGER_EMBLEMS = exports.FILTER_MANAGER_EMBLEMS_DEFINITION = exports.SORT_MANAGER_EMBLEMS_DEFINITION = exports.VIEW_NAME_EMBLEMS = exports.VIEW_ID_EMBLEMS = exports.FILTERS_INAPPLICABLE_EMBLEMS = exports.SORTS_INAPPLICABLE_EMBLEMS = exports.SORTS_DEFAULT_EMBLEMS = void 0;
    exports.SORTS_DEFAULT_EMBLEMS = [
        Sort_31.default.Name,
    ];
    exports.SORTS_INAPPLICABLE_EMBLEMS = [
        Sort_31.default.Power,
        Sort_31.default.Pattern,
        Sort_31.default.Shaped,
        Sort_31.default.Rarity,
        Sort_31.default.StatTotal,
        Sort_31.default.StatDistribution,
        Sort_31.default.StatLegacyDistribution,
        Sort_31.default.Moment,
        Sort_31.default.AmmoType,
        Sort_31.default.WeaponType,
        Sort_31.default.Quantity,
        Sort_31.default.Locked,
        Sort_31.default.Harmonizable,
        Sort_31.default.Exotic,
        Sort_31.default.CanShape,
        Sort_31.default.BreakerType,
        Sort_31.default.Energy,
        Sort_31.default.Masterwork,
        Sort_31.default.DamageType,
        Sort_31.default.Featured,
        "stat-.*",
    ];
    exports.FILTERS_INAPPLICABLE_EMBLEMS = [
        Filter_26.default.Ammo,
        Filter_26.default.WeaponType,
        Filter_26.default.Rarity,
        Filter_26.default.Shaped,
        Filter_26.default.Perk,
        Filter_26.default.Moment,
        Filter_26.default.Locked,
        Filter_26.default.Artifice,
        Filter_26.default.Pattern,
        Filter_26.default.Catalyst,
        Filter_26.default.Duplicate,
        Filter_26.default.BreakerType,
        Filter_26.default.Element,
        Filter_26.default.Adept,
        Filter_26.default.Masterwork,
        Filter_26.default.Featured,
    ];
    exports.VIEW_ID_EMBLEMS = "emblems";
    exports.VIEW_NAME_EMBLEMS = "Emblems";
    exports.SORT_MANAGER_EMBLEMS_DEFINITION = {
        id: exports.VIEW_ID_EMBLEMS,
        name: exports.VIEW_NAME_EMBLEMS,
        default: exports.SORTS_DEFAULT_EMBLEMS,
        inapplicable: exports.SORTS_INAPPLICABLE_EMBLEMS,
    };
    exports.FILTER_MANAGER_EMBLEMS_DEFINITION = {
        id: exports.VIEW_ID_EMBLEMS,
        name: exports.VIEW_NAME_EMBLEMS,
        inapplicable: exports.FILTERS_INAPPLICABLE_EMBLEMS,
    };
    exports.SORT_MANAGER_EMBLEMS = new SortManager_7.default(exports.SORT_MANAGER_EMBLEMS_DEFINITION);
    exports.FILTER_MANAGER_EMBLEMS = new FilterManager_7.default(exports.FILTER_MANAGER_EMBLEMS_DEFINITION);
});
define("ui/view/collections/EmblemsView", ["require", "exports", "model/Model", "model/models/Emblems", "model/models/Manifest", "model/models/ProfileBatch", "model/models/items/Item", "ui/component/Component", "ui/component/Paginator", "ui/destiny/component/HintsDrawer", "ui/destiny/component/IItemComponent", "ui/destiny/component/ProfileButton", "ui/destiny/filter/FilterManager", "ui/destiny/filter/ItemFilter", "ui/destiny/sort/ItemSort", "ui/destiny/tooltip/ItemTooltip", "ui/utility/UiEventBus", "ui/view/View", "ui/view/collections/ICollectionsView", "ui/view/collections/IEmblemsView", "utility/Async"], function (require, exports, Model_18, Emblems_1, Manifest_25, ProfileBatch_11, Item_7, Component_75, Paginator_3, HintsDrawer_3, IItemComponent_6, ProfileButton_2, FilterManager_8, ItemFilter_3, ItemSort_3, ItemTooltip_3, UiEventBus_10, View_8, ICollectionsView_4, IEmblemsView_1, Async_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmblemsViewClasses = void 0;
    var EmblemsViewClasses;
    (function (EmblemsViewClasses) {
        EmblemsViewClasses["Paginator"] = "view-emblems-paginator";
        EmblemsViewClasses["ListWrapper"] = "view-emblems-list-wrapper";
        EmblemsViewClasses["List"] = "view-emblems-list";
        EmblemsViewClasses["Emblem"] = "view-emblems-emblem";
        EmblemsViewClasses["Emblem_NotAcquired"] = "view-emblems-emblem--not-acquired";
    })(EmblemsViewClasses || (exports.EmblemsViewClasses = EmblemsViewClasses = {}));
    const EmblemItems = Model_18.default.createTemporary(async (api) => {
        const profile = await api.subscribeProgressAndWait(ProfileBatch_11.default, 1 / 4);
        const manifest = await api.subscribeProgressAndWait(Manifest_25.default, 1 / 4, 1 / 4);
        const emblems = await api.subscribeProgressAndWait(Emblems_1.default, 1 / 4, 2 / 4);
        const start = 3 / 4;
        const result = [];
        let lastUpdate = 0;
        for (const emblem of emblems) {
            result.push({
                ...emblem,
                item: await Item_7.default.createFake(manifest, profile, emblem.definition),
            });
            if (Date.now() - lastUpdate > 100) {
                lastUpdate = Date.now();
                api.emitProgress(start + (1 / 4) * (result.length / emblems.length), "Loading emblems");
            }
        }
        return result;
    });
    exports.default = View_8.default.create({
        models: [EmblemItems, FilterManager_8.default.initModel],
        id: IEmblemsView_1.VIEW_ID_EMBLEMS,
        name: IEmblemsView_1.VIEW_NAME_EMBLEMS,
        auth: "optional",
        navGroupViewId: ICollectionsView_4.VIEW_ID_COLLECTIONS,
        initialise: (view, emblems) => {
            view.setTitle(title => title.text.set(IEmblemsView_1.VIEW_NAME_EMBLEMS));
            view.setSubtitle("lore", subtitle => subtitle
                .text.set("Symbols of aesthetics, collection, or prestige..."));
            const map = new Map();
            for (const emblem of emblems) {
                const fakeBungieId = { name: emblem.definition.displayProperties.name, code: -1 };
                const fakeProfile = {
                    lastModified: new Date().toISOString(),
                    emblemHash: emblem.definition.hash,
                };
                map.set(emblem, ProfileButton_2.default.create([fakeBungieId, fakeProfile])
                    .classes.add(EmblemsViewClasses.Emblem)
                    .classes.toggle(emblem.item.isNotAcquired(), EmblemsViewClasses.Emblem_NotAcquired)
                    .setTooltip(ItemTooltip_3.default, {
                    initialise: tooltip => emblem.definition && tooltip.setPadding(20).setItem(emblem.item),
                    differs: tooltip => tooltip.item?.reference.itemInstanceId !== emblem.item?.reference.itemInstanceId,
                }));
            }
            const emblemList = Paginator_3.default.create()
                .classes.add(EmblemsViewClasses.Paginator)
                .tweak(paginator => paginator.pageWrapper.classes.add(EmblemsViewClasses.ListWrapper))
                .appendTo(view.content);
            let sortAndFilterQueued = false;
            let sortAndFilterPromise;
            let lastState = "";
            const queueSortAndFilter = async () => {
                if (sortAndFilterQueued)
                    return;
                sortAndFilterQueued = true;
                while (sortAndFilterPromise)
                    await sortAndFilterPromise;
                sortAndFilterQueued = false;
                sortAndFilterPromise = Async_9.default.sleep(500).then(async () => {
                    sortAndFilterPromise = undefined;
                    const columns = Math.floor(Component_75.default.window.width / 350);
                    const rows = Math.floor((Component_75.default.window.height - 200) / 50);
                    const state = `${IEmblemsView_1.SORT_MANAGER_EMBLEMS.getStateHash()};${IEmblemsView_1.FILTER_MANAGER_EMBLEMS.getStateHash()};${columns};${rows}`;
                    if (state === lastState)
                        return;
                    lastState = state;
                    view.style.set("--columns", `${columns}`);
                    view.style.set("--rows", `${rows}`);
                    let index = 0;
                    const filler = emblemList.filler(columns * rows, page => {
                        index = 0;
                        page.classes.add(EmblemsViewClasses.List);
                    });
                    const subset = emblems
                        .filter(IEmblemsView_1.FILTER_MANAGER_EMBLEMS.apply)
                        .sort((a, b) => IEmblemsView_1.SORT_MANAGER_EMBLEMS.sort(a, b), (a, b) => a.definition.displayProperties.name.localeCompare(b.definition.displayProperties.name));
                    for (const emblem of subset)
                        map.get(emblem)
                            ?.style.set("--profile-index", `${index++}`)
                            ?.appendTo(filler.increment());
                    filler.fillRemainder(page => page.append(ProfileButton_2.default.Placeholder.create()));
                    emblemList.pageWrapper.element.scrollLeft = 0;
                    await Async_9.default.sleep(10);
                    emblemList.pageWrapper.element.scrollLeft = 0;
                });
            };
            Component_75.default.window.event.subscribe("resize", queueSortAndFilter);
            ItemSort_3.default.create([IEmblemsView_1.SORT_MANAGER_EMBLEMS])
                .event.subscribe("sort", queueSortAndFilter)
                .tweak(itemSort => View_8.default.registerFooterButton(itemSort.button))
                .tweak(itemSort => itemSort.label.classes.add(View_8.default.Classes.FooterButtonLabel))
                .tweak(itemSort => itemSort.sortText.classes.add(View_8.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const filterer = ItemFilter_3.default.getFor(IEmblemsView_1.FILTER_MANAGER_EMBLEMS)
                .event.subscribe("filter", queueSortAndFilter)
                .event.subscribe("submit", () => document.querySelector(`.${IItemComponent_6.ItemClasses.Main}:not([tabindex="-1"])`)?.focus())
                .tweak(itemFilter => View_8.default.registerFooterButton(itemFilter.button))
                .tweak(itemFilter => itemFilter.label.classes.add(View_8.default.Classes.FooterButtonLabel))
                .tweak(itemFilter => itemFilter.input.classes.add(View_8.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            void queueSortAndFilter();
            const hints = HintsDrawer_3.default.create()
                .tweak(hints => View_8.default.registerFooterButton(hints.button))
                .tweak(hints => hints.buttonLabel.classes.add(View_8.default.Classes.FooterButtonLabel))
                .tweak(hints => hints.buttonText.classes.add(View_8.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const onGlobalKeydown = (event) => {
                if (!document.contains(view.element)) {
                    UiEventBus_10.default.unsubscribe("keydown", onGlobalKeydown);
                    return;
                }
                if (hints.drawer.isOpen() && event.useOverInput("Escape")) {
                    hints.drawer.close(true);
                }
                if (filterer.isFiltered() && event.use("Escape")) {
                    filterer.reset();
                }
            };
            UiEventBus_10.default.subscribe("keydown", onGlobalKeydown);
        },
    });
});
define("ui/view/collections/IModsView", ["require", "exports", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager"], function (require, exports, Filter_27, FilterManager_9, Sort_32, SortManager_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModsViewClasses = exports.FILTER_MANAGER_MODS = exports.SORT_MANAGER_MODS = exports.FILTER_MANAGER_MODS_DEFINITION = exports.SORT_MANAGER_MODS_DEFINITION = exports.VIEW_NAME_MODS = exports.VIEW_ID_MODS = exports.FILTERS_INAPPLICABLE_MODS = exports.SORTS_INAPPLICABLE_MODS = exports.SORTS_DEFAULT_MODS = void 0;
    exports.SORTS_DEFAULT_MODS = [
        Sort_32.default.Name,
    ];
    exports.SORTS_INAPPLICABLE_MODS = [
        Sort_32.default.Power,
        Sort_32.default.Pattern,
        Sort_32.default.Shaped,
        Sort_32.default.Rarity,
        Sort_32.default.StatTotal,
        Sort_32.default.StatDistribution,
        Sort_32.default.StatLegacyDistribution,
        Sort_32.default.Moment,
        Sort_32.default.AmmoType,
        Sort_32.default.WeaponType,
        Sort_32.default.Quantity,
        Sort_32.default.Locked,
        Sort_32.default.Harmonizable,
        Sort_32.default.Exotic,
        Sort_32.default.CanShape,
        Sort_32.default.BreakerType,
        Sort_32.default.Acquired,
        Sort_32.default.Featured,
        "stat-.*",
    ];
    exports.FILTERS_INAPPLICABLE_MODS = [
        Filter_27.default.Ammo,
        Filter_27.default.WeaponType,
        Filter_27.default.Rarity,
        Filter_27.default.Shaped,
        Filter_27.default.Perk,
        Filter_27.default.Moment,
        Filter_27.default.Locked,
        Filter_27.default.Artifice,
        Filter_27.default.Pattern,
        Filter_27.default.Catalyst,
        Filter_27.default.Duplicate,
        Filter_27.default.BreakerType,
        Filter_27.default.Acquired,
        Filter_27.default.Featured,
    ];
    exports.VIEW_ID_MODS = "mods";
    exports.VIEW_NAME_MODS = "Mods";
    exports.SORT_MANAGER_MODS_DEFINITION = {
        id: exports.VIEW_ID_MODS,
        name: exports.VIEW_NAME_MODS,
        default: exports.SORTS_DEFAULT_MODS,
        inapplicable: exports.SORTS_INAPPLICABLE_MODS,
    };
    exports.FILTER_MANAGER_MODS_DEFINITION = {
        id: exports.VIEW_ID_MODS,
        name: exports.VIEW_NAME_MODS,
        inapplicable: exports.FILTERS_INAPPLICABLE_MODS,
    };
    exports.SORT_MANAGER_MODS = new SortManager_8.default(exports.SORT_MANAGER_MODS_DEFINITION);
    exports.FILTER_MANAGER_MODS = new FilterManager_9.default(exports.FILTER_MANAGER_MODS_DEFINITION);
    var ModsViewClasses;
    (function (ModsViewClasses) {
        ModsViewClasses["PlugList"] = "view-mods-plug-list";
        ModsViewClasses["PlugListContent"] = "view-mods-plug-list-content";
        ModsViewClasses["PlugListPage"] = "view-mods-plug-list-page";
        ModsViewClasses["Plug"] = "view-mods-plug";
        ModsViewClasses["TypeWrapper"] = "view-mods-type-wrapper";
    })(ModsViewClasses || (exports.ModsViewClasses = ModsViewClasses = {}));
});
define("ui/view/item/ItemSockets", ["require", "exports", "ui/component/Button", "ui/component/Card", "ui/component/Component", "ui/destiny/tooltip/ItemPlugTooltip", "ui/utility/Classes", "ui/utility/DisplayProperties"], function (require, exports, Button_18, Card_6, Component_76, ItemPlugTooltip_2, Classes_25, DisplayProperties_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemPlug = exports.ItemSocket = exports.ItemSocketsClasses = void 0;
    var ItemSocketsClasses;
    (function (ItemSocketsClasses) {
        ItemSocketsClasses["Main"] = "view-item-sockets";
        ItemSocketsClasses["SocketsContainer"] = "view-item-sockets-container";
        ItemSocketsClasses["Socket"] = "view-item-socket";
        ItemSocketsClasses["Plug"] = "view-item-socket-plug";
        ItemSocketsClasses["PlugSelected"] = "view-item-socket-plug-selected";
        ItemSocketsClasses["PlugName"] = "view-item-socket-plug-name";
        ItemSocketsClasses["PlugDescription"] = "view-item-socket-plug-description";
        ItemSocketsClasses["PlugEnhanced"] = "view-item-socket-plug-enhanced";
        ItemSocketsClasses["PlugEffects"] = "view-item-socket-plug-effects";
        ItemSocketsClasses["PlugExotic"] = "view-item-socket-plug-exotic";
        ItemSocketsClasses["PlugRequiredLevel"] = "view-item-socket-plug-required-level";
        ItemSocketsClasses["PlugType"] = "view-item-socket-plug-type";
        ItemSocketsClasses["PlugIconInner"] = "view-item-socket-plug-icon-inner";
        ItemSocketsClasses["PlugIconInnerType"] = "view-item-socket-plug-icon-inner-type";
        // PlugRequiredLevelWrapper = "view-item-socket-plug-required-level-wrapper",
        ItemSocketsClasses["Socketed"] = "view-item-socket-plug-socketed";
    })(ItemSocketsClasses || (exports.ItemSocketsClasses = ItemSocketsClasses = {}));
    class ItemSockets extends Card_6.default {
        get socketClasses() { return []; }
        get plugClasses() { return []; }
        async onMake(item, inventory) {
            super.onMake(item, inventory);
            this.item = item;
            this.inventory = inventory;
            this.classes.add(ItemSocketsClasses.Main);
            this.setDisplayMode(Card_6.CardClasses.DisplayModeSection);
            this.title.text.set(this.getTitle());
            this.addedSockets = [];
            this.maxSocketPlugs = 0;
            await this.initialise();
            this.classes.toggle(!this.addedSockets.length, Classes_25.Classes.Hidden);
            Component_76.default.create()
                .classes.add(ItemSocketsClasses.SocketsContainer)
                .append(...this.addedSockets.splice(0, Infinity))
                .appendTo(this.content);
            // Loadable.create(Promise.resolve().then(() => Async.sleep(2000)))
            // 	.onReady(() => ))
            // 	.appendTo(this.content);
        }
        addSocketsByType(...anyOfTypes) {
            return this.addSockets(...this.item.getSockets(...anyOfTypes));
        }
        addSockets(...sockets) {
            const components = [];
            for (const socket of sockets) {
                if (socket.state?.isVisible !== false) {
                    let socketComponent;
                    const socketPlugs = socket.plugs ?? [];
                    // const shouldOnlyShowEnhanced = !socket.state && !this.item.deepsight?.pattern && socketPlugs.some(p => p.type.endsWith('Enhanced'))
                    for (const plug of socketPlugs) {
                        if (!socket.state && plug.is("Intrinsic/FrameEnhanced"))
                            continue;
                        if (plug.is("Perk/TraitLocked"))
                            continue;
                        if (plug.is("Perk/EmptyCraftingSocket", "Intrinsic/EmptyCraftingSocket"))
                            continue;
                        // if (shouldOnlyShowEnhanced && !plug.type.endsWith('Enhanced') && plug.isNot('Intrinsic/Frame') && plug.isNot('Masterwork'))
                        // skip unenhanced perks for non-shaped weapons in collections
                        // continue;
                        if (!plug.definition?.displayProperties.name)
                            continue;
                        socketComponent ??= this.addSocket()
                            .classes.add(...this.socketClasses);
                        socketComponent.addPlug(plug, undefined, this.item)
                            .classes.add(...this.plugClasses);
                    }
                    if (socketComponent)
                        components.push(socketComponent);
                }
            }
            return components;
        }
        addPerksByPlugType(...anyOfTypes) {
            return this.addPerks(...this.item.getSockets(...anyOfTypes));
        }
        addPerks(...sockets) {
            const components = [];
            for (const socket of sockets) {
                if (socket.state?.isVisible !== false) {
                    const socketPlugs = socket.plugs ?? [];
                    for (const plug of socketPlugs) {
                        if (!socket.state && (plug.is("Perk/TraitEnhanced", "Intrinsic/FrameEnhanced") || plug.type.endsWith("Enhanced")))
                            continue;
                        if (socket.is("Masterwork/ExoticCatalyst") && !this.item.isMasterwork())
                            continue;
                        if (plug.is("Perk/EmptyCraftingSocket", "Intrinsic/EmptyCraftingSocket"))
                            continue;
                        for (const perk of plug.perks) {
                            if (perk.perkVisibility === 2 /* ItemPerkVisibility.Hidden */ || !perk.definition.isDisplayable)
                                continue;
                            const socketComponent = this.addSocket()
                                .classes.add(...this.socketClasses);
                            components.push(socketComponent);
                            socketComponent.addPlug(plug, perk, this.item)
                                .classes.add(...this.plugClasses);
                        }
                    }
                }
            }
            return components;
        }
        addSocket(initialiser) {
            const socket = ItemSocket.create()
                .tweak(initialiser);
            socket.event.subscribe("addPlug", () => this.updateSocket(socket));
            this.addedSockets.push(socket);
            this.updateSocket(socket);
            return socket;
        }
        updateSocket(socket) {
            const old = this.maxSocketPlugs;
            this.maxSocketPlugs = Math.max(this.maxSocketPlugs, socket.plugs.length);
            if (old === this.maxSocketPlugs)
                return;
            this.style.set("--max-socket-plugs", `${this.maxSocketPlugs}`);
        }
        hasSockets() {
            return !!this.addedSockets.length;
        }
    }
    exports.default = ItemSockets;
    class ItemSocket extends Component_76.default {
        onMake() {
            this.classes.add(ItemSocketsClasses.Socket);
            this.plugs = [];
        }
        addPlug(plug, perkOrInitialiser, itemOrInitialiser, initialiser) {
            const perk = typeof perkOrInitialiser === "function" ? undefined : perkOrInitialiser;
            const item = typeof itemOrInitialiser === "function" ? undefined : itemOrInitialiser;
            initialiser = typeof perkOrInitialiser === "function" ? perkOrInitialiser : typeof itemOrInitialiser === "function" ? itemOrInitialiser : initialiser;
            const component = ItemPlug.create([plug, perk, item])
                .tweak(initialiser)
                .appendTo(this);
            this.plugs.push(component);
            this.event.emit("addPlug");
            return component;
        }
    }
    exports.ItemSocket = ItemSocket;
    class ItemPlug extends Button_18.default {
        onMake(plug, perk, item) {
            super.onMake();
            this.classes.add(ItemSocketsClasses.Plug);
            this.addIcon();
            this.label = Component_76.default.create("label")
                .classes.add(ItemSocketsClasses.PlugName)
                .appendTo(this);
            this.description = Component_76.default.create()
                .classes.add(ItemSocketsClasses.PlugDescription)
                .appendTo(this);
            if (plug)
                this.using(plug, perk, item);
        }
        using(plug, perk, item, displayRequiredLevels = false) {
            this.hash = perk?.definition.hash ?? plug.definition?.hash ?? -1;
            this.plug = plug;
            this.perk = perk;
            this.item = item;
            this.classes.toggle(!!plug.socketed, ItemSocketsClasses.Socketed)
                .classes.toggle((plug.is("Intrinsic", "=Masterwork/ExoticCatalyst")) && item?.definition.inventory?.tierTypeHash === 2759499571 /* ItemTierTypeHashes.Exotic */, ItemSocketsClasses.PlugExotic)
                .classes.toggle(plug.is("Perk/TraitEnhanced", "Intrinsic/FrameEnhanced", "=Masterwork/ExoticCatalyst") || plug.type.endsWith("Enhanced"), ItemSocketsClasses.PlugEnhanced)
                .classes.removeWhere(cls => cls.startsWith(ItemSocketsClasses.PlugType))
                .classes.add(`${ItemSocketsClasses.PlugType}-${plug.categorisation?.categoryName.toLowerCase()}`)
                .classes.add(`${ItemSocketsClasses.PlugType}-${plug.type.replaceAll("/", "-").toLowerCase()}`)
                .setIcon(DisplayProperties_17.default.icon(perk?.definition) ?? DisplayProperties_17.default.icon(plug.definition))
                .setName(DisplayProperties_17.default.name(perk?.definition) ?? DisplayProperties_17.default.name(plug.definition) ?? "Unknown")
                .setDescription(DisplayProperties_17.default.description(perk?.definition) ?? DisplayProperties_17.default.description(plug.definition));
            this.innerIcon?.classes.add(ItemSocketsClasses.PlugIconInner)
                .classes.add(`${ItemSocketsClasses.PlugIconInnerType}-${plug.categorisation?.categoryName.toLowerCase()}`)
                .classes.add(`${ItemSocketsClasses.PlugIconInnerType}-${plug.type.replaceAll("/", "-").toLowerCase()}`);
            if (item?.deepsight?.pattern?.recipe && !item.instance && !item.isAdept() && plug.is("Perk"))
                // Component.create()
                // 	.classes.add(ItemSocketsClasses.PlugRequiredLevelWrapper)
                // 	.append(
                Component_76.default.create()
                    .classes.add(ItemSocketsClasses.PlugRequiredLevel)
                    .text.set(`${plug.craftingRequirements?.requiredLevel ?? 1}`)
                    //)
                    .appendTo(this);
            this.setTooltip(ItemPlugTooltip_2.default, {
                initialise: tooltip => tooltip.set(plug, perk, item),
                differs: tooltip => tooltip.plug?.plugItemHash !== plug.plugItemHash,
            });
        }
        setName(name) {
            this.label.text.set(name ?? "Unknown");
            return this;
        }
        setDescription(description) {
            this.description.text.set(description?.replace(/\n{2,}/g, "\n") ?? "");
            return this;
        }
        setIcon(icon) {
            this.innerIcon.style.set("--icon", icon);
            return this;
        }
    }
    exports.ItemPlug = ItemPlug;
});
define("ui/view/collections/ModsCategory", ["require", "exports", "ui/component/Component", "ui/component/Details", "ui/component/Paginator", "ui/utility/Classes", "ui/view/collections/CollectionsMoment", "ui/view/collections/IModsView", "ui/view/item/ItemSockets", "utility/decorator/Bound"], function (require, exports, Component_77, Details_4, Paginator_4, Classes_26, CollectionsMoment_3, IModsView_1, ItemSockets_1, Bound_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModsList = void 0;
    const capitalisationRegex = /(?<=[a-z])(?=[A-Z])/g;
    class ModsList extends Details_4.default {
        constructor() {
            super(...arguments);
            this.updatingVisibility = false;
            this.forcedOpen = false;
        }
        onMake(name, plugs, defaultOpen = false, updateVisibility = true) {
            super.onMake(name, plugs);
            this.classes.add(CollectionsMoment_3.CollectionsMomentClasses.Moment, IModsView_1.ModsViewClasses.TypeWrapper);
            this.close();
            this.plugs = plugs?.slice() ?? [];
            this.components = new WeakMap();
            this.classes.add(CollectionsMoment_3.CollectionsMomentClasses.Moment)
                .toggle(defaultOpen)
                .tweak(details => details.summary.text.set(name.replace(capitalisationRegex, " ")));
            this.plugList = Paginator_4.default.create()
                .classes.add(IModsView_1.ModsViewClasses.PlugList);
            this.plugList.pageWrapper.classes.add(IModsView_1.ModsViewClasses.PlugListContent);
            const storage = Component_77.default.create();
            this.event.subscribe("toggle", event => {
                event.stopPropagation();
                if (!this.updatingVisibility)
                    this.forcedOpen = false;
                this.plugList.appendTo(this.isOpen() ? this : storage)
                    .attributes.toggle(!this.isOpen(), "inert");
            }, false);
            this.sortAndFilter(updateVisibility);
        }
        addPlugs(plugs) {
            this.plugs.push(...plugs);
            this.sortAndFilter();
            return this;
        }
        sortAndFilter(updateVisibility = true) {
            this.plugs.sort((a, b) => IModsView_1.SORT_MANAGER_MODS.sort(a, b, false), (a, b) => a.definition?.displayProperties.name.localeCompare(b.definition?.displayProperties.name ?? "") ?? 0);
            const helper = this.plugList.filler({ desktop: 25, vertical: 15, tablet: 10, mobile: 5 });
            const plugs = this.plugs.filter(IModsView_1.FILTER_MANAGER_MODS.apply);
            for (const plug of plugs)
                if (plug.definition?.displayProperties?.name)
                    this.components.compute(plug, () => ItemSockets_1.ItemPlug.create([plug, undefined, undefined])
                        .classes.add(IModsView_1.ModsViewClasses.Plug))
                        .appendTo(helper.increment(page => page
                        .classes.add(IModsView_1.ModsViewClasses.PlugListPage)));
            this.plugList.classes.toggle(!plugs.length, Classes_26.Classes.Hidden);
            if (updateVisibility)
                this.updateVisibility(!!plugs.length);
            return !!plugs.length;
        }
        updateVisibility(visible) {
            this.updatingVisibility = true;
            const hidden = !visible;
            this.classes.toggle(hidden, CollectionsMoment_3.CollectionsMomentClasses.FilteredOut);
            if (this.forcedOpen && (hidden || !IModsView_1.FILTER_MANAGER_MODS.isFiltered())) {
                this.close();
                this.forcedOpen = false;
            }
            else if (IModsView_1.FILTER_MANAGER_MODS.isFiltered() && !hidden && !this.isOpen()) {
                this.open();
                this.forcedOpen = true;
            }
            this.updatingVisibility = false;
        }
    }
    exports.ModsList = ModsList;
    __decorate([
        Bound_27.default
    ], ModsList.prototype, "sortAndFilter", null);
    class ModsCategory extends ModsList {
        onMake(name, contents, defaultOpen = false) {
            this.types = [];
            super.onMake(name, contents, defaultOpen);
            this.classes.remove(IModsView_1.ModsViewClasses.TypeWrapper);
        }
        addType(typeDetails) {
            typeDetails.appendTo(this);
            this.types.push(typeDetails);
        }
        sortAndFilter() {
            let showing = false;
            for (const details of this.types) {
                const typeShowing = details.sortAndFilter();
                showing ||= typeShowing;
            }
            const catShowing = super.sortAndFilter(false);
            showing ||= catShowing;
            this.updateVisibility(showing);
            return showing;
        }
    }
    exports.default = ModsCategory;
    __decorate([
        Bound_27.default
    ], ModsCategory.prototype, "sortAndFilter", null);
});
define("ui/view/collections/ModsView", ["require", "exports", "model/Model", "model/models/Manifest", "model/models/items/Plugs", "ui/destiny/component/HintsDrawer", "ui/destiny/component/IItemComponent", "ui/destiny/filter/FilterManager", "ui/destiny/filter/ItemFilter", "ui/destiny/sort/ItemSort", "ui/utility/UiEventBus", "ui/view/View", "ui/view/collections/IModsView", "ui/view/collections/ModsCategory", "utility/Async"], function (require, exports, Model_19, Manifest_26, Plugs_3, HintsDrawer_4, IItemComponent_7, FilterManager_10, ItemFilter_4, ItemSort_4, UiEventBus_11, View_9, IModsView_2, ModsCategory_1, Async_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ModsViewModel = Model_19.default.createTemporary(async (api) => {
        api.emitProgress(0 / 2, "Loading manifest");
        const manifest = await api.subscribeProgressAndWait(Manifest_26.default, 1 / 2);
        const { DeepsightPlugCategorisation } = manifest;
        const from = 1 / 2;
        const amount = 1 / 2;
        api.emitProgress(from, "Loading mods");
        const categorisations = await DeepsightPlugCategorisation.all();
        const categoryNames = Array.from(new Set(categorisations.map(plug => plug.categoryName))).sort();
        let lastRender = 0;
        const categories = [];
        let i = 0;
        for (const categoryName of categoryNames) {
            const categoryCategorisations = categorisations.filter(plug => plug.categoryName === categoryName);
            const typeNames = Array.from(new Set(categoryCategorisations.map(plug => plug.typeName))).sort();
            const types = [];
            const plugs = [];
            const category = {
                category: categoryName,
                categorisations: categoryCategorisations,
                types,
                plugs,
            };
            for (const typeName of typeNames) {
                let plugs = category.plugs;
                if (typeName) {
                    plugs = [];
                    types.push({
                        type: typeName,
                        plugs,
                    });
                }
                for (const plugCategorisation of categoryCategorisations) {
                    if (plugCategorisation.typeName === typeName)
                        plugs.push(await Plugs_3.Plug.resolveFromHash(manifest, plugCategorisation.hash, true));
                    if (Date.now() - lastRender > 200) {
                        lastRender = Date.now();
                        api.emitProgress(from + amount * (i++ / categorisations.length), "Loading mods");
                        await Async_10.default.sleep(10);
                    }
                }
            }
            categories.push(category);
        }
        const sorter = (a, b) => (a.definition?.displayProperties?.name ?? "").localeCompare(b.definition?.displayProperties?.name ?? "");
        for (const category of categories) {
            category.plugs.sort(sorter);
            for (const type of category.types) {
                type.plugs.sort(sorter);
            }
        }
        return {
            manifest,
            categories,
        };
    });
    exports.default = View_9.default.create({
        models: [ModsViewModel, FilterManager_10.default.initModel],
        id: IModsView_2.VIEW_ID_MODS,
        name: IModsView_2.VIEW_NAME_MODS,
        auth: "optional",
        noProfileInURL: true,
        navGroupViewId: "collections",
        initialise: (view, { categories }) => {
            view.setTitle(title => title.text.set("Mods"));
            view.setSubtitle("lore", subtitle => subtitle
                .text.set("An exhaustive list of every mod, perk, cosmetic, and more..."));
            let detailsIndex = 0;
            const details = [];
            for (const category of categories) {
                const categoryDetails = ModsCategory_1.default.create([category.category])
                    .style.set("--index", `${detailsIndex++}`)
                    .addPlugs(category.plugs)
                    .appendTo(view.content);
                details.push(categoryDetails);
                for (const type of category.types) {
                    const typeDetails = ModsCategory_1.ModsList.create([type.type, undefined, undefined, false])
                        .style.set("--index", `${detailsIndex++}`)
                        .addPlugs(type.plugs);
                    categoryDetails.addType(typeDetails);
                }
            }
            let sortAndFilterQueued = false;
            let sortAndFilterPromise;
            let lastState = "";
            const queueSortAndFilter = async () => {
                if (sortAndFilterQueued)
                    return;
                sortAndFilterQueued = true;
                while (sortAndFilterPromise)
                    await sortAndFilterPromise;
                sortAndFilterQueued = false;
                sortAndFilterPromise = Async_10.default.sleep(500).then(() => {
                    sortAndFilterPromise = undefined;
                    const state = `${IModsView_2.SORT_MANAGER_MODS.getStateHash()};${IModsView_2.FILTER_MANAGER_MODS.getStateHash()}`;
                    if (state === lastState)
                        return;
                    lastState = state;
                    details.forEach(wrapper => wrapper.sortAndFilter());
                });
            };
            ItemSort_4.default.create([IModsView_2.SORT_MANAGER_MODS])
                .event.subscribe("sort", queueSortAndFilter)
                .tweak(itemSort => View_9.default.registerFooterButton(itemSort.button))
                .tweak(itemSort => itemSort.label.classes.add(View_9.default.Classes.FooterButtonLabel))
                .tweak(itemSort => itemSort.sortText.classes.add(View_9.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const filterer = ItemFilter_4.default.getFor(IModsView_2.FILTER_MANAGER_MODS)
                .event.subscribe("filter", queueSortAndFilter)
                .event.subscribe("submit", () => document.querySelector(`.${IItemComponent_7.ItemClasses.Main}:not([tabindex="-1"])`)?.focus())
                .tweak(itemFilter => View_9.default.registerFooterButton(itemFilter.button))
                .tweak(itemFilter => itemFilter.label.classes.add(View_9.default.Classes.FooterButtonLabel))
                .tweak(itemFilter => itemFilter.input.classes.add(View_9.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            void queueSortAndFilter();
            const hints = HintsDrawer_4.default.create()
                .tweak(hints => View_9.default.registerFooterButton(hints.button))
                .tweak(hints => hints.buttonLabel.classes.add(View_9.default.Classes.FooterButtonLabel))
                .tweak(hints => hints.buttonText.classes.add(View_9.default.Classes.FooterButtonText))
                .appendTo(view.footer);
            const onGlobalKeydown = (event) => {
                if (!document.contains(view.element)) {
                    UiEventBus_11.default.unsubscribe("keydown", onGlobalKeydown);
                    return;
                }
                if (hints.drawer.isOpen() && event.useOverInput("Escape")) {
                    hints.drawer.close(true);
                }
                if (filterer.isFiltered() && event.use("Escape")) {
                    filterer.reset();
                }
            };
            UiEventBus_11.default.subscribe("keydown", onGlobalKeydown);
        },
    });
});
define("ui/view/inventory/InventoryInventoryView", ["require", "exports", "model/models/Characters", "model/models/Inventory", "model/models/items/Bucket", "ui/component/Component", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager", "ui/view/View", "ui/view/inventory/InventoryView"], function (require, exports, Characters_12, Inventory_7, Bucket_13, Component_78, Filter_28, FilterManager_11, Sort_33, SortManager_9, View_10, InventoryView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventoryInventoryViewClasses = exports.FILTER_MANAGER_INVENTORY_DEFINITION = exports.SORT_MANAGER_INVENTORY_DEFINITION = exports.VIEW_NAME_INVENTORY = exports.VIEW_ID_INVENTORY = exports.FILTERS_INAPPLICABLE_INVENTORY = exports.SORTS_INAPPLICABLE_INVENTORY = exports.SORTS_DEFAULT_INVENTORY = void 0;
    exports.SORTS_DEFAULT_INVENTORY = [Sort_33.default.Rarity, Sort_33.default.Name, Sort_33.default.Quantity];
    exports.SORTS_INAPPLICABLE_INVENTORY = [
        Sort_33.default.Power,
        Sort_33.default.Energy,
        Sort_33.default.Pattern,
        Sort_33.default.Shaped,
        Sort_33.default.Masterwork,
        Sort_33.default.StatTotal,
        Sort_33.default.StatDistribution,
        Sort_33.default.StatLegacyDistribution,
        Sort_33.default.AmmoType,
        Sort_33.default.DamageType,
        Sort_33.default.WeaponType,
        Sort_33.default.Harmonizable,
        Sort_33.default.CanShape,
        Sort_33.default.BreakerType,
        Sort_33.default.Acquired,
        Sort_33.default.Featured,
        "stat-.*",
    ];
    exports.FILTERS_INAPPLICABLE_INVENTORY = [
        Filter_28.default.Ammo,
        Filter_28.default.WeaponType,
        Filter_28.default.Element,
        Filter_28.default.Enhancement,
        Filter_28.default.Unlevelled,
        Filter_28.default.Perk,
        Filter_28.default.Shaped,
        Filter_28.default.Adept,
        Filter_28.default.Artifice,
        Filter_28.default.Catalyst,
        Filter_28.default.Pattern,
        Filter_28.default.BreakerType,
        Filter_28.default.Acquired,
        Filter_28.default.Featured,
    ];
    exports.VIEW_ID_INVENTORY = "inventory";
    exports.VIEW_NAME_INVENTORY = "Inventory";
    exports.SORT_MANAGER_INVENTORY_DEFINITION = {
        id: exports.VIEW_ID_INVENTORY,
        name: exports.VIEW_NAME_INVENTORY,
        default: exports.SORTS_DEFAULT_INVENTORY,
        inapplicable: exports.SORTS_INAPPLICABLE_INVENTORY,
    };
    exports.FILTER_MANAGER_INVENTORY_DEFINITION = {
        id: exports.VIEW_ID_INVENTORY,
        name: exports.VIEW_NAME_INVENTORY,
        inapplicable: exports.FILTERS_INAPPLICABLE_INVENTORY,
    };
    var InventoryInventoryViewClasses;
    (function (InventoryInventoryViewClasses) {
        InventoryInventoryViewClasses["Content"] = "view-inventory-inventory-content";
        InventoryInventoryViewClasses["PostmasterBuckets"] = "view-inventory-inventory-postmaster-buckets";
        InventoryInventoryViewClasses["VaultBuckets"] = "view-inventory-inventory-vault-buckets";
        InventoryInventoryViewClasses["ConsumablesBucket"] = "view-inventory-inventory-consumables-bucket";
        InventoryInventoryViewClasses["ModificationsBucket"] = "view-inventory-inventory-modifications-bucket";
    })(InventoryInventoryViewClasses || (exports.InventoryInventoryViewClasses = InventoryInventoryViewClasses = {}));
    exports.default = new View_10.default.Factory()
        .using(Inventory_7.default.createModel())
        .define()
        .initialise((view, model) => view.make(InventoryView_2.default, model))
        .wrapper()
        .create({
        id: exports.VIEW_ID_INVENTORY,
        name: exports.VIEW_NAME_INVENTORY,
        layout: view => {
            view.super.content.classes.add(InventoryInventoryViewClasses.Content);
            view.addBuckets([
                Bucket_13.Bucket.id(1469714392 /* InventoryBucketHashes.Consumables */),
                Bucket_13.Bucket.id(138197802 /* InventoryBucketHashes.General */, undefined, 1469714392 /* InventoryBucketHashes.Consumables */),
            ]);
            view.addBuckets([
                Bucket_13.Bucket.id(3313201758 /* InventoryBucketHashes.Modifications */),
                Bucket_13.Bucket.id(138197802 /* InventoryBucketHashes.General */, undefined, 3313201758 /* InventoryBucketHashes.Modifications */),
            ]);
            const postmasters = Component_78.default.create()
                .classes.add(InventoryInventoryViewClasses.PostmasterBuckets)
                .appendTo(view.super.content);
            Characters_12.default.getSorted()
                .map(character => Bucket_13.Bucket.id(215593132 /* InventoryBucketHashes.LostItems */, character.characterId))
                .collect(bucketIds => view.addBucketsTo(postmasters, bucketIds));
        },
        sort: new SortManager_9.default(exports.SORT_MANAGER_INVENTORY_DEFINITION),
        filter: new FilterManager_11.default(exports.FILTER_MANAGER_INVENTORY_DEFINITION),
    });
});
define("ui/view/inventory/equipment/InventorySlotColumnsView", ["require", "exports", "model/models/Characters", "model/models/Inventory", "model/models/items/Bucket", "ui/component/Component", "ui/view/View", "ui/view/inventory/InventoryView", "utility/Functions"], function (require, exports, Characters_13, Inventory_8, Bucket_14, Component_79, View_11, InventoryView_3, Functions_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InventorySlotColumnsViewClasses = void 0;
    var InventorySlotColumnsViewClasses;
    (function (InventorySlotColumnsViewClasses) {
        InventorySlotColumnsViewClasses["Content"] = "view-slot-columns-content";
        InventorySlotColumnsViewClasses["SectionTitle"] = "view-slot-columns-section-title";
        InventorySlotColumnsViewClasses["SectionContent"] = "view-slot-columns-section-content";
        InventorySlotColumnsViewClasses["SectionWeapons"] = "view-slot-columns-section-weapons";
        InventorySlotColumnsViewClasses["SectionArmour"] = "view-slot-columns-section-armour";
        InventorySlotColumnsViewClasses["SlotColumn"] = "view-slot-columns-slot-column";
        InventorySlotColumnsViewClasses["PostmasterColumn"] = "view-slot-columns-slot-column-postmaster";
        InventorySlotColumnsViewClasses["SlotColumnTitle"] = "view-slot-columns-slot-column-title";
    })(InventorySlotColumnsViewClasses || (exports.InventorySlotColumnsViewClasses = InventorySlotColumnsViewClasses = {}));
    exports.default = new View_11.default.Factory()
        .using(Inventory_8.default.createModel())
        .define()
        .initialise((view, model) => view.make(InventoryView_3.default, model))
        .wrapper()
        .configure(definition => ({
        layout: view => {
            const chars = Characters_13.default.getSorted();
            view.super.content
                .classes.add(InventorySlotColumnsViewClasses.Content)
                .style.set("--buckets", `${definition.mergedVaults ? chars.length + 1 : chars.length * 2}`);
            for (const childView of definition.childViews) {
                const column = Component_79.default.create()
                    .classes.add(InventorySlotColumnsViewClasses.SlotColumn)
                    .appendTo(view.super.content);
                Component_79.default.create()
                    .classes.add(InventorySlotColumnsViewClasses.SlotColumnTitle)
                    .text.set(Functions_3.default.resolve(childView.name) ?? "?")
                    .appendTo(column);
                for (const character of chars) {
                    view.addBucketsTo(column, Bucket_14.Bucket.id(childView.definition.slot, character.characterId));
                    if (!definition.mergedVaults)
                        view.addBucketsTo(column, Bucket_14.Bucket.id(138197802 /* InventoryBucketHashes.General */, character.characterId, childView.definition.slot));
                }
                if (definition.mergedVaults)
                    view.addBucketsTo(column, Bucket_14.Bucket.id(138197802 /* InventoryBucketHashes.General */, undefined, childView.definition.slot));
            }
            if (definition.childViews.length <= 3)
                Component_79.default.create()
                    .classes.add(InventorySlotColumnsViewClasses.SlotColumn, InventorySlotColumnsViewClasses.PostmasterColumn)
                    .append(Component_79.default.create())
                    .appendTo(view.super.content)
                    .tweak(column => chars
                    .map(character => Bucket_14.Bucket.id(215593132 /* InventoryBucketHashes.LostItems */, character.characterId))
                    .collect(bucketIds => view.addBucketsTo(column, bucketIds)));
        },
        onItemMoveStart(view, wrapper, item, event) {
            if (definition.scrollToTop) {
                wrapper.content.element.scrollTo({ top: 0, behavior: "smooth" });
            }
        },
    }));
});
define("ui/view/inventory/equipment/InventoryArmourView", ["require", "exports", "ui/destiny/filter/FilterManager", "ui/destiny/sort/SortManager", "ui/view/inventory/equipment/InventorySlotColumnsView", "ui/view/inventory/slot/InventoryArmourSlotView", "ui/view/inventory/slot/InventoryArmsView", "ui/view/inventory/slot/InventoryChestView", "ui/view/inventory/slot/InventoryClassItemView", "ui/view/inventory/slot/InventoryHelmetView", "ui/view/inventory/slot/InventoryLegsView"], function (require, exports, FilterManager_12, SortManager_10, InventorySlotColumnsView_1, InventoryArmourSlotView_6, InventoryArmsView_2, InventoryChestView_2, InventoryClassItemView_2, InventoryHelmetView_2, InventoryLegsView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventorySlotColumnsView_1.default.clone().create({
        id: InventoryArmourSlotView_6.VIEW_ID_ARMOUR,
        name: InventoryArmourSlotView_6.VIEW_NAME_ARMOUR,
        sort: new SortManager_10.default(InventoryArmourSlotView_6.SORT_MANAGER_ARMOUR_DEFINITION),
        filter: new FilterManager_12.default(InventoryArmourSlotView_6.FILTER_MANAGER_ARMOUR_DEFINITION),
        childViews: [InventoryHelmetView_2.default, InventoryArmsView_2.default, InventoryChestView_2.default, InventoryLegsView_2.default, InventoryClassItemView_2.default],
        mergedVaults: false,
    });
});
define("ui/view/inventory/slot/InventoryEquipmentSlotView", ["require", "exports", "ui/destiny/filter/Filter", "ui/destiny/filter/FilterManager", "ui/destiny/sort/Sort", "ui/destiny/sort/SortManager", "ui/view/inventory/slot/InventorySlotView"], function (require, exports, Filter_29, FilterManager_13, Sort_34, SortManager_11, InventorySlotView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FILTER_MANAGER_EQUIPMENT_DEFINITION = exports.SORT_MANAGER_EQUIPMENT_DEFINITION = exports.VIEW_NAME_EQUIPMENT = exports.VIEW_ID_EQUIPMENT = exports.FILTERS_INAPPLICABLE_EQUIPMENT = exports.SORTS_INAPPLICABLE_EQUIPMENT = exports.SORTS_DEFAULT_EQUIPMENT = void 0;
    exports.SORTS_DEFAULT_EQUIPMENT = [Sort_34.default.Rarity, Sort_34.default.Masterwork, Sort_34.default.Name];
    exports.SORTS_INAPPLICABLE_EQUIPMENT = [
        Sort_34.default.Power,
        Sort_34.default.Energy,
        Sort_34.default.Pattern,
        Sort_34.default.Shaped,
        Sort_34.default.StatTotal,
        Sort_34.default.StatDistribution,
        Sort_34.default.StatLegacyDistribution,
        Sort_34.default.AmmoType,
        Sort_34.default.DamageType,
        Sort_34.default.WeaponType,
        Sort_34.default.Quantity,
        Sort_34.default.Harmonizable,
        Sort_34.default.CanShape,
        Sort_34.default.BreakerType,
        Sort_34.default.Acquired,
        "stat-.*",
    ];
    exports.FILTERS_INAPPLICABLE_EQUIPMENT = [
        Filter_29.default.Ammo,
        Filter_29.default.Element,
        Filter_29.default.Perk,
        Filter_29.default.Shaped,
        Filter_29.default.Enhancement,
        Filter_29.default.WeaponType,
        Filter_29.default.Unlevelled,
        Filter_29.default.Adept,
        Filter_29.default.Artifice,
        Filter_29.default.Catalyst,
        Filter_29.default.Pattern,
        Filter_29.default.BreakerType,
        Filter_29.default.Acquired,
        Filter_29.default.Featured,
    ];
    exports.VIEW_ID_EQUIPMENT = "equipment";
    exports.VIEW_NAME_EQUIPMENT = "Equipment";
    exports.SORT_MANAGER_EQUIPMENT_DEFINITION = {
        id: exports.VIEW_ID_EQUIPMENT,
        name: exports.VIEW_NAME_EQUIPMENT,
        default: exports.SORTS_DEFAULT_EQUIPMENT,
        inapplicable: exports.SORTS_INAPPLICABLE_EQUIPMENT,
    };
    exports.FILTER_MANAGER_EQUIPMENT_DEFINITION = {
        id: exports.VIEW_ID_EQUIPMENT,
        name: exports.VIEW_NAME_EQUIPMENT,
        inapplicable: exports.FILTERS_INAPPLICABLE_EQUIPMENT,
    };
    exports.default = InventorySlotView_3.default.clone().configure({
        sort: new SortManager_11.default(exports.SORT_MANAGER_EQUIPMENT_DEFINITION),
        filter: new FilterManager_13.default(exports.FILTER_MANAGER_EQUIPMENT_DEFINITION),
        navGroupViewId: exports.VIEW_ID_EQUIPMENT,
        mergedVaults: true,
    });
});
define("ui/view/inventory/slot/InventoryGhostView", ["require", "exports", "ui/view/inventory/slot/InventoryEquipmentSlotView"], function (require, exports, InventoryEquipmentSlotView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryEquipmentSlotView_1.default.create({
        id: "ghost",
        name: "Ghost",
        slot: 4023194814 /* InventoryBucketHashes.Ghost */,
    });
});
define("ui/view/inventory/slot/InventoryShipView", ["require", "exports", "ui/view/inventory/slot/InventoryEquipmentSlotView"], function (require, exports, InventoryEquipmentSlotView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryEquipmentSlotView_2.default.create({
        id: "ship",
        name: "Ship",
        slot: 284967655 /* InventoryBucketHashes.Ships */,
    });
});
define("ui/view/inventory/slot/InventorySparrowView", ["require", "exports", "ui/view/inventory/slot/InventoryEquipmentSlotView"], function (require, exports, InventoryEquipmentSlotView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventoryEquipmentSlotView_3.default.create({
        id: "sparrow",
        name: "Sparrow",
        slot: 2025709351 /* InventoryBucketHashes.Vehicle */,
    });
});
define("ui/view/inventory/equipment/InventoryEquipmentView", ["require", "exports", "ui/destiny/filter/FilterManager", "ui/destiny/sort/SortManager", "ui/view/inventory/equipment/InventorySlotColumnsView", "ui/view/inventory/slot/InventoryEquipmentSlotView", "ui/view/inventory/slot/InventoryGhostView", "ui/view/inventory/slot/InventoryShipView", "ui/view/inventory/slot/InventorySparrowView"], function (require, exports, FilterManager_14, SortManager_12, InventorySlotColumnsView_2, InventoryEquipmentSlotView_4, InventoryGhostView_1, InventoryShipView_1, InventorySparrowView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventorySlotColumnsView_2.default.clone().create({
        id: InventoryEquipmentSlotView_4.VIEW_ID_EQUIPMENT,
        name: InventoryEquipmentSlotView_4.VIEW_NAME_EQUIPMENT,
        sort: new SortManager_12.default(InventoryEquipmentSlotView_4.SORT_MANAGER_EQUIPMENT_DEFINITION),
        filter: new FilterManager_14.default(InventoryEquipmentSlotView_4.FILTER_MANAGER_EQUIPMENT_DEFINITION),
        childViews: [InventoryGhostView_1.default, InventorySparrowView_1.default, InventoryShipView_1.default],
        mergedVaults: true,
    });
});
define("ui/view/inventory/equipment/InventoryWeaponsView", ["require", "exports", "ui/destiny/filter/FilterManager", "ui/destiny/sort/SortManager", "ui/view/inventory/equipment/InventorySlotColumnsView", "ui/view/inventory/slot/InventoryEnergyView", "ui/view/inventory/slot/InventoryKineticView", "ui/view/inventory/slot/InventoryPowerView", "ui/view/inventory/slot/InventoryWeaponSlotView"], function (require, exports, FilterManager_15, SortManager_13, InventorySlotColumnsView_3, InventoryEnergyView_2, InventoryKineticView_2, InventoryPowerView_2, InventoryWeaponSlotView_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = InventorySlotColumnsView_3.default.clone().create({
        id: InventoryWeaponSlotView_4.VIEW_ID_WEAPONS,
        name: InventoryWeaponSlotView_4.VIEW_NAME_WEAPONS,
        sort: new SortManager_13.default(InventoryWeaponSlotView_4.SORT_MANAGER_WEAPONS_DEFINITION),
        filter: new FilterManager_15.default(InventoryWeaponSlotView_4.FILTER_MANAGER_WEAPONS_DEFINITION),
        onItemMoveStart(view, wrapper, item, event) {
            wrapper.content.element.scrollTo({ top: 0, behavior: "smooth" });
        },
        childViews: [InventoryKineticView_2.default, InventoryEnergyView_2.default, InventoryPowerView_2.default],
        mergedVaults: true,
    });
});
define("ui/view/item/ItemIntrinsics", ["require", "exports", "ui/view/item/ItemSockets"], function (require, exports, ItemSockets_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemIntrinsicsClasses = void 0;
    var ItemIntrinsicsClasses;
    (function (ItemIntrinsicsClasses) {
        ItemIntrinsicsClasses["IntrinsicSocket"] = "view-item-socket-intrinsic";
    })(ItemIntrinsicsClasses || (exports.ItemIntrinsicsClasses = ItemIntrinsicsClasses = {}));
    class ItemIntrinsics extends ItemSockets_2.default {
        getTitle() {
            return "Intrinsic Traits";
        }
        get socketClasses() { return [ItemIntrinsicsClasses.IntrinsicSocket]; }
        initialise() {
            this.addSocketsByType("Intrinsic");
            this.addPerksByPlugType("=Masterwork/ExoticCatalyst");
        }
    }
    exports.default = ItemIntrinsics;
});
define("ui/view/item/ItemPerks", ["require", "exports", "ui/component/Button", "ui/component/Card", "ui/component/Component", "ui/component/Drawer", "ui/component/form/Checkbox", "ui/utility/Classes", "ui/utility/UiEventBus", "ui/view/item/ItemSockets", "utility/Store", "utility/decorator/Bound"], function (require, exports, Button_19, Card_7, Component_80, Drawer_5, Checkbox_2, Classes_27, UiEventBus_12, ItemSockets_3, Store_16, Bound_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemPerksClasses = void 0;
    var ItemPerksClasses;
    (function (ItemPerksClasses) {
        ItemPerksClasses["Main"] = "view-item-perks";
        ItemPerksClasses["ButtonWishlistPerks"] = "view-item-perks-button-wishlist-perks";
        ItemPerksClasses["MarkedAsJunk"] = "view-item-perks-button-wishlist-perks-marked-as-junk";
        ItemPerksClasses["Shaped"] = "view-item-perks-button-wishlist-perks-shaped";
        ItemPerksClasses["ViewingWishlist"] = "view-item-perks-viewing-wishlist";
        ItemPerksClasses["Wishlisting"] = "view-item-perks-wishlisting";
        ItemPerksClasses["WishlistContainer"] = "view-item-perks-wishlist-container";
        ItemPerksClasses["WishlistButtonAdd"] = "view-item-perks-wishlist-button-add";
        ItemPerksClasses["WishlistButtonAddPlusIcon"] = "view-item-perks-wishlist-button-add-plus-icon";
        ItemPerksClasses["WishlistButtonConfirm"] = "view-item-perks-wishlist-button-confirm";
        ItemPerksClasses["WishlistButtonConfirmIcon"] = "view-item-perks-wishlist-button-confirm-icon";
        ItemPerksClasses["WishlistDrawer"] = "view-item-perks-wishlist-drawer";
        ItemPerksClasses["Wishlist"] = "view-item-perks-wishlist-drawer-wishlist";
        ItemPerksClasses["WishlistTitle"] = "view-item-perks-wishlist-drawer-wishlist-title";
        ItemPerksClasses["WishlistRemove"] = "view-item-perks-wishlist-drawer-wishlist-remove";
        ItemPerksClasses["WishlistRemoveIcon"] = "view-item-perks-wishlist-drawer-wishlist-remove-icon";
        ItemPerksClasses["WishlistNameInput"] = "view-item-perks-wishlist-name-input";
        ItemPerksClasses["NoRollsPlease"] = "view-item-perks-wishlist-no-rolls-please";
    })(ItemPerksClasses || (exports.ItemPerksClasses = ItemPerksClasses = {}));
    class ItemPerks extends ItemSockets_3.default {
        getTitle() {
            const cats = this.item.definition.itemCategoryHashes;
            const catName = cats?.includes(43 /* ItemCategoryHashes.Sparrows */) ? "Vehicle"
                : cats?.includes(20 /* ItemCategoryHashes.Armor */) ? "Armour"
                    : "Weapon";
            return `${catName} Perks`;
        }
        initialise() {
            this.classes.add(ItemPerksClasses.Main);
            this.sockets = [];
            const randomIntrinsics = this.item.getCollectionsRandomIntrinsics();
            if (randomIntrinsics?.exotics)
                this.sockets.push(...this.addSocketsByType("Intrinsic/Exotic"));
            if (randomIntrinsics?.frames)
                this.sockets.push(...this.addSocketsByType("Intrinsic/Frame"));
            this.sockets.push(...this.addSocketsByType("Perk"));
            this.wishlists = Store_16.default.items[`item${this.item.baseItem?.hash ?? this.item.definition.hash}PerkWishlists`];
            if (this.item.instance) {
                Button_19.default.create()
                    .classes.add(Card_7.CardClasses.TitleButton, Card_7.CardClasses.DisplayModeSectionTitleButton, ItemPerksClasses.ButtonWishlistPerks)
                    .classes.toggle(this.wishlists?.length === 0, ItemPerksClasses.MarkedAsJunk)
                    .classes.toggle(!!this.item.shaped, ItemPerksClasses.Shaped)
                    .text.set(this.item.shaped ? "Weapon Level Perk Unlocks" : this.wishlists?.length === 0 ? "Marked as Junk" : "Wishlist Perks")
                    .event.subscribe("click", () => this.event.emit("showCollections"))
                    .appendTo(this.title);
                // move socketed plugs first
                for (const socket of this.sockets)
                    for (const plug of socket.plugs)
                        if (plug.plug?.socketed)
                            plug.prependTo(socket);
                return;
            }
            // if (this.inventory.isCrafted(this.item.definition.hash)) {
            // 	delete Store.items[`item${this.item.definition.hash}PerkWishlists`];
            // 	return;
            // }
            this.saveWishlists({ preserveMarkedAsJunk: true });
            for (const socket of this.sockets) {
                for (const plug of socket.plugs) {
                    plug.event.subscribe("click", () => {
                        if (plug.plug?.is("Perk/TraitEnhanced") || plug.plug?.type.endsWith("Enhanced"))
                            return;
                        if (!this.editingWishlist)
                            this.editNewWishlist();
                        plug.classes.toggle(ItemSockets_3.ItemSocketsClasses.PlugSelected);
                        if (this.editingWishlist) {
                            const plugs = [];
                            for (const socket of this.sockets) {
                                for (const plug of socket.plugs) {
                                    if (plug.classes.has(ItemSockets_3.ItemSocketsClasses.PlugSelected)) {
                                        plugs.push(plug.hash);
                                    }
                                }
                            }
                            this.editingWishlist.plugs = plugs;
                            this.saveWishlists({ preserveEmptyWishlists: true });
                        }
                    });
                }
            }
            this.wishlistNameInput = Component_80.default.create()
                .classes.add(ItemPerksClasses.WishlistNameInput)
                .text.set(this.wishlists?.length === 0 ? "MARKED AS JUNK" : "WISHLIST")
                .attributes.set("contenteditable", "")
                .attributes.add("inert")
                .event.subscribe("input", () => {
                if (!this.editingWishlist)
                    return;
                this.editingWishlist.name = this.wishlistNameInput.text.get()?.trim().slice(0, 20) ?? "";
                this.saveWishlists({ preserveEmptyWishlists: true });
            })
                .event.subscribe("paste", this.onPaste);
            this.wishlistContainer = Component_80.default.create()
                .classes.add(ItemPerksClasses.WishlistContainer)
                .event.subscribe("mouseenter", () => {
                if (this.editingWishlist)
                    return;
                this.wishlistDrawer.open("mouse");
                this.wishlistNameInput.text.set("WISHLIST");
                this.wishlistButton.classes.remove(ItemPerksClasses.MarkedAsJunk);
            })
                .event.subscribe("mouseleave", event => {
                if (this.wishlistContainer.contains(document.elementFromPoint(event.clientX, event.clientY)))
                    return;
                this.wishlistDrawer.close("mouse");
                if (!this.editingWishlist) {
                    const displayMarkedAsJunk = this.wishlists?.length === 0;
                    this.wishlistNameInput.text.set(displayMarkedAsJunk ? "MARKED AS JUNK" : "WISHLIST");
                    this.wishlistButton.classes.toggle(displayMarkedAsJunk, ItemPerksClasses.MarkedAsJunk);
                }
            })
                .appendTo(this.title);
            this.wishlistDrawer = Drawer_5.default.create()
                .classes.add(ItemPerksClasses.WishlistDrawer)
                .appendTo(this.wishlistContainer);
            this.wishlistDrawer.focusOnClick = false;
            this.renderWishlists();
            this.wishlistConfirmButton = Button_19.default.create()
                .classes.add(ItemPerksClasses.WishlistButtonConfirm)
                .attributes.add("inert")
                .event.subscribe("click", event => this.doneEditingWishlist(event))
                .append(Component_80.default.create()
                .classes.add(ItemPerksClasses.WishlistButtonConfirmIcon));
            this.wishlistButton = Button_19.default.create("div")
                .classes.add(Card_7.CardClasses.TitleButton, Card_7.CardClasses.DisplayModeSectionTitleButton, ItemPerksClasses.WishlistButtonAdd)
                .classes.toggle(this.wishlists?.length === 0, ItemPerksClasses.MarkedAsJunk)
                .attributes.set("tabindex", "0")
                .attributes.set("role", "button")
                .event.subscribe("click", () => {
                if (this.editingWishlist)
                    return;
                this.editNewWishlist();
            })
                .append(Component_80.default.create()
                .classes.add(ItemPerksClasses.WishlistButtonAddPlusIcon))
                .append(this.wishlistNameInput)
                .append(this.wishlistConfirmButton)
                .appendTo(this.wishlistContainer);
            UiEventBus_12.default.until(viewManager.event.waitFor("hide"), events => events
                .subscribe("keydown", this.onKeydown));
        }
        renderWishlists() {
            this.wishlistDrawer.removeContents();
            for (const wishlist of this.wishlists ?? []) {
                Component_80.default.create()
                    .classes.add(ItemPerksClasses.Wishlist)
                    .append(Button_19.default.create()
                    .classes.add(ItemPerksClasses.WishlistTitle)
                    .text.set(wishlist.name)
                    .event.subscribe("click", () => this.editWishlist(wishlist)))
                    .append(Button_19.default.create()
                    .classes.add(ItemPerksClasses.WishlistRemove)
                    .append(Component_80.default.create()
                    .classes.add(ItemPerksClasses.WishlistRemoveIcon))
                    .event.subscribe("click", () => this.removeWishlist(wishlist)))
                    .event.subscribe("mouseenter", () => this.displayWishlist(wishlist))
                    .event.subscribe("mouseleave", () => this.undisplayWishlist(wishlist))
                    .appendTo(this.wishlistDrawer);
            }
            this.wishlistNoRollsPlease = Checkbox_2.default.create([this.wishlists?.length === 0])
                .classes.add(ItemPerksClasses.NoRollsPlease)
                .classes.toggle(!!this.wishlists?.length, Classes_27.Classes.Hidden)
                .attributes.toggle(!!this.wishlists?.length, "inert")
                .tweak(checkbox => checkbox.label.text.set("Mark all rolls as junk"))
                .tweak(checkbox => checkbox.description.text.set("No perk combination satisfies me!"))
                .event.subscribe("update", ({ checked }) => {
                if (!this.wishlists?.length) {
                    this.wishlists = checked ? [] : undefined;
                    this.saveWishlists({ preserveMarkedAsJunk: true });
                }
            })
                .appendTo(this.wishlistDrawer);
        }
        displayWishlist(wishlist) {
            this.classes.add(ItemPerksClasses.ViewingWishlist);
            this.displayedWishlist = wishlist;
            for (const socket of this.sockets) {
                for (const plug of socket.plugs) {
                    plug.classes.toggle(wishlist.plugs.includes(plug.hash), ItemSockets_3.ItemSocketsClasses.PlugSelected);
                }
            }
        }
        undisplayWishlist(wishlist) {
            if (this.displayedWishlist !== wishlist)
                return;
            this.classes.remove(ItemPerksClasses.ViewingWishlist);
            for (const socket of this.sockets)
                for (const plug of socket.plugs)
                    plug.classes.remove(ItemSockets_3.ItemSocketsClasses.PlugSelected);
        }
        editNewWishlist() {
            return this.editWishlist({ name: `Wishlist${this.wishlists?.length ? ` ${this.wishlists.length + 1}` : ""}`, plugs: [] });
        }
        editWishlist(wishlist) {
            if (this.displayedWishlist)
                this.undisplayWishlist(this.displayedWishlist);
            this.wishlists ??= [];
            if (!this.wishlists.includes(wishlist))
                this.wishlists.push(wishlist);
            this.backupEditingWishlist = { ...wishlist, plugs: [...wishlist.plugs] };
            this.editingWishlist = wishlist;
            this.classes.add(ItemPerksClasses.Wishlisting);
            this.wishlistButton.classes.add(Button_19.ButtonClasses.Selected);
            for (const socket of this.sockets) {
                for (const plug of socket.plugs) {
                    plug.classes.toggle(wishlist.plugs.includes(plug.hash), ItemSockets_3.ItemSocketsClasses.PlugSelected);
                }
            }
            this.wishlistNameInput.attributes.remove("inert");
            this.wishlistConfirmButton.attributes.remove("inert");
            this.wishlistNameInput.text.set(wishlist.name);
            window.getSelection()?.selectAllChildren(this.wishlistNameInput.element);
            this.wishlistDrawer.close(true);
            this.saveWishlists({ preserveEmptyWishlists: true });
            this.renderWishlists();
        }
        cancelEditingWishlist() {
            this.editingWishlist = this.backupEditingWishlist;
            this.doneEditingWishlist();
            if (this.wishlistNameInput.isFocused())
                this.wishlistButton.focus();
        }
        doneEditingWishlist(event) {
            delete this.editingWishlist;
            this.classes.remove(ItemPerksClasses.Wishlisting);
            this.wishlistButton.classes.remove(Button_19.ButtonClasses.Selected);
            this.wishlistNameInput.attributes.add("inert");
            this.wishlistConfirmButton.attributes.add("inert");
            for (const socket of this.sockets)
                for (const plug of socket.plugs)
                    plug.classes.remove(ItemSockets_3.ItemSocketsClasses.PlugSelected);
            this.saveWishlists();
            this.renderWishlists();
            event?.stopImmediatePropagation();
            const hovered = document.querySelectorAll(":hover");
            if (this.wishlistContainer.contains(hovered[hovered.length - 1]))
                this.wishlistDrawer.open("mouse");
        }
        removeWishlist(wishlist) {
            if (this.displayedWishlist === wishlist)
                this.undisplayWishlist(wishlist);
            const index = this.wishlists?.indexOf(wishlist);
            if (index !== undefined && index >= 0)
                this.wishlists.splice(index, 1);
            this.saveWishlists();
            this.renderWishlists();
        }
        cleanupWishlists(options) {
            if (!options?.preserveEmptyWishlists)
                this.wishlists = this.wishlists?.filter(wishlist => wishlist.name !== "" && wishlist.plugs.length > 0);
            if (!this.wishlists?.length && !options?.preserveMarkedAsJunk)
                delete this.wishlists;
            if (!this.editingWishlist) {
                const displayMarkedAsJunk = this.wishlists?.length === 0 && !this.wishlistDrawer?.isOpen();
                this.wishlistNameInput?.text.set(displayMarkedAsJunk ? "MARKED AS JUNK" : "WISHLIST");
                this.wishlistButton?.classes.toggle(displayMarkedAsJunk, ItemPerksClasses.MarkedAsJunk);
            }
        }
        saveWishlists(options) {
            this.cleanupWishlists(options);
            Store_16.default.items[`item${this.item.baseItem?.hash ?? this.item.definition.hash}PerkWishlists`] = this.wishlists;
        }
        onKeydown(event) {
            if (this.editingWishlist && event.useOverInput("Escape"))
                this.cancelEditingWishlist();
            if (this.wishlistButton.isFocused() && !this.editingWishlist && (event.use(" ") || event.use("Enter")))
                this.editNewWishlist();
        }
        onPaste(event) {
            event.preventDefault();
            const data = event.clipboardData?.getData("text/plain");
            if (!data)
                return;
            const selection = window.getSelection();
            for (let i = 0; i < (selection?.rangeCount ?? 0); i++) {
                const range = selection?.getRangeAt(i);
                if (!range)
                    continue;
                if (!this.wishlistNameInput.element.contains(range.startContainer) || !this.wishlistNameInput.element.contains(range.endContainer))
                    continue;
                range.deleteContents();
                range.insertNode(document.createTextNode(data.replace(/\n/g, "")));
                range.collapse();
            }
        }
    }
    exports.default = ItemPerks;
    __decorate([
        Bound_28.default
    ], ItemPerks.prototype, "onKeydown", null);
});
define("ui/view/item/ItemView", ["require", "exports", "model/Model", "model/models/Inventory", "model/models/Manifest", "model/models/ProfileBatch", "model/models/items/Item", "ui/component/Button", "ui/component/Component", "ui/destiny/component/IItemComponent", "ui/destiny/component/ItemComponent", "ui/destiny/tooltip/item/ItemAmmo", "ui/destiny/tooltip/item/ItemStat", "ui/destiny/tooltip/item/ItemStatTracker", "ui/destiny/utility/ElementTypes", "ui/utility/DisplayProperties", "ui/utility/LoadingManager", "ui/view/ErrorView", "ui/view/View", "ui/view/item/ItemIntrinsics", "ui/view/item/ItemPerks", "utility/Objects"], function (require, exports, Model_20, Inventory_9, Manifest_27, ProfileBatch_12, Item_8, Button_20, Component_81, IItemComponent_8, ItemComponent_7, ItemAmmo_2, ItemStat_3, ItemStatTracker_2, ElementTypes_3, DisplayProperties_18, LoadingManager_2, ErrorView_1, View_12, ItemIntrinsics_1, ItemPerks_1, Objects_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemViewClasses = void 0;
    exports.resolveItemURL = resolveItemURL;
    async function resolveItemURL(url, api) {
        const [bucketId, itemId] = url.split("/");
        const total = bucketId === "collections" ? 3 : 2;
        const manifest = await api.subscribeProgressAndWait(Manifest_27.default, 1 / total);
        const inventory = await api.subscribeProgressAndWait(Inventory_9.default.createModel(), 1 / total, 1 / total);
        const { DestinyInventoryItemDefinition } = manifest;
        if (bucketId !== "collections")
            return inventory.getItem(itemId);
        const itemDef = await DestinyInventoryItemDefinition.get(itemId);
        if (!itemDef)
            return;
        return Item_8.default.createFake(manifest, ProfileBatch_12.default.latest ?? {}, itemDef);
    }
    var ItemViewClasses;
    (function (ItemViewClasses) {
        ItemViewClasses["Item"] = "view-item-header-item";
        ItemViewClasses["ItemDefinition"] = "view-item-definition";
        ItemViewClasses["FlavourText"] = "view-item-flavour-text";
        ItemViewClasses["PerksModsTraits"] = "view-item-perks-mods-traits";
        ItemViewClasses["ButtonViewInCollections"] = "view-item-button-view-in-collections";
        ItemViewClasses["LockButton"] = "view-item-lock-button";
        ItemViewClasses["LockButtonLocked"] = "view-item-lock-button-locked";
        ItemViewClasses["Foundry"] = "view-item-foundry";
        ItemViewClasses["StatsContainer"] = "view-item-stats-container";
        ItemViewClasses["Stats"] = "view-item-stats";
        ItemViewClasses["PrimaryInfo"] = "view-item-primary-info";
        ItemViewClasses["PrimaryInfoPowerLabel"] = "view-item-primary-info-power-label";
        ItemViewClasses["PrimaryInfoPower"] = "view-item-primary-info-power";
        ItemViewClasses["PrimaryInfoElement"] = "view-item-primary-info-element";
        ItemViewClasses["PrimaryInfoAmmo"] = "view-item-primary-info-ammo";
        ItemViewClasses["PrimaryInfoTracker"] = "view-item-primary-info-tracker";
    })(ItemViewClasses || (exports.ItemViewClasses = ItemViewClasses = {}));
    const itemViewBase = View_12.default.create({
        models: (item) => [Manifest_27.default, Inventory_9.default.createModel(), Model_20.default.createTemporary(async (api) => typeof item !== "string" ? item : resolveItemURL(item, api), "resolveItemURL")],
        id: "item",
        hash: (item) => typeof item === "string" ? `item/${item}` : `item/${item.bucket.isCollections() ? "collections" : "inventory"}/${item.bucket.isCollections() ? item.definition.hash : item.id}`,
        name: (item) => typeof item === "string" ? "Item Details" : item.definition.displayProperties.name,
        noDestinationButton: true,
        noProfileInURL: (item) => typeof item === "string" ? item.startsWith("collections") : item.bucket.isCollections(),
        subView: true,
        initialise: async (view, manifest, inventory, itemResult) => {
            LoadingManager_2.default.end(view.definition.id);
            const item = itemResult;
            if (!item) {
                return ErrorView_1.default.show(404, {
                    title: "Error: No Item Found",
                    subtitle: "Your ghost continues its search...",
                    buttonText: "View Collections",
                    buttonClick: () => viewManager.showCollections(),
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.$i = window.item = item;
            console.log(DisplayProperties_18.default.name(item.definition), item);
            view.classes.toggle(!item.instance, ItemViewClasses.ItemDefinition)
                .setTitle(title => title.text.set(item.definition.displayProperties.name))
                .setSubtitle("caps", subtitle => subtitle.text.set(item.definition.itemTypeDisplayName));
            const screenshot = item.getOrnament()?.definition?.screenshot ?? item.definition.screenshot;
            const secondaryIcon = item.definition.secondaryIcon;
            if (screenshot)
                view.setBackground(`https://www.bungie.net${screenshot}`, ...secondaryIcon ? [`https://www.bungie.net${secondaryIcon}`] : [])
                    .setUnfiltered(true)
                    .tweak(mgr => mgr.backgrounds[1]?.classes.add(ItemViewClasses.Foundry));
            if (!item.bucket.isCollections()) {
                const lockButton = Button_20.default.create()
                    .classes.add(ItemViewClasses.LockButton)
                    .classes.toggle(item.isLocked(), ItemViewClasses.LockButtonLocked)
                    .event.subscribe("click", async () => {
                    lockButton.classes.toggle(ItemViewClasses.LockButtonLocked);
                    const locked = await item.setLocked(lockButton.classes.has(ItemViewClasses.LockButtonLocked));
                    lockButton.classes.toggle(locked, ItemViewClasses.LockButtonLocked);
                })
                    .appendTo(view.title);
            }
            ItemComponent_7.default.create([item])
                .classes.remove(IItemComponent_8.ItemClasses.NotAcquired)
                .classes.add(ItemViewClasses.Item)
                .clearTooltip()
                .setDisableInteractions()
                .event.subscribe("mouseenter", () => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                window.$i = window.item = item;
                console.log(DisplayProperties_18.default.name(item.definition), item);
            })
                .prependTo(view.header);
            Component_81.default.create("p")
                .classes.add(ItemViewClasses.FlavourText)
                .text.set(item.definition.flavorText)
                .appendTo(view.header);
            if (item.instance)
                Button_20.default.create()
                    .classes.add(ItemViewClasses.ButtonViewInCollections)
                    .text.set("View in Collections")
                    .event.subscribe("click", () => ItemView.showCollections(item))
                    .appendTo(view.header);
            Component_81.default.create()
                .classes.add(ItemViewClasses.PerksModsTraits)
                .append(ItemPerks_1.default.create([item, inventory])
                .event.subscribe("showCollections", () => ItemView.showCollections(item)))
                // .append(ItemMods.create([item]))
                .append(item.getCollectionsRandomIntrinsics() ? undefined : ItemIntrinsics_1.default.create([item, inventory]))
                .appendTo(view.content);
            const statsContainer = Component_81.default.create()
                .classes.add(ItemViewClasses.StatsContainer)
                .appendTo(view.content);
            const energy = item.instance?.energy;
            const { DestinyDamageTypeDefinition, DestinyEnergyTypeDefinition } = manifest;
            const damageType = await DestinyDamageTypeDefinition.get(item.instance?.damageTypeHash ?? item.definition.defaultDamageTypeHash);
            const energyType = await DestinyEnergyTypeDefinition.get(energy?.energyTypeHash);
            const owner = item.owner;
            const elementTypeName = (damageType?.displayProperties.name ?? energyType?.displayProperties.name ?? "Unknown").toLowerCase();
            Component_81.default.create()
                .classes.add(ItemViewClasses.PrimaryInfo)
                .append(Component_81.default.create()
                .classes.add(ItemViewClasses.PrimaryInfoPowerLabel)
                .text.set("POWER"))
                .append(Component_81.default.create()
                .classes.add(ItemViewClasses.PrimaryInfoElement, `${ItemViewClasses.PrimaryInfoElement}-${elementTypeName}`)
                .style.set("--icon", DisplayProperties_18.default.icon(damageType) ?? DisplayProperties_18.default.icon(energyType))
                .style.set("--colour", ElementTypes_3.default.getColour(elementTypeName)))
                .append(Component_81.default.create()
                .classes.add(ItemViewClasses.PrimaryInfoPower)
                .text.set(`${item.getPower() ?? owner?.power ?? 0}`))
                .append(ItemAmmo_2.default.create()
                .classes.add(ItemViewClasses.PrimaryInfoAmmo)
                .setItem(item))
                .append(ItemStatTracker_2.default.create()
                .classes.add(ItemViewClasses.PrimaryInfoTracker)
                .setItem(item))
                .appendTo(statsContainer);
            const stats = ItemStat_3.default.Wrapper.create()
                .classes.add(ItemViewClasses.Stats);
            if (stats.setItem(item))
                stats.appendTo(statsContainer);
        },
    });
    class ItemViewClass extends View_12.default.Handler {
        showCollections(item) {
            this.show(`collections/${item.definition.hash}`);
        }
    }
    const ItemView = Objects_6.default.inherit(itemViewBase, ItemViewClass);
    exports.default = ItemView;
});
define("ui/view/item/ArtifactView", ["require", "exports", "model/Model", "model/models/Characters", "model/models/Inventory", "model/models/Manifest", "ui/component/Button", "ui/component/Component", "ui/destiny/component/ItemComponent", "ui/utility/DisplayProperties", "ui/utility/LoadingManager", "ui/view/View", "ui/view/item/ItemView", "utility/Objects", "utility/Strings"], function (require, exports, Model_21, Characters_14, Inventory_10, Manifest_28, Button_21, Component_82, ItemComponent_8, DisplayProperties_19, LoadingManager_3, View_13, ItemView_1, Objects_7, Strings_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveArtifactURL = resolveArtifactURL;
    async function resolveArtifactURL(url, api) {
        const inventory = await api.subscribeProgressAndWait(Inventory_10.default.createModel(), 1 / 4, 2 / 4);
        url = !url ? url : Strings_8.default.sliceTo(url, "/");
        return inventory.getBucket(1506418338 /* InventoryBucketHashes.SeasonalArtifact */, (url ?? Characters_14.default.getCurrent()?.characterId))?.equippedItem;
    }
    var ArtifactViewClasses;
    (function (ArtifactViewClasses) {
        ArtifactViewClasses["Item"] = "view-artifact-header-item";
        ArtifactViewClasses["ItemDefinition"] = "view-artifact-definition";
        ArtifactViewClasses["FlavourText"] = "view-artifact-flavour-text";
    })(ArtifactViewClasses || (ArtifactViewClasses = {}));
    const artifactViewBase = View_13.default.create({
        models: (itemOrCharacterId) => [Manifest_28.default, Inventory_10.default.createModel(), Model_21.default.createTemporary(async (api) => typeof itemOrCharacterId === "object" ? itemOrCharacterId : resolveArtifactURL(itemOrCharacterId, api), "resolveArtifactURL")],
        id: "artifact",
        name: (itemOrCharacterId) => (typeof itemOrCharacterId !== "string" ? itemOrCharacterId?.definition.displayProperties.name : undefined) ?? "Artifact Details",
        hash: (itemOrCharacterId) => typeof itemOrCharacterId === "string" ? `artifact/${itemOrCharacterId}` : itemOrCharacterId?.bucket.characterId ? `artifact/${itemOrCharacterId.bucket.characterId}` : "artifact",
        noDestinationButton: true,
        subView: true,
        initialise: async (view, manifest, inventory, itemResult) => {
            LoadingManager_3.default.end(view.definition.id);
            const item = itemResult;
            if (!item) {
                view.setTitle(title => title.text.set("No Artifact Was Found..."));
                view.setSubtitle("small", subtitle => subtitle.text.set("Your ghost continues its search..."));
                // const content = Component.create()
                // 	.appendTo(view.content);
                // Button.create()
                // 	.text.set("View Collections")
                // 	.setPrimary()
                // 	.setAttention()
                // 	.event.subscribe("click", () => viewManager.showCollections())
                // 	.appendTo(content);
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.$i = window.item = item;
            console.log(DisplayProperties_19.default.name(item.definition), item);
            view.updateHash(item);
            view.header.classes.add("view-item-header");
            view.classes.toggle(!item.instance, ArtifactViewClasses.ItemDefinition)
                .setTitle(title => title.text.set(item.definition.displayProperties.name)
                .classes.add("view-item-title"))
                .setSubtitle("caps", subtitle => subtitle.text.set(item.definition.itemTypeDisplayName));
            if (item.definition.screenshot)
                view.setBackground(`https://www.bungie.net${item.definition.screenshot}`);
            if (!item.bucket.isCollections()) {
                const lockButton = Button_21.default.create()
                    .classes.add(ItemView_1.ItemViewClasses.LockButton)
                    .classes.toggle(item.isLocked(), ItemView_1.ItemViewClasses.LockButtonLocked)
                    .event.subscribe("click", async () => {
                    lockButton.classes.toggle(ItemView_1.ItemViewClasses.LockButtonLocked);
                    const locked = await item.setLocked(lockButton.classes.has(ItemView_1.ItemViewClasses.LockButtonLocked));
                    lockButton.classes.toggle(locked, ItemView_1.ItemViewClasses.LockButtonLocked);
                })
                    .appendTo(view.title);
            }
            ItemComponent_8.default.create([item])
                .classes.add(ItemView_1.ItemViewClasses.Item)
                .clearTooltip()
                .setDisableInteractions()
                .event.subscribe("mouseenter", () => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                window.$i = window.item = item;
                console.log(DisplayProperties_19.default.name(item.definition), item);
            })
                .prependTo(view.header);
            Component_82.default.create("p")
                .classes.add(ArtifactViewClasses.FlavourText)
                .text.set(item.definition.flavorText)
                .appendTo(view.header);
        },
    });
    class ArtifactViewClass extends View_13.default.Handler {
    }
    const ArtifactView = Objects_7.default.inherit(artifactViewBase, ArtifactViewClass);
    exports.default = ArtifactView;
});
define("ui/view/itemtooltip/ItemTooltipView", ["require", "exports", "model/Model", "model/models/Inventory", "model/models/Manifest", "ui/component/Button", "ui/component/Component", "ui/destiny/tooltip/ItemTooltip", "ui/utility/LoadingManager", "ui/view/View", "ui/view/item/ItemView"], function (require, exports, Model_22, Inventory_11, Manifest_29, Button_22, Component_83, ItemTooltip_4, LoadingManager_4, View_14, ItemView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemTooltipViewClasses = void 0;
    var ItemTooltipViewClasses;
    (function (ItemTooltipViewClasses) {
        ItemTooltipViewClasses["Tooltip"] = "view-item-tooltip-tooltip";
        ItemTooltipViewClasses["Button"] = "view-item-tooltip-button";
        ItemTooltipViewClasses["Buttons"] = "view-item-tooltip-buttons";
    })(ItemTooltipViewClasses || (exports.ItemTooltipViewClasses = ItemTooltipViewClasses = {}));
    const tooltipViewModels = [Manifest_29.default, Inventory_11.default.createModel()];
    exports.default = View_14.default.create({
        models: (item) => [
            ...tooltipViewModels,
            ...typeof item !== "string" ? []
                : [Model_22.default.createTemporary(async (api) => (0, ItemView_2.resolveItemURL)(item, api))]
        ],
        noDestinationButton: true,
        id: "item-tooltip",
        hash: (item) => typeof item === "string" ? `item-tooltip/${item}` : `item-tooltip/${item.bucket.isCollections() ? "collections" : item.bucket.hash}/${item.id}`,
        name: (item) => typeof item === "string" ? "Item" : item.definition.displayProperties.name,
        initialise: async (view, manifest, inventory, itemModel) => {
            LoadingManager_4.default.end(view.definition.id);
            const item = view._args[1] = itemModel ?? view._args[1];
            console.log(item.definition.displayProperties.name, item);
            const owner = item.owner;
            const itemTooltip = ItemTooltip_4.default.createRaw()
                .classes.add(ItemTooltipViewClasses.Tooltip);
            await itemTooltip.setItem(item, inventory);
            itemTooltip.appendTo(view.content);
            itemTooltip.footer.remove();
            const { DestinyClassDefinition } = manifest;
            const buttons = Component_83.default.create()
                .classes.add(ItemTooltipViewClasses.Buttons)
                .appendTo(view.content);
            const cls = !owner ? undefined : await DestinyClassDefinition.get(owner.classHash);
            const className = cls?.displayProperties.name ?? "Unknown";
            const inEngramBucket = item.reference.bucketHash === 375726501 /* InventoryBucketHashes.Engrams */;
            if (owner && !item.bucket.isCharacter() && !item.equipped && !inEngramBucket)
                Button_22.default.create()
                    .classes.add(ItemTooltipViewClasses.Button)
                    .text.set(`Pull to ${className}`)
                    .event.subscribe("click", () => {
                    void item.transferToCharacter(owner.characterId);
                    view.back();
                })
                    .appendTo(buttons);
            if (owner && item.bucket.isCharacter() && !item.equipped)
                Button_22.default.create()
                    .classes.add(ItemTooltipViewClasses.Button)
                    .text.set(`Equip to ${className}`)
                    .event.subscribe("click", () => {
                    void item.equip(owner.characterId);
                    view.back();
                })
                    .appendTo(buttons);
            if (item.bucket.isVault() && !item.equipped && !inEngramBucket)
                Button_22.default.create()
                    .classes.add(ItemTooltipViewClasses.Button)
                    .text.set("Vault")
                    .event.subscribe("click", () => {
                    void item.transferToVault();
                    view.back();
                })
                    .appendTo(buttons);
            if (!inEngramBucket)
                Button_22.default.create()
                    .classes.add(ItemTooltipViewClasses.Button)
                    .text.set("Details")
                    .event.subscribe("click", () => ItemView_2.default.show(item))
                    .appendTo(buttons);
        },
    });
});
define("ui/view/settings/SettingsBackground", ["require", "exports", "model/models/WallpaperMoments", "ui/component/Button", "ui/component/Card", "ui/component/Component", "ui/component/Loadable", "ui/component/form/Checkbox", "ui/component/form/RangeInput", "utility/Env", "utility/Store"], function (require, exports, WallpaperMoments_2, Button_23, Card_8, Component_84, Loadable_6, Checkbox_3, RangeInput_2, Env_10, Store_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsBackgroundClasses;
    (function (SettingsBackgroundClasses) {
        SettingsBackgroundClasses["BackgroundOptions"] = "settings-background-options";
        SettingsBackgroundClasses["InternalWrapper"] = "settings-background-options-wrapper";
        SettingsBackgroundClasses["Wallpaper"] = "settings-background-options-wallpaper";
        SettingsBackgroundClasses["WallpaperLoadingThumbnail"] = "settings-background-options-wallpaper-loading-thumbnail";
        SettingsBackgroundClasses["WallpaperMoment"] = "settings-background-options-wallpaper-moment";
        SettingsBackgroundClasses["WallpaperMomentWallpapers"] = "settings-background-options-wallpaper-moment-list";
        SettingsBackgroundClasses["WallpaperMomentLabel"] = "settings-background-options-wallpaper-moment-label";
        SettingsBackgroundClasses["WallpaperImage"] = "settings-background-options-wallpaper-image";
        SettingsBackgroundClasses["OptionsRow"] = "settings-background-options-row";
    })(SettingsBackgroundClasses || (SettingsBackgroundClasses = {}));
    class SettingsBackground extends Card_8.default {
        onMake() {
            super.onMake();
            this.title.text.set("Background");
            const remotepath = "https://deepsight.gg/";
            let scrollLeft;
            const momentsWrapper = Loadable_6.default.create(WallpaperMoments_2.default)
                .onReady(moments => Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.InternalWrapper)
                .append(...[...moments].reverse().map(moment => Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.WallpaperMoment)
                .append(Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.WallpaperMomentLabel)
                .text.set(moment.moment.displayProperties.name))
                .append(Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.WallpaperMomentWallpapers)
                .append(...[...moment.wallpapers, ...moment.secondaryWallpapers].map(wallpaper => Button_23.default.create()
                .classes.add(SettingsBackgroundClasses.Wallpaper)
                .classes.toggle(Store_17.default.items.settingsBackground === wallpaper, Button_23.ButtonClasses.Selected)
                .event.subscribe("click", (event) => {
                document.querySelector(`.${SettingsBackgroundClasses.Wallpaper}.${Button_23.ButtonClasses.Selected}`)
                    ?.classList.remove(Button_23.ButtonClasses.Selected);
                if (Store_17.default.items.settingsBackground === wallpaper) {
                    delete Store_17.default.items.settingsBackground;
                    Store_17.default.items.settingsBackgroundNoUseDefault = true;
                    return;
                }
                event.target.classList.add(Button_23.ButtonClasses.Selected);
                Store_17.default.items.settingsBackground = wallpaper;
                Store_17.default.items.settingsBackgroundNoUseDefault = true;
            })
                .append(Component_84.default.create("img")
                .classes.add(SettingsBackgroundClasses.WallpaperImage)
                .attributes.set("loading", "lazy")
                .attributes.set("src", wallpaper.startsWith(remotepath) ? `${Env_10.default.DEEPSIGHT_PATH}${wallpaper.slice(remotepath.length)}` : wallpaper))
                .tweak(button => button.attributes.set("data-wallpaper", wallpaper))))))))
                .classes.add(SettingsBackgroundClasses.BackgroundOptions)
                .setSimple()
                .event.subscribe("mousedown", () => {
                scrollLeft = undefined;
            })
                .event.subscribe("wheel", event => {
                if (event.shiftKey)
                    return;
                if (scrollLeft === undefined || Math.sign(event.deltaY) !== Math.sign(scrollLeft - momentsWrapper.element.scrollLeft))
                    scrollLeft = momentsWrapper.element.scrollLeft;
                scrollLeft += event.deltaY;
                if (scrollLeft + momentsWrapper.element.clientWidth > momentsWrapper.element.scrollWidth)
                    scrollLeft = momentsWrapper.element.scrollWidth - momentsWrapper.element.clientWidth;
                if (scrollLeft < 0)
                    scrollLeft = 0;
                momentsWrapper.element.scrollLeft = scrollLeft;
            })
                .appendTo(this.content);
            // async function renderThumbnails () {
            // 	let hasUnloadedThumbnail = false;
            // 	let i = -1;
            // 	for (const button of sourcesWrapper.element.getElementsByClassName(SettingsBackgroundClasses.Wallpaper)) {
            // 		i++;
            // 		if (button.classList.contains(SettingsBackgroundClasses.WallpaperLoadingThumbnail))
            // 			continue;
            // 		if (sourcesWrapper.element.scrollLeft + 500 > i * 144) {
            // 			button.classList.add(SettingsBackgroundClasses.WallpaperLoadingThumbnail);
            // 			button.append(await createWallpaperThumbnail((button as HTMLElement).dataset.wallpaper!));
            // 			continue;
            // 		}
            // 		hasUnloadedThumbnail = true;
            // 	}
            // 	if (hasUnloadedThumbnail)
            // 		// eslint-disable-next-line @typescript-eslint/no-misused-promises
            // 		setTimeout(renderThumbnails, 1);
            // }
            // void Async.sleep(500).then(renderThumbnails);
            const randomiseCheckbox = Checkbox_3.default.create([!Store_17.default.items.settingsBackground && !Store_17.default.items.settingsBackgroundNoUseDefault])
                .tweak(checkbox => checkbox.label.text.set("Randomise"))
                .event.subscribe("update", ({ checked }) => {
                Store_17.default.items.settingsBackgroundNoUseDefault = checked ? undefined : true;
                if (!Store_17.default.items.settingsBackgroundNoUseDefault) {
                    delete Store_17.default.items.settingsBackground;
                    document.querySelector(`.${SettingsBackgroundClasses.Wallpaper}.${Button_23.ButtonClasses.Selected}`)
                        ?.classList.remove(Button_23.ButtonClasses.Selected);
                }
            })
                .appendTo(this.content);
            Store_17.default.subscribeBackgroundChange(() => randomiseCheckbox.checkbox.element.checked = !Store_17.default.items.settingsBackground && !Store_17.default.items.settingsBackgroundNoUseDefault);
            Checkbox_3.default.create([Store_17.default.items.settingsBackgroundFollowMouse])
                .tweak(checkbox => checkbox.label.text.set("Follow Mouse"))
                .event.subscribe("update", ({ checked }) => Store_17.default.items.settingsBackgroundFollowMouse = checked ? true : undefined)
                .appendTo(this.content);
            const blurWrapper = Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.OptionsRow)
                .text.add("Blur")
                .appendTo(this.content);
            const blurInput = RangeInput_2.default.create([{ min: 0, max: 3, step: 0.01, default: 0.5 }])
                .event.subscribe("input", () => {
                Store_17.default.items.settingsBackgroundBlur = blurInput.value;
            })
                .appendTo(blurWrapper);
            blurInput.value = Store_17.default.items.settingsBackgroundBlur === true ? 0.5 : Store_17.default.items.settingsBackgroundBlur ?? 0;
            const darknessWrapper = Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.OptionsRow)
                .text.add("Darkness")
                .appendTo(this.content);
            const darknessInput = RangeInput_2.default.create([{ min: 0, max: 1, step: 0.01, default: 0.5 }])
                .event.subscribe("input", () => {
                Store_17.default.items.settingsBackgroundDarkness = darknessInput.value;
            })
                .appendTo(darknessWrapper);
            darknessInput.value = Store_17.default.items.settingsBackgroundDarkness ?? 0.5;
            const prismaticWrapper = Component_84.default.create()
                .classes.add(SettingsBackgroundClasses.OptionsRow)
                .text.add("Prismatic")
                .appendTo(this.content);
            const input = RangeInput_2.default.create([{ min: 0, max: 1, step: 0.01, default: 0.5 }])
                .event.subscribe("input", () => Store_17.default.items.settingsBackgroundRainbowVibrancy = input.value)
                .appendTo(prismaticWrapper);
            input.value = Store_17.default.items.settingsBackgroundRainbowVibrancy ?? 0.5;
        }
    }
    exports.default = SettingsBackground;
});
define("ui/component/DescribedButton", ["require", "exports", "ui/component/Button", "ui/component/Component"], function (require, exports, Button_24, Component_85) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribedButtonClasses = void 0;
    var DescribedButtonClasses;
    (function (DescribedButtonClasses) {
        DescribedButtonClasses["Description"] = "button-description";
    })(DescribedButtonClasses || (exports.DescribedButtonClasses = DescribedButtonClasses = {}));
    class DescribedButton extends Component_85.default {
        onMake() {
            this.button = Button_24.default.basic()
                .appendTo(this);
            this.description = Component_85.default.create("p")
                .classes.add(DescribedButtonClasses.Description)
                .appendTo(this);
        }
    }
    exports.default = DescribedButton;
});
define("ui/view/settings/SettingsDeviceStorage", ["require", "exports", "model/Model", "ui/component/Card", "ui/component/Component", "ui/component/DescribedButton"], function (require, exports, Model_23, Card_9, Component_86, DescribedButton_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // const membershipNames: Record<BungieMembershipType, string> = {
    // 	[BungieMembershipType.None]: "None",
    // 	[BungieMembershipType.All]: "All",
    // 	[BungieMembershipType.TigerXbox]: "Xbox",
    // 	[BungieMembershipType.TigerPsn]: "Playstation",
    // 	[BungieMembershipType.TigerSteam]: "Steam",
    // 	[BungieMembershipType.TigerBlizzard]: "Blizzard",
    // 	[BungieMembershipType.TigerStadia]: "Stadia",
    // 	[BungieMembershipType.TigerEgs]: "Epic",
    // 	[BungieMembershipType.TigerDemon]: "Demon",
    // 	[BungieMembershipType.BungieNext]: "BungieNext",
    // };
    class SettingsDeviceStorage extends Card_9.default {
        onMake() {
            super.onMake();
            this.title.text.set("Account & Storage");
            // Component.create("h1")
            // 	.text.set("If you see this Chiri was bad and forgot to readd something she was too lazy to fix")
            // 	.appendTo(this.content);
            // const memberships = !Bungie.authenticated ? undefined : await Promise.race([Memberships.await(), Async.sleep(5000)]).catch(() => undefined);
            // // if cross save is disabled and there's more than one membership, show a selection for which destiny membership should be viewed
            // if ((memberships?.destinyMemberships.length ?? 0) > 1) {
            // 	const membershipsDropdown = Dropdown.create()
            // 		.addLabel(label => label.text.set("Platform"))
            // 		.tweak(dropdown => memberships!.destinyMemberships.forEach(membership => dropdown.addOption(option => option
            // 			.attributes.set("data-membership-type", `${membership.membershipType}`)
            // 			.text.set(membershipNames[membership.membershipType] ?? "Unknown Membership Type"))))
            // 		.tweak(dropdown => dropdown.options.forEach(option => {
            // 			if (+option.attributes.get("data-membership-type")! as BungieMembershipType === Store.items.destinyMembershipType)
            // 				option.click();
            // 		}))
            // 		.event.subscribe("change", () => {
            // 			Store.items.destinyMembershipType = +membershipsDropdown.activeOption.attributes.get("data-membership-type")! as BungieMembershipType;
            // 			void Profile.reset();
            // 			void Items.reset();
            // 		})
            // 		.appendTo(this.content);
            // }
            DescribedButton_1.default.create()
                .tweak(wrapper => wrapper.button.text.set("Clear Destiny Cache"))
                .tweak(wrapper => wrapper.description
                .text.set("Removes the Destiny manifest (a large database of information about the game downloaded from the Bungie.net API), your profile information, and some other misc Destiny data downloaded from other projects. Does not clear your deepsight.gg settings.")
                .append(Component_86.default.create("p")
                .append(Component_86.default.create("b").text.set("Note:"))
                .text.add(" Continuing to use the app will re-download the deleted data.")))
                .tweak(wrapper => wrapper.button.event.subscribe("click", async () => {
                await Model_23.default.clearCache(true);
                location.reload();
            }))
                .appendTo(this.content);
            // if (Bungie.authenticated)
            // 	DescribedButton.create()
            // 		.tweak(wrapper => wrapper.button.text.set("Unauthorise"))
            // 		.tweak(wrapper => wrapper.description.text.set("Forgets your Bungie.net authentication. (Note that the authentication token is not sent anywhere except Bungie.net, and it's stored on your device.)"))
            // 		.tweak(wrapper => wrapper.button.event.subscribe("click", async () => {
            // 			Bungie.resetAuthentication();
            // 			location.reload();
            // 		}))
            // 		.appendTo(this.content);
        }
    }
    exports.default = SettingsDeviceStorage;
});
define("ui/view/settings/SettingsInventoryDisplay", ["require", "exports", "ui/component/Card", "ui/component/Component", "ui/component/form/Checkbox", "utility/Store"], function (require, exports, Card_10, Component_87, Checkbox_4, Store_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SettingsInformationDisplay extends Card_10.default {
        onMake() {
            super.onMake();
            this.title.text.set("Inventory Display");
            Checkbox_4.default.create([Store_18.default.items.settingsAlwaysShowExtra])
                .tweak(checkbox => checkbox.label.text.set("Always Show Extra Information"))
                .tweak(checkbox => checkbox.description.text.set("Additional information will always be displayed. On items  the relevant sort information. In tooltips  where applicable, a secondary tooltip detailing content in the main tooltip."))
                .event.subscribe("update", ({ checked }) => Store_18.default.items.settingsAlwaysShowExtra = checked ? true : undefined)
                .appendTo(this.content);
            Checkbox_4.default.create([Store_18.default.items.settingsToggleExtra])
                .tweak(checkbox => checkbox.label.text.set("Toggle Extra Information"))
                .tweak(checkbox => checkbox.description
                .append(Component_87.default.create("kbd").text.set("E"))
                .text.add(" toggles whether extra information is displayed, instead of requiring the key to be held."))
                .event.subscribe("update", ({ checked }) => Store_18.default.items.settingsToggleExtra = checked ? true : undefined)
                .appendTo(this.content);
            Checkbox_4.default.create([Store_18.default.items.settingsDisplayLocksOnItems])
                .tweak(checkbox => checkbox.label.text.set("Always Display Locks on Items"))
                .tweak(checkbox => checkbox.description.text.set("Display a lock in the centre left of locked items even when extra information isn't shown."))
                .event.subscribe("update", ({ checked }) => Store_18.default.items.settingsDisplayLocksOnItems = checked ? true : undefined)
                .appendTo(this.content);
            // Checkbox.create([!Store.items.settingsClearItemFilterOnSwitchingViews])
            // 	.tweak(checkbox => checkbox.label.text.set("Persistent Item Filter"))
            // 	.tweak(checkbox => checkbox.description.text.set("When reloading the page or switching between views (ie, from Kinetic to Special), any filters are retained."))
            // 	.event.subscribe("update", ({ checked }) =>
            // 		Store.items.settingsClearItemFilterOnSwitchingViews = !checked ? true : undefined)
            // 	.appendTo(this.content);
            Checkbox_4.default.create([Store_18.default.items.settingsDisplayWishlistedHighlights])
                .tweak(checkbox => checkbox.label.text.set("Highlight Items Matching Wishlists"))
                .tweak(checkbox => checkbox.description.text.set("Items that exactly match a wishlist you've created will be highlighted with a teal border."))
                .event.subscribe("update", ({ checked }) => Store_18.default.items.settingsDisplayWishlistedHighlights = checked ? true : undefined)
                .appendTo(this.content);
            Checkbox_4.default.create([!Store_18.default.items.settingsDisableDisplayNonWishlistedHighlights])
                .tweak(checkbox => checkbox.label.text.set("Highlight Items Not Matching Wishlists"))
                .tweak(checkbox => checkbox.description.text.set("Items that do not match wishlists you've created will be highlighted with a lime border."))
                .event.subscribe("update", ({ checked }) => Store_18.default.items.settingsDisplayWishlistedHighlights = !checked ? true : undefined)
                .appendTo(this.content);
        }
    }
    exports.default = SettingsInformationDisplay;
});
define("ui/view/settings/SettingsItemMovement", ["require", "exports", "ui/component/Card", "ui/component/form/Checkbox", "utility/Store"], function (require, exports, Card_11, Checkbox_5, Store_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SettingsItemMovement extends Card_11.default {
        onMake() {
            super.onMake();
            this.title.text.set("Item Movement");
            Checkbox_5.default.create([!Store_19.default.items.settingsDisableReturnOnFailure])
                .tweak(checkbox => checkbox.label.text.set("Return Items to Starting Location on Failure"))
                .tweak(checkbox => checkbox.description.text.set("When moving an item from one character to another, the item is first pulled into the vault. If in the process of moving the item, it fails to complete a step, this causes the item to be put back where it was originally."))
                .event.subscribe("update", ({ checked }) => Store_19.default.items.settingsDisableReturnOnFailure = !checked ? true : undefined)
                .appendTo(this.content);
        }
    }
    exports.default = SettingsItemMovement;
});
define("ui/view/settings/SettingsView", ["require", "exports", "ui/component/Component", "ui/view/View", "ui/view/settings/SettingsBackground", "ui/view/settings/SettingsDeviceStorage", "ui/view/settings/SettingsInventoryDisplay", "ui/view/settings/SettingsItemMovement"], function (require, exports, Component_88, View_15, SettingsBackground_1, SettingsDeviceStorage_1, SettingsInventoryDisplay_1, SettingsItemMovement_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = View_15.default.create({
        id: "settings",
        name: "Settings",
        auth: "optional",
        initialiseDestinationButton: button => button.text.remove(),
        initialise: view => view
            .setTitle(title => title.text.set("Settings"))
            .tweak(view => view.content.append(Component_88.default.create()
            .classes.add("view-settings-cards")
            .append(SettingsInventoryDisplay_1.default.create())
            .append(SettingsItemMovement_1.default.create())
            .append(SettingsBackground_1.default.create())
            .append(SettingsDeviceStorage_1.default.create()))),
    });
});
define("ui/utility/ViewManager", ["require", "exports", "Constants", "ui/view/AboutView", "ui/view/AuthView", "ui/view/ErrorView", "ui/view/View", "ui/view/collections/CollectionsView", "ui/view/collections/EmblemsView", "ui/view/collections/ModsView", "ui/view/inventory/InventoryInventoryView", "ui/view/inventory/equipment/InventoryArmourView", "ui/view/inventory/equipment/InventoryEquipmentView", "ui/view/inventory/equipment/InventoryWeaponsView", "ui/view/inventory/slot/InventoryArmsView", "ui/view/inventory/slot/InventoryChestView", "ui/view/inventory/slot/InventoryClassItemView", "ui/view/inventory/slot/InventoryEnergyView", "ui/view/inventory/slot/InventoryGhostView", "ui/view/inventory/slot/InventoryHelmetView", "ui/view/inventory/slot/InventoryKineticView", "ui/view/inventory/slot/InventoryLegsView", "ui/view/inventory/slot/InventoryPowerView", "ui/view/inventory/slot/InventoryShipView", "ui/view/inventory/slot/InventorySparrowView", "ui/view/item/ArtifactView", "ui/view/item/ItemView", "ui/view/itemtooltip/ItemTooltipView", "ui/view/settings/SettingsView", "utility/Async", "utility/EventManager", "utility/ProfileManager", "utility/Strings", "utility/URL"], function (require, exports, Constants_1, AboutView_2, AuthView_1, ErrorView_2, View_16, CollectionsView_1, EmblemsView_1, ModsView_1, InventoryInventoryView_1, InventoryArmourView_1, InventoryEquipmentView_1, InventoryWeaponsView_1, InventoryArmsView_3, InventoryChestView_3, InventoryClassItemView_3, InventoryEnergyView_3, InventoryGhostView_2, InventoryHelmetView_3, InventoryKineticView_3, InventoryLegsView_3, InventoryPowerView_3, InventoryShipView_2, InventorySparrowView_2, ArtifactView_1, ItemView_3, ItemTooltipView_1, SettingsView_1, Async_11, EventManager_20, ProfileManager_14, Strings_9, URL_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const registry = Object.fromEntries([
        AuthView_1.default,
        InventoryWeaponsView_1.default,
        InventoryArmourView_1.default,
        InventoryKineticView_3.default,
        InventoryEnergyView_3.default,
        InventoryPowerView_3.default,
        InventoryHelmetView_3.default,
        InventoryArmsView_3.default,
        InventoryChestView_3.default,
        InventoryLegsView_3.default,
        InventoryClassItemView_3.default,
        InventoryEquipmentView_1.default,
        InventoryGhostView_2.default,
        InventorySparrowView_2.default,
        InventoryShipView_2.default,
        InventoryInventoryView_1.default,
        CollectionsView_1.default,
        SettingsView_1.default,
        ItemView_3.default,
        ErrorView_2.default,
        ItemTooltipView_1.default,
        AboutView_2.default,
        EmblemsView_1.default,
        ModsView_1.default,
        ArtifactView_1.default,
        // VendorsView,
        // VendorView,
    ].map((view) => [view.id, view]));
    View_16.default.event.subscribe("show", ({ view }) => ViewManager.show(view));
    View_16.default.event.subscribe("hide", () => ViewManager.hide());
    URL_4.default.event.subscribe("navigate", () => {
        ViewManager.showByHash(URL_4.default.path ?? URL_4.default.hash);
    });
    class ViewManager {
        static get registry() {
            return registry;
        }
        static getDefaultView() {
            return ProfileManager_14.default.get() ? InventoryWeaponsView_1.default : AuthView_1.default;
        }
        static hasView() {
            return !!this.view;
        }
        static showDefaultView() {
            this.getDefaultView().show();
        }
        static showByHash(hash) {
            if (hash === this.view?.hash)
                return;
            if (hash === null)
                return this.showDefaultView();
            const view = registry[hash] ?? registry[Strings_9.default.sliceTo(hash, "/")];
            if (view?.redirectOnLoad === true || hash === "")
                return this.showDefaultView();
            else if (view?.redirectOnLoad)
                return this.showByHash(view.redirectOnLoad);
            if (!view) {
                if (this.actionRegistry[hash])
                    this.actionRegistry[hash]();
                else if (location.hash !== `#${hash}`)
                    console.warn(`Tried to navigate to an unknown view '${hash}'`);
                ErrorView_2.default.show(404);
                return;
            }
            const args = [];
            if (view !== registry[hash])
                args.push(Strings_9.default.trimTextMatchingFromEnd(Strings_9.default.sliceAfter(hash, "/"), "/"));
            view.show(...args);
        }
        static show(view) {
            if (this.view === view)
                return;
            const oldView = this.view;
            if (oldView) {
                oldView.event.emit("hide");
                this.event.emit("hide", { view: oldView });
                oldView.classes.add(View_16.default.Classes.Hidden);
                void Async_11.default.sleep(1000).then(() => oldView.remove());
            }
            this.view = view;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.view = view;
            view.appendTo(document.body);
            view.event.until("hide", manager => manager
                .subscribe("updateTitle", () => this.updateDocumentTitle(view))
                .subscribe("updateHash", () => this.updateHash(view))
                .subscribe("back", () => this.hide())
                .subscribe("initialise", () => this.event.emit("initialise", { view })));
            this.updateDocumentTitle(view);
            this.updateHash(view);
            this.event.emit("show", { view });
        }
        static get requiredAuth() {
            return !ViewManager.view ? "none" : ViewManager.view.definition.auth ?? "spy";
        }
        static updateHash(view) {
            if (view.definition.noHashChange)
                return;
            if (URL_4.default.path !== view.hash)
                URL_4.default.path = view.hash;
            if (URL_4.default.hash === URL_4.default.path)
                URL_4.default.hash = null;
        }
        static showItem(item) {
            if (item.definition.itemCategoryHashes?.includes(1378222069 /* ItemCategoryHashes.SeasonalArtifacts */))
                ArtifactView_1.default.show(item);
            else
                ItemView_3.default.show(item);
        }
        // public static showVendors () {
        // 	VendorsView.show();
        // }
        // public static showVendor (vendor: DeepsightVendorDefinition | VendorHashes | string) {
        // 	VendorView.show(typeof vendor === "number" ? `${vendor}` : vendor);
        // }
        static showCollections(item) {
            if (item)
                ItemView_3.default.showCollections(item);
            else
                CollectionsView_1.default.show();
        }
        static showItemTooltip(item) {
            ItemTooltipView_1.default.show(item);
        }
        static hide() {
            history.back();
        }
        static updateDocumentTitle(view) {
            let name = view.definition.name;
            if (typeof name === "function")
                name = name(...view._args.slice(1));
            const bungieId = URL_4.default.bungieID;
            const bungieIdSegment = !bungieId ? "" : ` / ${bungieId.name}#${`${bungieId.code}`.padStart(4, "0")}`;
            document.title = name ? `${name}${bungieIdSegment} // ${Constants_1.APP_NAME}` : Constants_1.APP_NAME;
        }
        static registerHashAction(hash, action) {
            this.actionRegistry[hash] = action;
            return this;
        }
    }
    ViewManager.event = EventManager_20.EventManager.make();
    ViewManager.actionRegistry = {};
    exports.default = ViewManager;
    window.addEventListener("popstate", event => {
        ViewManager.showByHash(URL_4.default.path ?? URL_4.default.hash);
        if (!ViewManager.hasView())
            ViewManager.showDefaultView();
    });
    Object.assign(window, { viewManager: ViewManager });
});
define("ui/view/appnav/AppInfo", ["require", "exports", "ui/TextLogo", "ui/component/Button", "ui/component/Component", "ui/component/Drawer", "ui/component/Loadable", "ui/utility/Classes", "ui/utility/LoadingManager", "ui/view/AboutView", "utility/Env"], function (require, exports, TextLogo_2, Button_25, Component_89, Drawer_6, Loadable_7, Classes_28, LoadingManager_5, AboutView_3, Env_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AppInfoClasses = void 0;
    var AppInfoClasses;
    (function (AppInfoClasses) {
        AppInfoClasses["Container"] = "app-info-container";
        AppInfoClasses["Drawer"] = "app-info-drawer";
        AppInfoClasses["LogoContainer"] = "app-info-logo-container";
        AppInfoClasses["Logo"] = "app-info-logo";
        AppInfoClasses["Title"] = "app-info-title";
        AppInfoClasses["Versions"] = "app-info-versions";
        AppInfoClasses["ApiDownWarning"] = "app-info-api-down-warning";
        AppInfoClasses["Links"] = "app-info-links";
        AppInfoClasses["Row"] = "app-info-row";
    })(AppInfoClasses || (exports.AppInfoClasses = AppInfoClasses = {}));
    class AppInfo extends Component_89.default {
        onMake() {
            this.classes.add(AppInfoClasses.Container);
            Loadable_7.default.create(LoadingManager_5.default.model)
                .onReady(() => Component_89.default.create()
                .classes.add(AppInfoClasses.Logo, Classes_28.Classes.Logo))
                .classes.add(AppInfoClasses.LogoContainer)
                .setSimple()
                .setPersistent()
                .prependTo(this);
            TextLogo_2.default.create()
                .classes.add(AppInfoClasses.Title)
                .appendTo(this);
            const appInfoDrawer = Drawer_6.default.create()
                .classes.add(AppInfoClasses.Drawer)
                .appendTo(this);
            appInfoDrawer.createPanel()
                .append(Component_89.default.create()
                .classes.add(Classes_28.Classes.ShowIfAPIDown, AppInfoClasses.ApiDownWarning)
                .append(Component_89.default.create("h3")
                .classes.add(Classes_28.Classes.WarningText)
                .text.set("Bungie API Error"))
                .append(Component_89.default.create("p")
                .text.set("I promise it's not my fault! Probably!"))
                .append(Component_89.default.create("p")
                .text.set("Consider checking ")
                .append(Component_89.default.create("a")
                .attributes.set("href", "https://twitter.com/BungieHelp")
                .attributes.set("target", "_blank")
                .text.set("Bungie Help"))
                .text.add(" on Twitter.")))
                .append(Component_89.default.create()
                .classes.add(AppInfoClasses.Row)
                .append(Component_89.default.create("label")
                .text.set("A fresh take on vault management..."))
                .append(Button_25.default.create()
                .text.set("About / FAQ")
                .event.subscribe("click", () => AboutView_3.default.show())))
                .append(Component_89.default.create()
                .classes.add(AppInfoClasses.Links)
                .append(Component_89.default.create("h3")
                .text.set("Feature requests? Bug reports?"))
                .append(Component_89.default.create("p")
                .text.add("Come chat on the ")
                .append(Component_89.default.create("a")
                .attributes.set("href", "https://discord.gg/dMFRMXZZnY")
                .attributes.set("target", "_blank")
                .text.set("Discord"))
                .text.add("!"))
                .append(Component_89.default.create("h3")
                .text.set("Open source!"))
                .append(Component_89.default.create("p")
                .text.add("Check out the project's ")
                .append(Component_89.default.create("a")
                .attributes.set("href", "https://github.com/ChiriVulpes/deepsight.gg")
                .attributes.set("target", "_blank")
                .text.set("GitHub"))
                .text.add("!")))
                .append(Component_89.default.create()
                .classes.add(Classes_28.Classes.SmallText, AppInfoClasses.Versions)
                .text.set("deepsight.gg /// ")
                .text.add(Env_11.default.DEEPSIGHT_BUILD_NUMBER ? `${Env_11.default.DEEPSIGHT_ENVIRONMENT === "beta" ? "beta " : ""}build #${Env_11.default.DEEPSIGHT_BUILD_NUMBER} // ${Env_11.default.DEEPSIGHT_BUILD_SHA?.slice(0, 7) ?? ""}` : "unknown build"));
            this.event.subscribe("click", () => appInfoDrawer.open("click"))
                .event.subscribe("mouseenter", () => appInfoDrawer.open("mouse"))
                .event.subscribe("mouseleave", () => appInfoDrawer.close("mouse"));
            document.body.addEventListener("click", event => {
                const element = event.target;
                if (!element?.closest(`.${AppInfoClasses.Container}`))
                    appInfoDrawer.close("click");
            });
        }
    }
    exports.default = AppInfo;
});
define("ui/AppNav", ["require", "exports", "ui/PlayerOverview", "ui/component/Button", "ui/component/Component", "ui/utility/Classes", "ui/utility/UiEventBus", "ui/view/appnav/AppInfo", "utility/Store", "utility/URL", "utility/decorator/Bound", "utility/endpoint/bungie/Bungie"], function (require, exports, PlayerOverview_1, Button_26, Component_90, Classes_29, UiEventBus_13, AppInfo_1, Store_20, URL_5, Bound_29, Bungie_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassesAppNav = void 0;
    var ClassesAppNav;
    (function (ClassesAppNav) {
        ClassesAppNav["Main"] = "app-nav";
        ClassesAppNav["IdentityContainer"] = "app-nav-identity-container";
        ClassesAppNav["Destinations"] = "app-nav-destinations";
        ClassesAppNav["Compress"] = "app-nav-compress";
        ClassesAppNav["DestinationsToggle"] = "app-nav-destinations-toggle";
        ClassesAppNav["DestinationsClose"] = "app-nav-destinations-close";
        ClassesAppNav["Destination"] = "app-nav-destination";
        ClassesAppNav["DestinationAuthRequired"] = "app-nav-destination-auth-required";
        ClassesAppNav["DestinationAuthSpy"] = "app-nav-destination-auth-spy";
        ClassesAppNav["DestinationNoAuthRequired"] = "app-nav-destination-no-auth-required";
        ClassesAppNav["DestinationChildActive"] = "app-nav-destination-child-active";
        ClassesAppNav["DestinationChildren"] = "app-nav-destination-children";
        ClassesAppNav["DocumentHasAppNav"] = "has-app-nav";
    })(ClassesAppNav || (exports.ClassesAppNav = ClassesAppNav = {}));
    class AppNav extends Component_90.default {
        onMake(viewManager) {
            this.destinationButtons = {};
            this.destinationDropdownWrappers = [];
            this.viewGrid = [];
            this.viewPos = { x: 0, y: 0 };
            this.classes.add(ClassesAppNav.Main);
            this.appInfo = AppInfo_1.default.create()
                .appendTo(this);
            viewManager.registerHashAction("overview", () => {
                viewManager.event.subscribeOnce("show", () => {
                    if (Bungie_8.default.authenticated)
                        URL_5.default.hash = "overview";
                });
            });
            PlayerOverview_1.default.create()
                .classes.add(ClassesAppNav.IdentityContainer)
                .insertToAfter(this, this.appInfo);
            this.destinationsWrapper = Component_90.default.create()
                .classes.add(ClassesAppNav.Destinations)
                .appendTo(this);
            Component_90.default.create()
                .classes.add(ClassesAppNav.DestinationsClose)
                .event.subscribe("click", () => this.destinationsWrapper.classes.remove(Classes_29.Classes.Active))
                .appendTo(this);
            Button_26.default.create()
                .classes.add(ClassesAppNav.DestinationsToggle)
                .event.subscribe("click", () => this.destinationsWrapper.classes.toggle(Classes_29.Classes.Active))
                .appendTo(this.destinationsWrapper);
            const viewTree = {};
            for (const destinationViewHandler of Object.values(viewManager.registry)) {
                if (destinationViewHandler.noDestinationButton)
                    continue;
                let name = destinationViewHandler.definition.name;
                if (typeof name === "function")
                    name = name();
                const authVisibility = destinationViewHandler.definition.auth ?? "spy";
                const destinationButton = this.destinationButtons[destinationViewHandler.id] = Button_26.default.create()
                    .classes.add(ClassesAppNav.Destination, `app-nav-destination-${destinationViewHandler.id}`)
                    .classes.toggle(authVisibility === "required", ClassesAppNav.DestinationAuthRequired)
                    .classes.toggle(authVisibility === "spy", ClassesAppNav.DestinationAuthSpy)
                    .classes.toggle(authVisibility === "none", ClassesAppNav.DestinationNoAuthRequired)
                    .text.set(name ?? "Unknown View")
                    .tweak(destinationViewHandler.initialiseDestinationButton)
                    .event.subscribe("click", () => destinationViewHandler.show());
                if (!destinationViewHandler.navGroupViewId) {
                    destinationButton.appendTo(this.destinationsWrapper);
                    const column = this.viewGrid.length;
                    this.viewGrid.push([destinationViewHandler]);
                    viewTree[destinationViewHandler.id] ??= { buttons: [], column };
                    continue;
                }
                const branch = viewTree[destinationViewHandler.navGroupViewId];
                branch.buttons.push(destinationButton);
                this.viewGrid[branch.column].push(destinationViewHandler);
            }
            for (const [navGroupViewId, branch] of Object.entries(viewTree)) {
                if (!branch.buttons.length)
                    continue;
                const navGroupViewDestinationButton = this.destinationButtons[navGroupViewId];
                if (!navGroupViewDestinationButton) {
                    console.warn("Tried to child destination button(s) to a nonexistent parent:", navGroupViewId);
                    continue;
                }
                this.destinationDropdownWrappers.push(Component_90.default.create()
                    .classes.add(ClassesAppNav.DestinationChildren, `app-nav-destination-${navGroupViewId}-parent`)
                    .append(...branch.buttons)
                    .insertToAfter(this.destinationsWrapper, navGroupViewDestinationButton)
                    .prepend(navGroupViewDestinationButton));
            }
            viewManager.event.subscribe("show", ({ view }) => this.showing(view));
            Store_20.default.event.subscribe("setSettingsEquipmentView", this.refreshDestinationButtons);
            this.refreshDestinationButtons();
            UiEventBus_13.default.subscribe("keydown", this.onGlobalKeydown);
        }
        refreshDestinationButtons() {
            let showing = 0;
            for (const [id, destinationButton] of Object.entries(this.destinationButtons)) {
                const destinationViewHandler = viewManager.registry[id];
                const hidden = destinationViewHandler.displayDestinationButton?.() === false;
                destinationButton.classes.toggle(hidden, Classes_29.Classes.Hidden);
                if (!hidden && !destinationViewHandler.navGroupViewId)
                    showing++;
            }
            this.classes.toggle(showing > 7, ClassesAppNav.Compress);
        }
        showing(view) {
            for (const button of Object.values(this.destinationButtons))
                button.classes.remove(Classes_29.Classes.Active);
            for (const wrapper of this.destinationDropdownWrappers)
                wrapper.classes.remove(ClassesAppNav.DestinationChildActive);
            this.destinationButtons[view.definition.id]?.classes.add(Classes_29.Classes.Active);
            if (view.definition.navGroupViewId)
                this.destinationButtons[view.definition.id]?.parent()?.classes.add(ClassesAppNav.DestinationChildActive);
            document.documentElement.classList.add(ClassesAppNav.DocumentHasAppNav);
            this.destinationsWrapper.classes.remove(Classes_29.Classes.Active);
            const x = this.viewGrid.findIndex(column => column.some(handler => handler.id === view.definition.id));
            const y = this.viewGrid[x]?.findIndex(handler => handler.id === view.definition.id);
            this.viewPos = { x, y };
        }
        isDestinationVisible(id) {
            return !!this.destinationButtons[id].element.offsetWidth;
        }
        getActualViewY() {
            return Math.max(0, this.viewGrid[this.viewPos.x]
                .filter(view => this.isDestinationVisible(view.id))
                .indexOf(this.viewGrid[this.viewPos.x][this.viewPos.y]));
        }
        changeViewX(amount) {
            for (let x = this.viewPos.x + amount; x >= 0 && x < this.viewGrid.length; x += amount) {
                const column = this.viewGrid[x].filter(view => this.isDestinationVisible(view.id));
                if (!column.length)
                    continue;
                const view = column[Math.min(this.getActualViewY(), column.length - 1)];
                view.show();
                return;
            }
        }
        changeViewY(amount) {
            const column = this.viewGrid[this.viewPos.x].filter(view => this.isDestinationVisible(view.id));
            if (!column.length)
                return;
            const y = this.getActualViewY();
            const newY = Math.max(0, Math.min(y + amount, column.length - 1));
            if (y === newY)
                return;
            column[newY].show();
        }
        onGlobalKeydown(event) {
            if (!document.contains(this.element)) {
                UiEventBus_13.default.unsubscribe("keydown", this.onGlobalKeydown);
                return;
            }
            if (this.viewPos.x === -1 || this.viewPos.y === -1)
                return;
            switch (event.key) {
                case "ArrowDown":
                    return this.changeViewY(1);
                case "ArrowUp":
                    return this.changeViewY(-1);
                case "ArrowRight":
                    return this.changeViewX(1);
                case "ArrowLeft":
                    return this.changeViewX(-1);
            }
        }
    }
    AppNav.defaultType = "nav";
    exports.default = AppNav;
    __decorate([
        Bound_29.default
    ], AppNav.prototype, "refreshDestinationButtons", null);
    __decorate([
        Bound_29.default
    ], AppNav.prototype, "onGlobalKeydown", null);
});
define("utility/Fonts", ["require", "exports", "ui/component/Component", "utility/Async"], function (require, exports, Component_91, Async_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Fonts;
    (function (Fonts) {
        const TEST_STRING = "mmmmm";
        const FONTS = {
            "neue-haas-grotesk": ["Neue Haas Grotesk Display Pro", "Neue Haas Grotesk Display", "Neue Haas Grotesk"],
        };
        async function check() {
            const monospaceSpan = Component_91.default.create("span")
                .style.set("font-family", "monospace")
                .style.set("opacity", "0")
                .style.set("user-select", "none")
                .style.set("pointer-events", "none")
                .style.set("font-size", "48px")
                .style.set("position", "absolute")
                .style.set("top", "0")
                .style.set("left", "0")
                .text.set(TEST_STRING)
                .appendTo(document.body);
            for (const [id, variants] of Object.entries(FONTS)) {
                const variantSpans = variants.map(variant => [variant, Component_91.default.create("span")
                        .style.set("font-family", `"${variant}", monospace`)
                        .style.set("opacity", "0")
                        .style.set("user-select", "none")
                        .style.set("pointer-events", "none")
                        .style.set("font-size", "48px")
                        .style.set("position", "absolute")
                        .style.set("top", "0")
                        .style.set("left", "0")
                        .text.set(TEST_STRING)
                        .appendTo(document.body)]);
                await Async_12.default.sleep(100);
                for (const [variant, span] of variantSpans) {
                    if (span.element.clientWidth !== monospaceSpan.element.clientWidth) {
                        Component_91.default.get(document.documentElement)
                            .style.set(`--font-${id}`, `"${variant}"`)
                            .classes.add(`has-font-${id}`);
                        break;
                    }
                }
                for (const [, span] of variantSpans) {
                    span.remove();
                }
            }
            monospaceSpan.remove();
        }
        Fonts.check = check;
    })(Fonts || (Fonts = {}));
    exports.default = Fonts;
});
define("DeepsightGG", ["require", "exports", "model/models/Activities", "ui/AppNav", "ui/component/BackgroundManager", "ui/utility/UiEventBus", "ui/utility/ViewManager", "ui/view/AuthView", "utility/BungieID", "utility/Env", "utility/Fonts", "utility/ProfileManager", "utility/Store", "utility/URL", "utility/decorator/Bound", "utility/endpoint/bungie/Bungie"], function (require, exports, Activities_2, AppNav_1, BackgroundManager_2, UiEventBus_14, ViewManager_1, AuthView_2, BungieID_6, Env_12, Fonts_1, ProfileManager_15, Store_21, URL_6, Bound_30, Bungie_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    void screen?.orientation?.lock?.("portrait-primary").catch(() => { });
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    window.Activities = Activities_2.default;
    class DeepsightGG {
        constructor() {
            void this.main();
        }
        async main() {
            UiEventBus_14.default.subscribe("keydown", event => {
                if (event.use("F6"))
                    for (const stylesheet of document.querySelectorAll("link[rel=stylesheet]")) {
                        const href = stylesheet.getAttribute("href");
                        const newHref = `${href.slice(0, Math.max(0, href.indexOf("?")) || Infinity)}?${Math.random().toString().slice(2)}`;
                        stylesheet.setAttribute("href", newHref);
                    }
                if (event.use("F4"))
                    document.documentElement.classList.add("persist-tooltips");
            });
            UiEventBus_14.default.subscribe("keyup", event => {
                if (event.use("F4"))
                    document.documentElement.classList.remove("persist-tooltips");
            });
            await Env_12.default.load();
            void Fonts_1.default.check();
            Bungie_9.default.event.subscribe(["resetAuthentication", "authenticated"], this.refreshProfileState);
            const didAuthenticate = Store_21.default.items.profiles?.[""] && await Bungie_9.default.authenticate("complete");
            if (didAuthenticate) {
                location.reload();
                return;
            }
            Bungie_9.default.event.subscribe("apiDown", () => document.body.classList.add("bungie-api-down"));
            Bungie_9.default.event.subscribe("querySuccess", () => document.body.classList.remove("bungie-api-down"));
            if (Bungie_9.default.authenticated) {
                document.documentElement.classList.add("authenticated");
            }
            void BackgroundManager_2.default.initialiseMain();
            const bungieId = URL_6.default.bungieID;
            const idString = bungieId && BungieID_6.default.stringify(bungieId);
            if (idString && (idString !== Store_21.default.items.selectedProfile || !ProfileManager_15.default.byId(idString))) {
                if (Store_21.default.items.profiles?.[idString]) {
                    Store_21.default.items.selectedProfile = idString;
                    location.reload();
                    return;
                }
                const path = URL_6.default.path;
                const profile = await ProfileManager_15.default.reinit(bungieId);
                Store_21.default.items.selectedProfile = profile ? idString : undefined;
                URL_6.default.path = path;
                location.reload();
                return;
            }
            if (!bungieId) {
                const profile = ProfileManager_15.default.get();
                if (profile) {
                    const path = URL_6.default.path;
                    Store_21.default.items.selectedProfile = BungieID_6.default.stringify(profile.id);
                    URL_6.default.path = path;
                }
            }
            this.refreshProfileState();
            Store_21.default.event.subscribe(["setSelectedProfile", "deleteSelectedProfile"], this.refreshProfileState);
            AppNav_1.default.create([ViewManager_1.default])
                .appendTo(document.body);
            const path = URL_6.default.path ?? URL_6.default.hash;
            if (path === AuthView_2.default.id) {
                URL_6.default.hash = null;
                URL_6.default.path = null;
            }
            ViewManager_1.default.showByHash(URL_6.default.path ?? URL_6.default.hash);
            const viewRequiredAuth = !ViewManager_1.default.view ? undefined : (ViewManager_1.default.view?.definition.auth ?? "spy");
            const needsAuthView = false
                || (viewRequiredAuth === "required" && !ProfileManager_15.default.isAuthenticated())
                || (viewRequiredAuth === "spy" && !ProfileManager_15.default.get())
                || false;
            if (needsAuthView)
                AuthView_2.default.show();
        }
        refreshProfileState() {
            const profile = ProfileManager_15.default.get();
            if (profile?.id)
                ProfileManager_15.default.update(profile.id);
            const authenticated = !!profile?.data.accessToken;
            const spying = !!profile && !authenticated;
            document.documentElement.classList.toggle("spying", spying);
            document.documentElement.classList.toggle("authenticated", authenticated);
        }
    }
    exports.default = DeepsightGG;
    __decorate([
        Bound_30.default
    ], DeepsightGG.prototype, "refreshProfileState", null);
});
define("utility/Define", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function Define(proto, key, implementation) {
        try {
            Object.defineProperty(proto, key, {
                configurable: true,
                writable: true,
                value: implementation,
            });
        }
        catch (err) {
        }
    }
    (function (Define) {
        function all(protos, key, implementation) {
            for (const proto of protos) {
                Define(proto, key, implementation);
            }
        }
        Define.all = all;
        function magic(obj, key, implementation) {
            try {
                Object.defineProperty(obj, key, {
                    configurable: true,
                    ...implementation,
                });
            }
            catch (err) {
            }
        }
        Define.magic = magic;
    })(Define || (Define = {}));
    exports.default = Define;
});
define("utility/DOMRect", ["require", "exports", "utility/Define"], function (require, exports, Define_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = default_2;
    function default_2() {
        Object.defineProperty(DOMRect.prototype, "centerX", {
            get() {
                return this.left + this.width / 2;
            },
        });
        Object.defineProperty(DOMRect.prototype, "centerY", {
            get() {
                return this.top + this.height / 2;
            },
        });
        (0, Define_1.default)(DOMRect.prototype, "containsPoint", function (x, y) {
            return x >= this.x && x < this.x + this.width
                && y >= this.y && y < this.y + this.height;
        });
    }
});
define("utility/prototype/ArrayPrototypes", ["require", "exports", "utility/Define"], function (require, exports, Define_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = applyPrototypes;
    function applyPrototypes() {
        (0, Define_2.default)(Array.prototype, "findLast", function (predicate) {
            if (this.length > 0)
                for (let i = this.length - 1; i >= 0; i--)
                    if (predicate(this[i], i, this))
                        return this[i];
            return undefined;
        });
        (0, Define_2.default)(Array.prototype, "findLastIndex", function (predicate) {
            if (this.length > 0)
                for (let i = this.length - 1; i >= 0; i--)
                    if (predicate(this[i], i, this))
                        return i;
            return -1;
        });
        const originalSort = Array.prototype.sort;
        (0, Define_2.default)(Array.prototype, "sort", function (...sorters) {
            if (this.length <= 1)
                return this;
            if (!sorters.length)
                return originalSort.call(this);
            return originalSort.call(this, (a, b) => {
                for (const sorter of sorters) {
                    if (!sorter)
                        continue;
                    if (sorter.length === 1) {
                        const mapper = sorter;
                        const sortValue = mapper(b) - mapper(a);
                        if (sortValue)
                            return sortValue;
                    }
                    else {
                        const sortValue = sorter(a, b);
                        if (sortValue)
                            return sortValue;
                    }
                }
                return 0;
            });
        });
        (0, Define_2.default)(Array.prototype, "collect", function (collector, ...args) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return collector?.(this, ...args);
        });
        (0, Define_2.default)(Array.prototype, "splat", function (collector, ...args) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return collector?.(...this, ...args);
        });
        (0, Define_2.default)(Array.prototype, "toObject", function (mapper) {
            return Object.fromEntries(mapper ? this.map(mapper) : this);
        });
        (0, Define_2.default)(Array.prototype, "toMap", function (mapper) {
            return new Map(mapper ? this.map(mapper) : this);
        });
        (0, Define_2.default)(Array.prototype, "distinct", function (mapper) {
            const result = [];
            const encountered = mapper ? [] : result;
            for (const value of this) {
                const encounterValue = mapper ? mapper(value) : value;
                if (encountered.includes(encounterValue))
                    continue;
                if (mapper)
                    encountered.push(encounterValue);
                result.push(value);
            }
            return result;
        });
        (0, Define_2.default)(Array.prototype, "findMap", function (predicate, mapper) {
            for (let i = 0; i < this.length; i++)
                if (predicate(this[i], i, this))
                    return mapper(this[i], i, this);
            return undefined;
        });
        (0, Define_2.default)(Array.prototype, "groupBy", function (grouper) {
            const result = {};
            for (let i = 0; i < this.length; i++)
                (result[String(grouper(this[i], i, this))] ??= []).push(this[i]);
            return Object.entries(result);
        });
    }
});
define("utility/prototype/IterableIteratorPrototypes", ["require", "exports", "utility/Define"], function (require, exports, Define_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = applyPrototypes;
    function applyPrototypes() {
        const prototypes = [
            Object.getPrototypeOf([][Symbol.iterator]()),
            Object.getPrototypeOf(new Map().values()),
            Object.getPrototypeOf(new Set().values()),
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            Object.getPrototypeOf(function* () { }).prototype,
        ];
        for (const prototype of prototypes) {
            (0, Define_3.default)(prototype, "toArray", function () {
                return [...this];
            });
        }
    }
});
define("utility/prototype/StringPrototypes", ["require", "exports", "utility/Define"], function (require, exports, Define_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = applyPrototypes;
    function applyPrototypes() {
        (0, Define_4.default)(String.prototype, "indexOfOrUndefined", function (substring, startAt) {
            const index = this.indexOf(substring, startAt);
            return index === -1 ? undefined : index;
        });
        (0, Define_4.default)(String.prototype, "lastIndexOfOrUndefined", function (substring, startAt) {
            const index = this.lastIndexOf(substring, startAt);
            return index === -1 ? undefined : index;
        });
    }
});
define("utility/prototype/WeakMapPrototypes", ["require", "exports", "utility/Define"], function (require, exports, Define_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = applyPrototypes;
    function applyPrototypes() {
        (0, Define_5.default)(WeakMap.prototype, "compute", function (key, computer) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            let value = this.get(key);
            if (value === undefined) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                value = computer(key);
                this.set(key, value);
            }
            return value;
        });
    }
});
define("index", ["require", "exports", "DeepsightGG", "utility/DOMRect", "utility/prototype/ArrayPrototypes", "utility/prototype/IterableIteratorPrototypes", "utility/prototype/StringPrototypes", "utility/prototype/WeakMapPrototypes"], function (require, exports, DeepsightGG_1, DOMRect_1, ArrayPrototypes_1, IterableIteratorPrototypes_1, StringPrototypes_1, WeakMapPrototypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    (0, DOMRect_1.default)();
    (0, StringPrototypes_1.default)();
    (0, ArrayPrototypes_1.default)();
    (0, WeakMapPrototypes_1.default)();
    (0, IterableIteratorPrototypes_1.default)();
    new DeepsightGG_1.default();
});
define("utility/endpoint/bungie/endpoint/destiny2/GetPGCR", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_12.default
        .at((activityId) => `/Destiny2/Stats/PostGameCarnageReport/${activityId}/`)
        .returning()
        .allowErrorStatus("DestinyPGCRNotFound")
        .setSubdomain("stats");
});
define("model/models/RecentPGCR", ["require", "exports", "model/Model", "model/models/Manifest", "utility/Async", "utility/Time", "utility/endpoint/bungie/endpoint/destiny2/GetPGCR"], function (require, exports, Model_24, Manifest_30, Async_13, Time_8, GetPGCR_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RecentPGCR;
    (function (RecentPGCR) {
        const RecentID = Model_24.default.create("recent pgcr", {
            cache: "Global",
            resetTime: "Daily",
            async generate() {
                let left = 14008975359;
                let right = 137438953470;
                let targetTime = new Date().setUTCHours(17, 0, 0, 0); // Destiny reset time
                if (targetTime > Date.now())
                    targetTime -= Time_8.default.days(1);
                let attempts = 0;
                while (true) {
                    attempts++;
                    console.debug("[PGCR Search] Current range:", left, right, "Query count:", attempts);
                    const mid = Math.floor((left + right) / 2);
                    const response = await GetPGCR_1.default.query(mid);
                    if ("period" in response) {
                        if (new Date(response.period).getTime() > targetTime)
                            return mid;
                        left = mid + 1;
                    }
                    else {
                        right = mid - 1;
                    }
                    if (attempts >= 100) {
                        console.error("[PGCR Search] Failed to find a recent PGCR.");
                        return undefined;
                    }
                    await Async_13.default.sleep(100);
                }
            },
        });
        /**
         * Starting at any PGCR created since the daily reset, searches one by one through them to find a match.
         * @param descriptor A human-readable descriptor
         * @param filter
         * @returns
         */
        async function search(descriptor, filter) {
            let id = await RecentID.await();
            if (id === undefined)
                return undefined;
            const { DestinyActivityDefinition } = await Manifest_30.default.await();
            let attempts = 0;
            while (true) {
                id++;
                attempts++;
                console.debug(`[PGCR Search] Searching for ${descriptor}. Query count:`, attempts);
                const pgcr = await GetPGCR_1.default.query(id);
                if (!("period" in pgcr))
                    continue;
                const activityDef = await DestinyActivityDefinition.get(pgcr.activityDetails.referenceId);
                if (!activityDef)
                    continue;
                if (filter(activityDef, pgcr)) {
                    console.log(`[PGCR Search] Found ${descriptor}:`, activityDef.displayProperties?.name, activityDef, pgcr);
                    return { pgcr, activityDef };
                }
                if (attempts >= 500) {
                    console.error(`[PGCR Search] Failed to find ${descriptor}...`);
                    return undefined;
                }
                await Async_13.default.sleep(100);
            }
        }
        RecentPGCR.search = search;
    })(RecentPGCR || (RecentPGCR = {}));
    exports.default = RecentPGCR;
});
define("utility/endpoint/bungie/endpoint/GetCoreSettings", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_13.default.at("/Settings/")
        .returning();
});
define("model/models/Settings", ["require", "exports", "model/Model", "utility/endpoint/bungie/endpoint/GetCoreSettings"], function (require, exports, Model_25, GetCoreSettings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Model_25.default.create("settings", {
        cache: "Global",
        resetTime: "Daily",
        generate: _ => GetCoreSettings_1.default.query(),
    });
});
define("ui/component/form/Dropdown", ["require", "exports", "ui/component/Button", "ui/component/Component", "utility/decorator/Bound"], function (require, exports, Button_27, Component_92, Bound_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DropdownOption = exports.DropdownClasses = void 0;
    var DropdownClasses;
    (function (DropdownClasses) {
        DropdownClasses["Main"] = "dropdown";
        DropdownClasses["Label"] = "dropdown-label";
        DropdownClasses["Container"] = "dropdown-container";
        DropdownClasses["Option"] = "dropdown-option";
        DropdownClasses["OptionActive"] = "dropdown-option-active";
    })(DropdownClasses || (exports.DropdownClasses = DropdownClasses = {}));
    class Dropdown extends Component_92.default {
        onMake() {
            this.classes.add(DropdownClasses.Main);
            this.attributes.set("tabindex", "0");
            this.options = [];
            this.activeReasons = new Set();
            this.container = Component_92.default.create()
                .classes.add(DropdownClasses.Container)
                .appendTo(Component_92.default.create()
                .appendTo(this));
            this.event.subscribe("mouseenter", this.onMouseEnter);
            this.event.subscribe("focus", this.onFocus);
            this.event.subscribe("blur", this.onBlur);
        }
        addLabel(initialiser) {
            Component_92.default.create("label")
                .classes.add(DropdownClasses.Label)
                .tweak(initialiser)
                .prependTo(this);
            return this;
        }
        addOption(initialiser) {
            const option = DropdownOption.create()
                .attributes.add("inert");
            this.activeOption ??= option.classes.add(DropdownClasses.OptionActive);
            this.options.push(option);
            option.tweak(initialiser)
                .appendTo(this.container);
            option.event.subscribe("click", event => this.onOptionClick(option, event));
            setTimeout(() => {
                this.style.set("--content-width", `${this.container.element.clientWidth}px`);
            }, 10);
            return this;
        }
        setActive(reason) {
            if (!this.activeReasons.size) {
                for (const option of this.options) {
                    option.attributes.remove("inert");
                }
            }
            this.activeReasons.add(reason);
        }
        setInactive(reason) {
            this.activeReasons.delete(reason);
            if (!this.activeReasons.size) {
                for (const option of this.options) {
                    option.attributes.add("inert");
                }
            }
        }
        onOptionClick(option, event) {
            this.activeOption.classes.remove(DropdownClasses.OptionActive);
            this.activeOption = option.classes.add(DropdownClasses.OptionActive);
            this.event.emit("change");
        }
        onMouseEnter(event) {
            window.addEventListener("mousemove", this.onMouseMove);
            this.setActive("mouse");
        }
        onMouseMove(event) {
            const target = event.target;
            if (target?.closest(`.${DropdownClasses.Main}`) !== this.element) {
                window.removeEventListener("mousemove", this.onMouseMove);
                this.setInactive("mouse");
            }
        }
        onFocus(event) {
            window.addEventListener("keypress", this.onKeypress);
        }
        onBlur(event) {
            window.removeEventListener("keypress", this.onKeypress);
        }
        onKeypress(event) {
            if (event.key === " " || event.key === "Enter") {
                event.preventDefault();
                this.setActive("keyboard");
                document.addEventListener("focusin", this.onActiveElementChange);
            }
        }
        onActiveElementChange(event) {
            if (document.activeElement?.closest(`.${DropdownClasses.Main}`) !== this.element) {
                this.setInactive("keyboard");
                document.removeEventListener("focusin", this.onActiveElementChange);
            }
        }
    }
    exports.default = Dropdown;
    __decorate([
        Bound_31.default
    ], Dropdown.prototype, "onMouseEnter", null);
    __decorate([
        Bound_31.default
    ], Dropdown.prototype, "onMouseMove", null);
    __decorate([
        Bound_31.default
    ], Dropdown.prototype, "onFocus", null);
    __decorate([
        Bound_31.default
    ], Dropdown.prototype, "onBlur", null);
    __decorate([
        Bound_31.default
    ], Dropdown.prototype, "onKeypress", null);
    __decorate([
        Bound_31.default
    ], Dropdown.prototype, "onActiveElementChange", null);
    class DropdownOption extends Button_27.default {
        onMake() {
            this.classes.add(DropdownClasses.Option);
        }
    }
    exports.DropdownOption = DropdownOption;
});
define("ui/view/collections/vendor/VendorDisplay", ["require", "exports", "ui/component/Button", "ui/component/Component"], function (require, exports, Button_28, Component_93) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VendorDisplayClasses = void 0;
    var VendorDisplayClasses;
    (function (VendorDisplayClasses) {
        VendorDisplayClasses["Main"] = "vendor-display";
        VendorDisplayClasses["Title"] = "vendor-display-title";
        VendorDisplayClasses["TitleText"] = "vendor-display-title-text";
        VendorDisplayClasses["TitleBox"] = "vendor-display-title-box";
        VendorDisplayClasses["TitleHasDescription"] = "vendor-display-title--has-description";
        VendorDisplayClasses["Subtitle"] = "vendor-display-subtitle";
        VendorDisplayClasses["Description"] = "vendor-display-description";
        VendorDisplayClasses["DescriptionText"] = "vendor-display-description-text";
        VendorDisplayClasses["Button"] = "vendor-display-button";
    })(VendorDisplayClasses || (exports.VendorDisplayClasses = VendorDisplayClasses = {}));
    class VendorDisplay extends Component_93.default {
        onMake(vendor, description = true) {
            this.classes.add(VendorDisplayClasses.Main);
            Component_93.default.create()
                .classes.add(VendorDisplayClasses.Subtitle)
                .text.set(vendor.displayProperties.subtitle)
                .appendTo(this);
            const hasDescription = description && !!vendor.displayProperties.description && vendor.displayProperties.description !== vendor.displayProperties.subtitle;
            Component_93.default.create()
                .classes.add(VendorDisplayClasses.Title)
                .classes.toggle(hasDescription, VendorDisplayClasses.TitleHasDescription)
                .append(Component_93.default.create()
                .classes.add(VendorDisplayClasses.TitleText)
                .text.set(vendor.displayProperties.name))
                .append(Component_93.default.create()
                .classes.add(VendorDisplayClasses.TitleBox))
                .appendTo(this);
            if (hasDescription)
                Component_93.default.create()
                    .classes.add(VendorDisplayClasses.Description)
                    .append(Component_93.default.create()
                    .classes.add(VendorDisplayClasses.DescriptionText)
                    .text.set(vendor.displayProperties.description))
                    .appendTo(this);
        }
    }
    (function (VendorDisplay) {
        class Button extends Button_28.default {
            onMake(vendor) {
                super.onMake(vendor);
                this.classes.add(VendorDisplayClasses.Button);
                this.display = VendorDisplay.create([vendor])
                    .appendTo(this);
            }
        }
        VendorDisplay.Button = Button;
    })(VendorDisplay || (VendorDisplay = {}));
    exports.default = VendorDisplay;
});
define("ui/view/collections/VendorView", ["require", "exports", "model/Model", "model/models/Manifest", "model/models/items/Item", "ui/component/Card", "ui/component/Component", "ui/component/Paginator", "ui/destiny/component/IItemComponent", "ui/destiny/component/ItemComponent", "ui/destiny/component/Slot", "ui/utility/DisplayProperties", "ui/utility/LoadingManager", "ui/view/ErrorView", "ui/view/View", "ui/view/collections/vendor/VendorDisplay", "utility/Objects"], function (require, exports, Model_26, Manifest_31, Item_9, Card_12, Component_94, Paginator_5, IItemComponent_9, ItemComponent_9, Slot_7, DisplayProperties_20, LoadingManager_6, ErrorView_3, View_17, VendorDisplay_1, Objects_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VendorViewClasses = void 0;
    exports.resolveVendorURL = resolveVendorURL;
    function getId(vendor) {
        return vendor.displayProperties.name
            ?.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .toLowerCase()
            .replace(/'/g, "")
            .replace(/[^a-z0-9_-]+/g, "-");
    }
    async function resolveVendorURL(vendorId, api) {
        // const manifest = await api.subscribeProgressAndWait(Manifest, 1);
        // const { DeepsightVendorDefinition } = manifest;
        // const vendors = await DeepsightVendorDefinition.all();
        // const searchHash = +vendorId;
        // return vendors.find(vendor => vendor.hash === searchHash
        // 	|| vendorId === getId(vendor));
        return undefined;
    }
    var VendorViewClasses;
    (function (VendorViewClasses) {
        VendorViewClasses["Information"] = "view-vendor-information";
        VendorViewClasses["Wares"] = "view-vendor-wares";
        VendorViewClasses["WaresBackdrop2"] = "view-vendor-wares-backdrop-2";
        VendorViewClasses["CategoryPaginator"] = "view-vendor-category-paginator";
        VendorViewClasses["CategoryPaginatorPageWrapper"] = "view-vendor-category-paginator-page-wrapper";
        VendorViewClasses["CategoryPaginatorPage"] = "view-vendor-category-paginator-page";
        VendorViewClasses["Category"] = "view-vendor-category";
        VendorViewClasses["CategoryContent"] = "view-vendor-category-content";
    })(VendorViewClasses || (exports.VendorViewClasses = VendorViewClasses = {}));
    const vendorViewBase = View_17.default.create({
        models: (vendor) => [Manifest_31.default, Model_26.default.createTemporary(async (api) => typeof vendor !== "string" ? vendor : resolveVendorURL(vendor, api), "resolveVendorURL")],
        id: "vendor",
        hash: (vendor) => typeof vendor === "string" ? `vendor/${vendor}` : `vendor/${getId(vendor)}`,
        name: (vendor) => typeof vendor === "string" ? "Vendor Details" : DisplayProperties_20.default.name(vendor, "Vendor Details"),
        noDestinationButton: true,
        auth: "optional",
        initialise: async (view, manifest, vendorResult) => {
            LoadingManager_6.default.end(view.definition.id);
            const vendor = vendorResult;
            if (!vendor) {
                return ErrorView_3.default.show(404, {
                    title: "Error: No Vendor Found",
                    subtitle: "Your ghost continues its search...",
                    buttonText: "View Collections",
                    buttonClick: () => viewManager.showCollections(),
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            window.$i = window.vendor = vendor;
            console.log(DisplayProperties_20.default.name(vendor), vendor);
            if (vendor.background)
                view.setBackground(`../.${vendor.background}`).setUnfiltered(true);
            VendorDisplay_1.default.Button.create([vendor])
                // .event.subscribe("click", () => viewManager.showVendors())
                .appendTo(view.content);
            const appendItemSlot = async (to, itemRef, initialiser) => {
                const itemDef = await manifest.DestinyInventoryItemDefinition.get(itemRef.itemHash);
                if (!itemDef)
                    return;
                const item = await Item_9.default.createFake(manifest, { itemComponents: itemRef.itemComponent }, itemDef, undefined, `${itemRef.vendorItemIndex}`);
                const itemComponent = ItemComponent_9.default.create([])
                    .appendTo(Slot_7.default.create().appendTo(to));
                await itemComponent.setItem(item);
                initialiser?.(itemComponent);
            };
            const informationIndex = vendor.categories.findIndex(category => false
                || category.identifier.endsWith(".help.name")
                || category.items.some(item => DisplayProperties_20.default.name(item) === "Event Information")); // TODO this should be fixed in the vendor manifest
            const informationCategory = vendor.categories[informationIndex];
            const categories = vendor.categories.filter(category => category !== informationCategory);
            if (informationCategory)
                Component_94.default.create()
                    .classes.add(VendorViewClasses.Information)
                    .tweak(appendItemSlot, informationCategory.items[0], item => item.classes.add(IItemComponent_9.ItemClasses.Borderless))
                    .appendTo(view.content);
            const wares = Component_94.default.create()
                .classes.add(VendorViewClasses.Wares)
                .append(Component_94.default.create()
                .classes.add(VendorViewClasses.WaresBackdrop2))
                .appendTo(view.content);
            const categoryPaginator = Paginator_5.default.create()
                .classes.add(VendorViewClasses.CategoryPaginator)
                .appendTo(wares);
            categoryPaginator.pageWrapper.classes.add(VendorViewClasses.CategoryPaginatorPageWrapper);
            const filler = categoryPaginator.filler(16);
            for (const category of categories) {
                const categorySection = Card_12.default.create()
                    .classes.add(VendorViewClasses.Category, `${VendorViewClasses.Category}-${category.identifier.toLowerCase().replace(/[^a-z]+/g, "-")}`)
                    .setDisplayMode(Card_12.CardClasses.DisplayModeSection);
                categorySection.content.classes.add(VendorViewClasses.CategoryContent);
                let size = 0;
                if (category.displayProperties.name) {
                    size++;
                    Component_94.default.create()
                        .tweak(DisplayProperties_20.default.applyDescription, category.displayProperties.name, { singleLine: true })
                        .appendTo(categorySection.title);
                }
                let catItemsSize = 0;
                for (const itemRef of category.items) {
                    await appendItemSlot(categorySection.content, itemRef);
                    catItemsSize += 1 / 7;
                }
                size += Math.ceil(catItemsSize) * 2;
                categorySection.appendTo(filler.add(size, page => page.classes.add(VendorViewClasses.CategoryPaginatorPage)));
            }
        },
    });
    class VendorViewClass extends View_17.default.Handler {
    }
    const VendorView = Objects_8.default.inherit(vendorViewBase, VendorViewClass);
    exports.default = VendorView;
});
define("ui/view/collections/VendorsView", ["require", "exports", "model/models/Manifest", "ui/component/Component", "ui/view/View", "ui/view/collections/VendorView", "ui/view/collections/vendor/VendorDisplay"], function (require, exports, Manifest_32, Component_95, View_18, VendorView_1, VendorDisplay_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VendorsViewClasses = void 0;
    var VendorsViewClasses;
    (function (VendorsViewClasses) {
        VendorsViewClasses["Vendor"] = "view-vendors-vendor";
        VendorsViewClasses["GroupTitle"] = "view-vendors-group-title";
    })(VendorsViewClasses || (exports.VendorsViewClasses = VendorsViewClasses = {}));
    exports.default = View_18.default.create({
        models: [Manifest_32.default],
        id: "vendors",
        name: "Vendors",
        auth: "optional",
        noProfileInURL: true,
        navGroupViewId: "collections",
        initialise: async (view, Manifest) => {
            const vendors = [];
            // (await Manifest.DeepsightVendorDefinition.all())
            // .sort((a, b) => (a.displayProperties.name ?? "").localeCompare(b.displayProperties.name ?? ""))
            // .sort((a, b) => (b.moment ?? Infinity) - (a.moment ?? Infinity));
            for (const group of [3227191227 /* VendorGroupHashes.LimitedTime */, 427939601 /* VendorGroupHashes.Seasonal */, 679769104 /* VendorGroupHashes.Tower */, 2537374699 /* VendorGroupHashes.Destination */]) {
                const groupDef = await Manifest.DestinyVendorGroupDefinition.get(group);
                const groupVendors = vendors.filter(vendor => vendor.groups.includes(group));
                if (!groupVendors.length)
                    continue;
                Component_95.default.create()
                    .classes.add(View_18.default.Classes.Title, VendorsViewClasses.GroupTitle)
                    .text.set(groupDef?.categoryName)
                    .appendTo(view.content);
                for (const vendor of groupVendors) {
                    VendorDisplay_2.default.Button.create([vendor])
                        .classes.add(VendorsViewClasses.Vendor)
                        .event.subscribe("click", () => VendorView_1.default.show(vendor))
                        .appendTo(view.content);
                }
            }
        },
    });
});
define("ui/view/item/ItemMods", ["require", "exports", "ui/view/item/ItemSockets"], function (require, exports, ItemSockets_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // export enum ItemModsClasses {
    // 	Mod = "view-item-socket-plug-mod",
    // }
    class ItemMods extends ItemSockets_4.default {
        getTitle() {
            return "Weapon Mods";
        }
        initialise() {
            this.addSocketsByType("Mod");
        }
    }
    exports.default = ItemMods;
});
define("utility/endpoint/bungie/endpoint/destiny2/GetCharacter", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_14.default
        .at((membershipType, destinyMembershipId, characterId, components) => `/Destiny2/${membershipType}/Profile/${destinyMembershipId}/Character/${characterId}/`)
        .request((membershipType, destinyMembershipId, characterId, components) => ({
        search: {
            components: components.join(","),
        },
    }))
        .returning();
});
define("utility/endpoint/bungie/endpoint/destiny2/GetVendor", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint"], function (require, exports, BungieEndpoint_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_15.default
        .at((membershipType, destinyMembershipId, characterId, vendorHash, components) => `/Destiny2/${membershipType}/Profile/${destinyMembershipId}/Character/${characterId}/Vendors/${vendorHash}/`)
        .request((membershipType, destinyMembershipId, characterId, vendorHash, components) => ({
        search: {
            components: components.join(","),
        },
    }))
        .returning();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/loadout/ClearLoadout", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_16, ProfileManager_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_16.default
        .at("/Destiny2/Actions/Loadouts/ClearLoadout/")
        .request((character, index) => ({
        method: "POST",
        body: {
            loadoutIndex: index,
            characterId: character,
            membershipType: ProfileManager_16.default.get()?.data.membershipType,
        },
    }))
        .endpoint();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/loadout/EquipLoadout", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_17, ProfileManager_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_17.default
        .at("/Destiny2/Actions/Loadouts/EquipLoadout/")
        .request((character, index) => ({
        method: "POST",
        body: {
            loadoutIndex: index,
            characterId: character,
            membershipType: ProfileManager_17.default.get()?.data.membershipType,
        },
    }))
        .endpoint();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/loadout/UpdateLoadoutIdentifiers", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_18, ProfileManager_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_18.default
        .at("/Destiny2/Actions/Loadouts/SnapshotLoadout/")
        .request((character, index, identifiers) => ({
        method: "POST",
        body: {
            loadoutIndex: index,
            characterId: character,
            membershipType: ProfileManager_18.default.get()?.data.membershipType,
            ...identifiers,
        },
    }))
        .endpoint();
});
define("utility/endpoint/bungie/endpoint/destiny2/actions/loadout/SnapshotLoadout", ["require", "exports", "utility/endpoint/bungie/BungieEndpoint", "utility/ProfileManager"], function (require, exports, BungieEndpoint_19, ProfileManager_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = BungieEndpoint_19.default
        .at("/Destiny2/Actions/Loadouts/SnapshotLoadout/")
        .request((character, index, options) => ({
        method: "POST",
        body: {
            loadoutIndex: index,
            characterId: character,
            membershipType: ProfileManager_19.default.get()?.data.membershipType,
            ...options,
        },
    }))
        .endpoint();
});
define("utility/endpoint/deepsight/endpoint/GetDeepsightVendorDefinition", ["require", "exports", "utility/endpoint/deepsight/DeepsightEndpoint"], function (require, exports, DeepsightEndpoint_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new DeepsightEndpoint_16.default("DeepsightVendorDefinition.json");
});
